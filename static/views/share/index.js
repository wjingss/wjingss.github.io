webpackJsonp([5],{

/***/ 1:
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function() {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\tvar result = [];\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar item = this[i];\n\t\t\tif(item[2]) {\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t} else {\n\t\t\t\tresult.push(item[1]);\n\t\t\t}\n\t\t}\n\t\treturn result.join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvYmFieWZhbi9Eb2N1bWVudHMvcHJvamVjdC90cnVlY29sb3Ivfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz83YjIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9iYWJ5ZmFuL0RvY3VtZW50cy9wcm9qZWN0L3RydWVjb2xvci9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),

/***/ 10:
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(11)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzPzg2ODEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24pIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYmFieWZhbi9Eb2N1bWVudHMvcHJvamVjdC90cnVlY29sb3Ivfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),

/***/ 106:
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(54);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"db9dd392\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../../../../node_modules/css-loader/index.js?sourceMap!../../../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"id\\\":\\\"data-v-dd0d184a\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":true}!./index.css\", function() {\n     var newContent = require(\"!!../../../../../../node_modules/css-loader/index.js?sourceMap!../../../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"id\\\":\\\"data-v-dd0d184a\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":true}!./index.css\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlld3Mvc2hhcmUvaW5kZXguY3NzP2EwNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1kZDBkMTg0YVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi9pbmRleC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcImRiOWRkMzkyXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1kZDBkMTg0YVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi9pbmRleC5jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWRkMGQxODRhXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuL2luZGV4LmNzc1wiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vdnVlLXN0eWxlLWxvYWRlciEvVXNlcnMvYmFieWZhbi9Eb2N1bWVudHMvcHJvamVjdC90cnVlY29sb3Ivfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEvVXNlcnMvYmFieWZhbi9Eb2N1bWVudHMvcHJvamVjdC90cnVlY29sb3Ivfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWRkMGQxODRhXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOnRydWV9IS4vc3JjL2NvbXBvbmVudHMvdmlld3Mvc2hhcmUvaW5kZXguY3NzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///106\n");

/***/ }),

/***/ 107:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(3))(3);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBsaWJzX2U4ZGIzOWU2P2JiM2UiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzKSkoMyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIGxpYnNfZThkYjM5ZTZcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///107\n");

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzNmMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n");

/***/ }),

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(106)\n\nvar Component = __webpack_require__(9)(\n  /* script */\n  __webpack_require__(44),\n  /* template */\n  __webpack_require__(99),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/babyfan/Documents/project/truecolor/apps/truecolor/src/components/views/share/index.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] index.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-dd0d184a\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-dd0d184a\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9pbmRleC52dWU/MzEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1kZDBkMTg0YVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi9pbmRleC5jc3NcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vaW5kZXguanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWRkMGQxODRhXFxcIn0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL2FwcHMvdHJ1ZWNvbG9yL3NyYy9jb21wb25lbnRzL3ZpZXdzL3NoYXJlL2luZGV4LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGluZGV4LnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1kZDBkMTg0YVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWRkMGQxODRhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3ZpZXdzL3NoYXJlL2luZGV4LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),

/***/ 38:
/***/ (function(module, exports) {

eval("module.exports = \"static/assets/bg.26d5c483.png\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9hc3NldHMvYmcucG5nPzU2MmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcInN0YXRpYy9hc3NldHMvYmcuMjZkNWM0ODMucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9hc3NldHMvYmcucG5nXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n");

/***/ }),

/***/ 44:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_html2canvas__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_html2canvas___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_html2canvas__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_dic__ = __webpack_require__(2);\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            url1: __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].selectImg[0] ? __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].selectImg[0] : __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].dicImg[0],\n            url2: __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].selectImg[1] ? __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].selectImg[1] : __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].dicImg[1],\n            num: Math.floor(Math.random() * 6)\n        };\n    },\n\n    computed: {\n        imgShare: function imgShare() {\n            var img = __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].result[this.num].img;\n\n            return img;\n        },\n        spanShare: function spanShare() {\n            var span = __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].result[this.num].descp;\n\n            __WEBPACK_IMPORTED_MODULE_2__utils_dic__[\"default\"].sharedescp = this.num;\n\n            return span;\n        }\n    },\n    methods: {\n        share: function share() {\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.share-cover').toggle();\n        },\n        crop: function crop() {\n            __WEBPACK_IMPORTED_MODULE_1_html2canvas___default()(document.getElementById('share'), {\n                allowTaint: true,\n                taintTest: false,\n                onrendered: function onrendered(canvas) {\n                    canvas.id = 'mycanvas';\n\n                    var dataUrl = canvas.toDataURL('image/png', 1.0);\n                    var newImg = document.createElement('img');\n\n                    newImg.id = 'cropImg';\n\n                    newImg.src = dataUrl;\n                    document.body.appendChild(newImg);\n                }\n            });\n\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.share__button__right').css('display', 'none');\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.share__button__save').css('display', 'block');\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvdmlld3Mvc2hhcmUvaW5kZXguanM/NzM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IGh0bWwyY2FudmFzIGZyb20gJ2h0bWwyY2FudmFzJztcbmltcG9ydCBkaWMgZnJvbSAnLi4vLi4vdXRpbHMvZGljJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmwxOiBkaWMuc2VsZWN0SW1nWzBdID8gZGljLnNlbGVjdEltZ1swXSA6IGRpYy5kaWNJbWdbMF0sXG4gICAgICAgICAgICB1cmwyOiBkaWMuc2VsZWN0SW1nWzFdID8gZGljLnNlbGVjdEltZ1sxXSA6IGRpYy5kaWNJbWdbMV0sXG4gICAgICAgICAgICBudW06IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDYpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBpbWdTaGFyZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGRpYy5yZXN1bHRbdGhpcy5udW1dLmltZztcblxuICAgICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgfSxcblxuICAgICAgICBzcGFuU2hhcmUoKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gZGljLnJlc3VsdFt0aGlzLm51bV0uZGVzY3A7XG5cbiAgICAgICAgICAgIGRpYy5zaGFyZWRlc2NwID0gdGhpcy5udW07XG5cbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHNoYXJlKCkge1xuICAgICAgICAgICAgJCgnLnNoYXJlLWNvdmVyJykudG9nZ2xlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JvcCgpIHtcbiAgICAgICAgICAgIGh0bWwyY2FudmFzKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGFyZScpLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dUYWludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YWludFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9ucmVuZGVyZWQ6IChjYW52YXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmlkID0gJ215Y2FudmFzJztcblxuICAgICAgICAgICAgICAgICAgICAvLyDnlJ/miJBiYXNlNjTlm77niYfmlbDmja5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycsIDEuMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld0ltZy5pZCA9ICdjcm9wSW1nJztcblxuICAgICAgICAgICAgICAgICAgICBuZXdJbWcuc3JjID0gZGF0YVVybDtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuZXdJbWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCcuc2hhcmVfX2J1dHRvbl9fcmlnaHQnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgJCgnLnNoYXJlX19idXR0b25fX3NhdmUnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvdmlld3Mvc2hhcmUvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUF6QkE7QUF2QkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n");

/***/ }),

/***/ 54:
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".share {\\n  height: 100%;\\n  background: url(\" + __webpack_require__(38) + \") no-repeat;\\n  background-size: 100% 100%;\\n}\\n\\n#share {\\n  height: 100%;\\n  background: url(\" + __webpack_require__(38) + \") no-repeat;\\n  background-size: 100% 100%;\\n}\\n\\n.share__button {\\n  position: absolute;\\n  width: 5.933333rem;\\n  height: 0.666667rem;\\n  left: 50%;\\n  margin-left: -2.966667rem;\\n  bottom: 2%;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: justify;\\n  -webkit-justify-content: space-between;\\n  -ms-flex-pack: justify;\\n  justify-content: space-between;\\n  text-align: center;\\n  line-height: 0.666667rem;\\n  z-index: 88;\\n}\\n\\n.share__button__left {\\n  width: 2.466667rem;\\n  height: 0.666667rem;\\n  background-color: #efded5;\\n  border: 0.013333rem solid #fff;\\n  border-radius: 0.133333rem;\\n  color: rgb(150, 83, 49);\\n}\\n\\n[data-dpr=\\\"1\\\"] .share__button__left {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share__button__left {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share__button__left {\\n  font-size: 45px;\\n}\\n\\n.share__button__right {\\n  width: 3.333333rem;\\n  height: 0.666667rem;\\n  background-color: #efded5;\\n  border: 0.013333rem solid #fff;\\n  border-radius: 0.133333rem;\\n  color: rgb(150, 83, 49);\\n}\\n\\n[data-dpr=\\\"1\\\"] .share__button__right {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share__button__right {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share__button__right {\\n  font-size: 45px;\\n}\\n\\n.share__button__save {\\n  width: 3.333333rem;\\n  height: 0.666667rem;\\n  background-color: #efded5;\\n  border: 0.013333rem solid #fff;\\n  border-radius: 0.133333rem;\\n  color: rgb(150, 83, 49);\\n  display: none;\\n}\\n\\n[data-dpr=\\\"1\\\"] .share__button__save {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share__button__save {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share__button__save {\\n  font-size: 45px;\\n}\\n\\n.share-cover {\\n  width: 100%;\\n  height: 100%;\\n  position: fixed;\\n  display: none;\\n  background: url(\" + __webpack_require__(75) + \") no-repeat;\\n  background-size: 100% 100%;\\n  z-index: 99;\\n}\\n\\n.share-shining {\\n  background: url(\" + __webpack_require__(76) + \") no-repeat;\\n  background-size: 100% 100%;\\n  width: 4rem;\\n  height: 4rem;\\n  position: fixed;\\n  bottom: 0;\\n  left: 50%;\\n  margin-left: -2rem;\\n  margin-bottom: 10%;\\n  -webkit-animation: shining 3s;\\n  animation: shining 3s;\\n  -webkit-animation-iteration-count: 5;\\n  animation-iteration-count: 5;\\n  z-index: 3;\\n  overflow: hidden;\\n}\\n\\n@-webkit-keyframes shining {\\n  0% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n\\n  50% {\\n    -webkit-transform: scale(2, 2);\\n    transform: scale(2, 2);\\n  }\\n\\n  100% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n}\\n\\n@keyframes shining {\\n  0% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n\\n  50% {\\n    -webkit-transform: scale(2, 2);\\n    transform: scale(2, 2);\\n  }\\n\\n  100% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n}\\n\\n.share-middle {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n}\\n\\n.share-middle-cover {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  background: url(\" + __webpack_require__(38) + \") no-repeat;\\n  background-size: 100% 100%;\\n  z-index: 2;\\n}\\n\\n.share-middle-left {\\n  position: absolute;\\n  width: 34.4%;\\n  height: 25.8%;\\n  top: 30%;\\n  left: 12%;\\n}\\n\\n.share-middle-right {\\n  position: absolute;\\n  width: 34.4%;\\n  height: 25.8%;\\n  top: 30%;\\n  right: 12%;\\n}\\n\\n.share-img {\\n  position: absolute;\\n  width: 60%;\\n  height: 15%;\\n  bottom: 0;\\n  margin-bottom: 20%;\\n  left: 20%;\\n  z-index: 3;\\n}\\n\\n.share-img img {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.share-span {\\n  position: absolute;\\n  z-index: 3;\\n  bottom: 34%;\\n  color: rgb(150, 83, 49);\\n  left: 5%;\\n}\\n\\n[data-dpr=\\\"1\\\"] .share-span {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share-span {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share-span {\\n  font-size: 45px;\\n}\\n\\n#cropImg {\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  z-index: 3;\\n}\", \"\", {\"version\":3,\"sources\":[\"/Users/babyfan/Documents/project/truecolor/apps/truecolor/src/components/views/share/<input css 6>\"],\"names\":[],\"mappings\":\"AAAA;EACE,aAAa;EACb,oDAA2C;EAC3C,2BAA2B;CAC5B;;AAED;EACE,aAAa;EACb,oDAA2C;EAC3C,2BAA2B;CAC5B;;AAED;EACE,mBAAmB;EACnB,mBAAmB;EACnB,oBAAoB;EACpB,UAAU;EACV,0BAA0B;EAC1B,WAAW;EACX,qBAAqB;EACrB,sBAAsB;EACtB,qBAAqB;EACrB,cAAc;EACd,0BAA0B;EAC1B,uCAAuC;EACvC,uBAAuB;EACvB,+BAA+B;EAC/B,mBAAmB;EACnB,yBAAyB;EACzB,YAAY;CACb;;AAED;EACE,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;EAC1B,+BAA+B;EAC/B,2BAA2B;EAC3B,wBAAwB;CACzB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;EAC1B,+BAA+B;EAC/B,2BAA2B;EAC3B,wBAAwB;CACzB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;EAC1B,+BAA+B;EAC/B,2BAA2B;EAC3B,wBAAwB;EACxB,cAAc;CACf;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,cAAc;EACd,oDAA8C;EAC9C,2BAA2B;EAC3B,YAAY;CACb;;AAED;EACE,oDAAgD;EAChD,2BAA2B;EAC3B,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,UAAU;EACV,UAAU;EACV,mBAAmB;EACnB,mBAAmB;EACnB,8BAA8B;EAC9B,sBAAsB;EACtB,qCAAqC;EACrC,6BAA6B;EAC7B,WAAW;EACX,iBAAiB;CAClB;;AAED;EACE;IACE,wBAAwB;IACxB,gBAAgB;GACjB;;EAED;IACE,+BAA+B;IAC/B,uBAAuB;GACxB;;EAED;IACE,wBAAwB;IACxB,gBAAgB;GACjB;CACF;;AAED;EACE;IACE,wBAAwB;IACxB,gBAAgB;GACjB;;EAED;IACE,+BAA+B;IAC/B,uBAAuB;GACxB;;EAED;IACE,wBAAwB;IACxB,gBAAgB;GACjB;CACF;;AAED;EACE,YAAY;EACZ,aAAa;EACb,mBAAmB;CACpB;;AAED;EACE,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,oDAA2C;EAC3C,2BAA2B;EAC3B,WAAW;CACZ;;AAED;EACE,mBAAmB;EACnB,aAAa;EACb,cAAc;EACd,SAAS;EACT,UAAU;CACX;;AAED;EACE,mBAAmB;EACnB,aAAa;EACb,cAAc;EACd,SAAS;EACT,WAAW;CACZ;;AAED;EACE,mBAAmB;EACnB,WAAW;EACX,YAAY;EACZ,UAAU;EACV,mBAAmB;EACnB,UAAU;EACV,WAAW;CACZ;;AAED;EACE,YAAY;EACZ,aAAa;CACd;;AAED;EACE,mBAAmB;EACnB,WAAW;EACX,YAAY;EACZ,wBAAwB;EACxB,SAAS;CACV;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;CACjB;;AAED;EACE,gBAAgB;EAChB,OAAO;EACP,QAAQ;EACR,WAAW;CACZ\",\"file\":\"index.css\",\"sourcesContent\":[\".share {\\n  height: 100%;\\n  background: url(./assets/bg.png) no-repeat;\\n  background-size: 100% 100%;\\n}\\n\\n#share {\\n  height: 100%;\\n  background: url(./assets/bg.png) no-repeat;\\n  background-size: 100% 100%;\\n}\\n\\n.share__button {\\n  position: absolute;\\n  width: 5.933333rem;\\n  height: 0.666667rem;\\n  left: 50%;\\n  margin-left: -2.966667rem;\\n  bottom: 2%;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: justify;\\n  -webkit-justify-content: space-between;\\n  -ms-flex-pack: justify;\\n  justify-content: space-between;\\n  text-align: center;\\n  line-height: 0.666667rem;\\n  z-index: 88;\\n}\\n\\n.share__button__left {\\n  width: 2.466667rem;\\n  height: 0.666667rem;\\n  background-color: #efded5;\\n  border: 0.013333rem solid #fff;\\n  border-radius: 0.133333rem;\\n  color: rgb(150, 83, 49);\\n}\\n\\n[data-dpr=\\\"1\\\"] .share__button__left {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share__button__left {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share__button__left {\\n  font-size: 45px;\\n}\\n\\n.share__button__right {\\n  width: 3.333333rem;\\n  height: 0.666667rem;\\n  background-color: #efded5;\\n  border: 0.013333rem solid #fff;\\n  border-radius: 0.133333rem;\\n  color: rgb(150, 83, 49);\\n}\\n\\n[data-dpr=\\\"1\\\"] .share__button__right {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share__button__right {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share__button__right {\\n  font-size: 45px;\\n}\\n\\n.share__button__save {\\n  width: 3.333333rem;\\n  height: 0.666667rem;\\n  background-color: #efded5;\\n  border: 0.013333rem solid #fff;\\n  border-radius: 0.133333rem;\\n  color: rgb(150, 83, 49);\\n  display: none;\\n}\\n\\n[data-dpr=\\\"1\\\"] .share__button__save {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share__button__save {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share__button__save {\\n  font-size: 45px;\\n}\\n\\n.share-cover {\\n  width: 100%;\\n  height: 100%;\\n  position: fixed;\\n  display: none;\\n  background: url(./assets/cover.png) no-repeat;\\n  background-size: 100% 100%;\\n  z-index: 99;\\n}\\n\\n.share-shining {\\n  background: url(./assets/shining.png) no-repeat;\\n  background-size: 100% 100%;\\n  width: 4rem;\\n  height: 4rem;\\n  position: fixed;\\n  bottom: 0;\\n  left: 50%;\\n  margin-left: -2rem;\\n  margin-bottom: 10%;\\n  -webkit-animation: shining 3s;\\n  animation: shining 3s;\\n  -webkit-animation-iteration-count: 5;\\n  animation-iteration-count: 5;\\n  z-index: 3;\\n  overflow: hidden;\\n}\\n\\n@-webkit-keyframes shining {\\n  0% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n\\n  50% {\\n    -webkit-transform: scale(2, 2);\\n    transform: scale(2, 2);\\n  }\\n\\n  100% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n}\\n\\n@keyframes shining {\\n  0% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n\\n  50% {\\n    -webkit-transform: scale(2, 2);\\n    transform: scale(2, 2);\\n  }\\n\\n  100% {\\n    -webkit-transform: none;\\n    transform: none;\\n  }\\n}\\n\\n.share-middle {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n}\\n\\n.share-middle-cover {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  background: url(./assets/bg.png) no-repeat;\\n  background-size: 100% 100%;\\n  z-index: 2;\\n}\\n\\n.share-middle-left {\\n  position: absolute;\\n  width: 34.4%;\\n  height: 25.8%;\\n  top: 30%;\\n  left: 12%;\\n}\\n\\n.share-middle-right {\\n  position: absolute;\\n  width: 34.4%;\\n  height: 25.8%;\\n  top: 30%;\\n  right: 12%;\\n}\\n\\n.share-img {\\n  position: absolute;\\n  width: 60%;\\n  height: 15%;\\n  bottom: 0;\\n  margin-bottom: 20%;\\n  left: 20%;\\n  z-index: 3;\\n}\\n\\n.share-img img {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.share-span {\\n  position: absolute;\\n  z-index: 3;\\n  bottom: 34%;\\n  color: rgb(150, 83, 49);\\n  left: 5%;\\n}\\n\\n[data-dpr=\\\"1\\\"] .share-span {\\n  font-size: 15px;\\n}\\n\\n[data-dpr=\\\"2\\\"] .share-span {\\n  font-size: 30px;\\n}\\n\\n[data-dpr=\\\"3\\\"] .share-span {\\n  font-size: 45px;\\n}\\n\\n#cropImg {\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  z-index: 3;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9pbmRleC5jc3M/ODhmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2hhcmUge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vYXNzZXRzL2JnLnBuZ1wiKSArIFwiKSBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG59XFxuXFxuI3NoYXJlIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuL2Fzc2V0cy9iZy5wbmdcIikgKyBcIikgbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XFxufVxcblxcbi5zaGFyZV9fYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiA1LjkzMzMzM3JlbTtcXG4gIGhlaWdodDogMC42NjY2NjdyZW07XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTIuOTY2NjY3cmVtO1xcbiAgYm90dG9tOiAyJTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtcGFjazoganVzdGlmeTtcXG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAwLjY2NjY2N3JlbTtcXG4gIHotaW5kZXg6IDg4O1xcbn1cXG5cXG4uc2hhcmVfX2J1dHRvbl9fbGVmdCB7XFxuICB3aWR0aDogMi40NjY2NjdyZW07XFxuICBoZWlnaHQ6IDAuNjY2NjY3cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VmZGVkNTtcXG4gIGJvcmRlcjogMC4wMTMzMzNyZW0gc29saWQgI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMTMzMzMzcmVtO1xcbiAgY29sb3I6IHJnYigxNTAsIDgzLCA0OSk7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMVxcXCJdIC5zaGFyZV9fYnV0dG9uX19sZWZ0IHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnNoYXJlX19idXR0b25fX2xlZnQge1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAuc2hhcmVfX2J1dHRvbl9fbGVmdCB7XFxuICBmb250LXNpemU6IDQ1cHg7XFxufVxcblxcbi5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICB3aWR0aDogMy4zMzMzMzNyZW07XFxuICBoZWlnaHQ6IDAuNjY2NjY3cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VmZGVkNTtcXG4gIGJvcmRlcjogMC4wMTMzMzNyZW0gc29saWQgI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMTMzMzMzcmVtO1xcbiAgY29sb3I6IHJnYigxNTAsIDgzLCA0OSk7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMVxcXCJdIC5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICBmb250LXNpemU6IDE1cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMlxcXCJdIC5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICBmb250LXNpemU6IDMwcHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiM1xcXCJdIC5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICBmb250LXNpemU6IDQ1cHg7XFxufVxcblxcbi5zaGFyZV9fYnV0dG9uX19zYXZlIHtcXG4gIHdpZHRoOiAzLjMzMzMzM3JlbTtcXG4gIGhlaWdodDogMC42NjY2NjdyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZkZWQ1O1xcbiAgYm9yZGVyOiAwLjAxMzMzM3JlbSBzb2xpZCAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMC4xMzMzMzNyZW07XFxuICBjb2xvcjogcmdiKDE1MCwgODMsIDQ5KTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMVxcXCJdIC5zaGFyZV9fYnV0dG9uX19zYXZlIHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnNoYXJlX19idXR0b25fX3NhdmUge1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAuc2hhcmVfX2J1dHRvbl9fc2F2ZSB7XFxuICBmb250LXNpemU6IDQ1cHg7XFxufVxcblxcbi5zaGFyZS1jb3ZlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi9hc3NldHMvY292ZXIucG5nXCIpICsgXCIpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJSAxMDAlO1xcbiAgei1pbmRleDogOTk7XFxufVxcblxcbi5zaGFyZS1zaGluaW5nIHtcXG4gIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuL2Fzc2V0cy9zaGluaW5nLnBuZ1wiKSArIFwiKSBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHdpZHRoOiA0cmVtO1xcbiAgaGVpZ2h0OiA0cmVtO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogNTAlO1xcbiAgbWFyZ2luLWxlZnQ6IC0ycmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMTAlO1xcbiAgLXdlYmtpdC1hbmltYXRpb246IHNoaW5pbmcgM3M7XFxuICBhbmltYXRpb246IHNoaW5pbmcgM3M7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDU7XFxuICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiA1O1xcbiAgei1pbmRleDogMztcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBzaGluaW5nIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmU7XFxuICAgIHRyYW5zZm9ybTogbm9uZTtcXG4gIH1cXG5cXG4gIDUwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgyLCAyKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgyLCAyKTtcXG4gIH1cXG5cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIHNoaW5pbmcge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcblxcbiAgNTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDIsIDIpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDIsIDIpO1xcbiAgfVxcblxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBub25lO1xcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxufVxcblxcbi5zaGFyZS1taWRkbGUge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5zaGFyZS1taWRkbGUtY292ZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi9hc3NldHMvYmcucG5nXCIpICsgXCIpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJSAxMDAlO1xcbiAgei1pbmRleDogMjtcXG59XFxuXFxuLnNoYXJlLW1pZGRsZS1sZWZ0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAzNC40JTtcXG4gIGhlaWdodDogMjUuOCU7XFxuICB0b3A6IDMwJTtcXG4gIGxlZnQ6IDEyJTtcXG59XFxuXFxuLnNoYXJlLW1pZGRsZS1yaWdodCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMzQuNCU7XFxuICBoZWlnaHQ6IDI1LjglO1xcbiAgdG9wOiAzMCU7XFxuICByaWdodDogMTIlO1xcbn1cXG5cXG4uc2hhcmUtaW1nIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiA2MCU7XFxuICBoZWlnaHQ6IDE1JTtcXG4gIGJvdHRvbTogMDtcXG4gIG1hcmdpbi1ib3R0b206IDIwJTtcXG4gIGxlZnQ6IDIwJTtcXG4gIHotaW5kZXg6IDM7XFxufVxcblxcbi5zaGFyZS1pbWcgaW1nIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uc2hhcmUtc3BhbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAzO1xcbiAgYm90dG9tOiAzNCU7XFxuICBjb2xvcjogcmdiKDE1MCwgODMsIDQ5KTtcXG4gIGxlZnQ6IDUlO1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjFcXFwiXSAuc2hhcmUtc3BhbiB7XFxuICBmb250LXNpemU6IDE1cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMlxcXCJdIC5zaGFyZS1zcGFuIHtcXG4gIGZvbnQtc2l6ZTogMzBweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIzXFxcIl0gLnNoYXJlLXNwYW4ge1xcbiAgZm9udC1zaXplOiA0NXB4O1xcbn1cXG5cXG4jY3JvcEltZyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgei1pbmRleDogMztcXG59XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9iYWJ5ZmFuL0RvY3VtZW50cy9wcm9qZWN0L3RydWVjb2xvci9hcHBzL3RydWVjb2xvci9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS88aW5wdXQgY3NzIDY+XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsYUFBYTtFQUNiLG9EQUEyQztFQUMzQywyQkFBMkI7Q0FDNUI7O0FBRUQ7RUFDRSxhQUFhO0VBQ2Isb0RBQTJDO0VBQzNDLDJCQUEyQjtDQUM1Qjs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixtQkFBbUI7RUFDbkIsb0JBQW9CO0VBQ3BCLFVBQVU7RUFDViwwQkFBMEI7RUFDMUIsV0FBVztFQUNYLHFCQUFxQjtFQUNyQixzQkFBc0I7RUFDdEIscUJBQXFCO0VBQ3JCLGNBQWM7RUFDZCwwQkFBMEI7RUFDMUIsdUNBQXVDO0VBQ3ZDLHVCQUF1QjtFQUN2QiwrQkFBK0I7RUFDL0IsbUJBQW1CO0VBQ25CLHlCQUF5QjtFQUN6QixZQUFZO0NBQ2I7O0FBRUQ7RUFDRSxtQkFBbUI7RUFDbkIsb0JBQW9CO0VBQ3BCLDBCQUEwQjtFQUMxQiwrQkFBK0I7RUFDL0IsMkJBQTJCO0VBQzNCLHdCQUF3QjtDQUN6Qjs7QUFFRDtFQUNFLGdCQUFnQjtDQUNqQjs7QUFFRDtFQUNFLGdCQUFnQjtDQUNqQjs7QUFFRDtFQUNFLGdCQUFnQjtDQUNqQjs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixvQkFBb0I7RUFDcEIsMEJBQTBCO0VBQzFCLCtCQUErQjtFQUMvQiwyQkFBMkI7RUFDM0Isd0JBQXdCO0NBQ3pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsbUJBQW1CO0VBQ25CLG9CQUFvQjtFQUNwQiwwQkFBMEI7RUFDMUIsK0JBQStCO0VBQy9CLDJCQUEyQjtFQUMzQix3QkFBd0I7RUFDeEIsY0FBYztDQUNmOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsWUFBWTtFQUNaLGFBQWE7RUFDYixnQkFBZ0I7RUFDaEIsY0FBYztFQUNkLG9EQUE4QztFQUM5QywyQkFBMkI7RUFDM0IsWUFBWTtDQUNiOztBQUVEO0VBQ0Usb0RBQWdEO0VBQ2hELDJCQUEyQjtFQUMzQixZQUFZO0VBQ1osYUFBYTtFQUNiLGdCQUFnQjtFQUNoQixVQUFVO0VBQ1YsVUFBVTtFQUNWLG1CQUFtQjtFQUNuQixtQkFBbUI7RUFDbkIsOEJBQThCO0VBQzlCLHNCQUFzQjtFQUN0QixxQ0FBcUM7RUFDckMsNkJBQTZCO0VBQzdCLFdBQVc7RUFDWCxpQkFBaUI7Q0FDbEI7O0FBRUQ7RUFDRTtJQUNFLHdCQUF3QjtJQUN4QixnQkFBZ0I7R0FDakI7O0VBRUQ7SUFDRSwrQkFBK0I7SUFDL0IsdUJBQXVCO0dBQ3hCOztFQUVEO0lBQ0Usd0JBQXdCO0lBQ3hCLGdCQUFnQjtHQUNqQjtDQUNGOztBQUVEO0VBQ0U7SUFDRSx3QkFBd0I7SUFDeEIsZ0JBQWdCO0dBQ2pCOztFQUVEO0lBQ0UsK0JBQStCO0lBQy9CLHVCQUF1QjtHQUN4Qjs7RUFFRDtJQUNFLHdCQUF3QjtJQUN4QixnQkFBZ0I7R0FDakI7Q0FDRjs7QUFFRDtFQUNFLFlBQVk7RUFDWixhQUFhO0VBQ2IsbUJBQW1CO0NBQ3BCOztBQUVEO0VBQ0UsWUFBWTtFQUNaLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsb0RBQTJDO0VBQzNDLDJCQUEyQjtFQUMzQixXQUFXO0NBQ1o7O0FBRUQ7RUFDRSxtQkFBbUI7RUFDbkIsYUFBYTtFQUNiLGNBQWM7RUFDZCxTQUFTO0VBQ1QsVUFBVTtDQUNYOztBQUVEO0VBQ0UsbUJBQW1CO0VBQ25CLGFBQWE7RUFDYixjQUFjO0VBQ2QsU0FBUztFQUNULFdBQVc7Q0FDWjs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixXQUFXO0VBQ1gsWUFBWTtFQUNaLFVBQVU7RUFDVixtQkFBbUI7RUFDbkIsVUFBVTtFQUNWLFdBQVc7Q0FDWjs7QUFFRDtFQUNFLFlBQVk7RUFDWixhQUFhO0NBQ2Q7O0FBRUQ7RUFDRSxtQkFBbUI7RUFDbkIsV0FBVztFQUNYLFlBQVk7RUFDWix3QkFBd0I7RUFDeEIsU0FBUztDQUNWOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0UsZ0JBQWdCO0VBQ2hCLE9BQU87RUFDUCxRQUFRO0VBQ1IsV0FBVztDQUNaXCIsXCJmaWxlXCI6XCJpbmRleC5jc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNoYXJlIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IHVybCguL2Fzc2V0cy9iZy5wbmcpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJSAxMDAlO1xcbn1cXG5cXG4jc2hhcmUge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogdXJsKC4vYXNzZXRzL2JnLnBuZykgbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XFxufVxcblxcbi5zaGFyZV9fYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiA1LjkzMzMzM3JlbTtcXG4gIGhlaWdodDogMC42NjY2NjdyZW07XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTIuOTY2NjY3cmVtO1xcbiAgYm90dG9tOiAyJTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtcGFjazoganVzdGlmeTtcXG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAwLjY2NjY2N3JlbTtcXG4gIHotaW5kZXg6IDg4O1xcbn1cXG5cXG4uc2hhcmVfX2J1dHRvbl9fbGVmdCB7XFxuICB3aWR0aDogMi40NjY2NjdyZW07XFxuICBoZWlnaHQ6IDAuNjY2NjY3cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VmZGVkNTtcXG4gIGJvcmRlcjogMC4wMTMzMzNyZW0gc29saWQgI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMTMzMzMzcmVtO1xcbiAgY29sb3I6IHJnYigxNTAsIDgzLCA0OSk7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMVxcXCJdIC5zaGFyZV9fYnV0dG9uX19sZWZ0IHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnNoYXJlX19idXR0b25fX2xlZnQge1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAuc2hhcmVfX2J1dHRvbl9fbGVmdCB7XFxuICBmb250LXNpemU6IDQ1cHg7XFxufVxcblxcbi5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICB3aWR0aDogMy4zMzMzMzNyZW07XFxuICBoZWlnaHQ6IDAuNjY2NjY3cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VmZGVkNTtcXG4gIGJvcmRlcjogMC4wMTMzMzNyZW0gc29saWQgI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMTMzMzMzcmVtO1xcbiAgY29sb3I6IHJnYigxNTAsIDgzLCA0OSk7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMVxcXCJdIC5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICBmb250LXNpemU6IDE1cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMlxcXCJdIC5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICBmb250LXNpemU6IDMwcHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiM1xcXCJdIC5zaGFyZV9fYnV0dG9uX19yaWdodCB7XFxuICBmb250LXNpemU6IDQ1cHg7XFxufVxcblxcbi5zaGFyZV9fYnV0dG9uX19zYXZlIHtcXG4gIHdpZHRoOiAzLjMzMzMzM3JlbTtcXG4gIGhlaWdodDogMC42NjY2NjdyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZkZWQ1O1xcbiAgYm9yZGVyOiAwLjAxMzMzM3JlbSBzb2xpZCAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMC4xMzMzMzNyZW07XFxuICBjb2xvcjogcmdiKDE1MCwgODMsIDQ5KTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMVxcXCJdIC5zaGFyZV9fYnV0dG9uX19zYXZlIHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnNoYXJlX19idXR0b25fX3NhdmUge1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAuc2hhcmVfX2J1dHRvbl9fc2F2ZSB7XFxuICBmb250LXNpemU6IDQ1cHg7XFxufVxcblxcbi5zaGFyZS1jb3ZlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiB1cmwoLi9hc3NldHMvY292ZXIucG5nKSBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHotaW5kZXg6IDk5O1xcbn1cXG5cXG4uc2hhcmUtc2hpbmluZyB7XFxuICBiYWNrZ3JvdW5kOiB1cmwoLi9hc3NldHMvc2hpbmluZy5wbmcpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJSAxMDAlO1xcbiAgd2lkdGg6IDRyZW07XFxuICBoZWlnaHQ6IDRyZW07XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTJyZW07XFxuICBtYXJnaW4tYm90dG9tOiAxMCU7XFxuICAtd2Via2l0LWFuaW1hdGlvbjogc2hpbmluZyAzcztcXG4gIGFuaW1hdGlvbjogc2hpbmluZyAzcztcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogNTtcXG4gIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDU7XFxuICB6LWluZGV4OiAzO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIHNoaW5pbmcge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcblxcbiAgNTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDIsIDIpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDIsIDIpO1xcbiAgfVxcblxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBub25lO1xcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgc2hpbmluZyB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBub25lO1xcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICA1MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMiwgMik7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMiwgMik7XFxuICB9XFxuXFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmU7XFxuICAgIHRyYW5zZm9ybTogbm9uZTtcXG4gIH1cXG59XFxuXFxuLnNoYXJlLW1pZGRsZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLnNoYXJlLW1pZGRsZS1jb3ZlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQ6IHVybCguL2Fzc2V0cy9iZy5wbmcpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJSAxMDAlO1xcbiAgei1pbmRleDogMjtcXG59XFxuXFxuLnNoYXJlLW1pZGRsZS1sZWZ0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAzNC40JTtcXG4gIGhlaWdodDogMjUuOCU7XFxuICB0b3A6IDMwJTtcXG4gIGxlZnQ6IDEyJTtcXG59XFxuXFxuLnNoYXJlLW1pZGRsZS1yaWdodCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMzQuNCU7XFxuICBoZWlnaHQ6IDI1LjglO1xcbiAgdG9wOiAzMCU7XFxuICByaWdodDogMTIlO1xcbn1cXG5cXG4uc2hhcmUtaW1nIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiA2MCU7XFxuICBoZWlnaHQ6IDE1JTtcXG4gIGJvdHRvbTogMDtcXG4gIG1hcmdpbi1ib3R0b206IDIwJTtcXG4gIGxlZnQ6IDIwJTtcXG4gIHotaW5kZXg6IDM7XFxufVxcblxcbi5zaGFyZS1pbWcgaW1nIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uc2hhcmUtc3BhbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAzO1xcbiAgYm90dG9tOiAzNCU7XFxuICBjb2xvcjogcmdiKDE1MCwgODMsIDQ5KTtcXG4gIGxlZnQ6IDUlO1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjFcXFwiXSAuc2hhcmUtc3BhbiB7XFxuICBmb250LXNpemU6IDE1cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMlxcXCJdIC5zaGFyZS1zcGFuIHtcXG4gIGZvbnQtc2l6ZTogMzBweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIzXFxcIl0gLnNoYXJlLXNwYW4ge1xcbiAgZm9udC1zaXplOiA0NXB4O1xcbn1cXG5cXG4jY3JvcEltZyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgei1pbmRleDogMztcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9iYWJ5ZmFuL0RvY3VtZW50cy9wcm9qZWN0L3RydWVjb2xvci9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS9Vc2Vycy9iYWJ5ZmFuL0RvY3VtZW50cy9wcm9qZWN0L3RydWVjb2xvci9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZGQwZDE4NGFcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9pbmRleC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54\n");

/***/ }),

/***/ 55:
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*\n  html2canvas 0.5.0-beta4 <http://html2canvas.hertzen.com>\n  Copyright (c) 2016 Niklas von Hertzen\n\n  Released under  License\n*/\n\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.html2canvas = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\nvar log = _dereq_('./log');\n\nfunction restoreOwnerScroll(ownerDocument, x, y) {\n    if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {\n        ownerDocument.defaultView.scrollTo(x, y);\n    }\n}\n\nfunction cloneCanvasContents(canvas, clonedCanvas) {\n    try {\n        if (clonedCanvas) {\n            clonedCanvas.width = canvas.width;\n            clonedCanvas.height = canvas.height;\n            clonedCanvas.getContext(\"2d\").putImageData(canvas.getContext(\"2d\").getImageData(0, 0, canvas.width, canvas.height), 0, 0);\n        }\n    } catch(e) {\n        log(\"Unable to copy canvas content from\", canvas, e);\n    }\n}\n\nfunction cloneNode(node, javascriptEnabled) {\n    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);\n\n    var child = node.firstChild;\n    while(child) {\n        if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {\n            clone.appendChild(cloneNode(child, javascriptEnabled));\n        }\n        child = child.nextSibling;\n    }\n\n    if (node.nodeType === 1) {\n        clone._scrollTop = node.scrollTop;\n        clone._scrollLeft = node.scrollLeft;\n        if (node.nodeName === \"CANVAS\") {\n            cloneCanvasContents(node, clone);\n        } else if (node.nodeName === \"TEXTAREA\" || node.nodeName === \"SELECT\") {\n            clone.value = node.value;\n        }\n    }\n\n    return clone;\n}\n\nfunction initNode(node) {\n    if (node.nodeType === 1) {\n        node.scrollTop = node._scrollTop;\n        node.scrollLeft = node._scrollLeft;\n\n        var child = node.firstChild;\n        while(child) {\n            initNode(child);\n            child = child.nextSibling;\n        }\n    }\n}\n\nmodule.exports = function(ownerDocument, containerDocument, width, height, options, x ,y) {\n    var documentElement = cloneNode(ownerDocument.documentElement, options.javascriptEnabled);\n    var container = containerDocument.createElement(\"iframe\");\n\n    container.className = \"html2canvas-container\";\n    container.style.visibility = \"hidden\";\n    container.style.position = \"fixed\";\n    container.style.left = \"-10000px\";\n    container.style.top = \"0px\";\n    container.style.border = \"0\";\n    container.width = width;\n    container.height = height;\n    container.scrolling = \"no\"; // ios won't scroll without it\n    containerDocument.body.appendChild(container);\n\n    return new Promise(function(resolve) {\n        var documentClone = container.contentWindow.document;\n\n        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle\n         if window url is about:blank, we can assign the url to current by writing onto the document\n         */\n        container.contentWindow.onload = container.onload = function() {\n            var interval = setInterval(function() {\n                if (documentClone.body.childNodes.length > 0) {\n                    initNode(documentClone.documentElement);\n                    clearInterval(interval);\n                    if (options.type === \"view\") {\n                        container.contentWindow.scrollTo(x, y);\n                        if ((/(iPad|iPhone|iPod)/g).test(navigator.userAgent) && (container.contentWindow.scrollY !== y || container.contentWindow.scrollX !== x)) {\n                            documentClone.documentElement.style.top = (-y) + \"px\";\n                            documentClone.documentElement.style.left = (-x) + \"px\";\n                            documentClone.documentElement.style.position = 'absolute';\n                        }\n                    }\n                    resolve(container);\n                }\n            }, 50);\n        };\n\n        documentClone.open();\n        documentClone.write(\"<!DOCTYPE html><html></html>\");\n        // Chrome scrolls the parent document for some reason after the write to the cloned window???\n        restoreOwnerScroll(ownerDocument, x, y);\n        documentClone.replaceChild(documentClone.adoptNode(documentElement), documentClone.documentElement);\n        documentClone.close();\n    });\n};\n\n},{\"./log\":13}],3:[function(_dereq_,module,exports){\n// http://dev.w3.org/csswg/css-color/\n\nfunction Color(value) {\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    this.a = null;\n    var result = this.fromArray(value) ||\n        this.namedColor(value) ||\n        this.rgb(value) ||\n        this.rgba(value) ||\n        this.hex6(value) ||\n        this.hex3(value);\n}\n\nColor.prototype.darken = function(amount) {\n    var a = 1 - amount;\n    return  new Color([\n        Math.round(this.r * a),\n        Math.round(this.g * a),\n        Math.round(this.b * a),\n        this.a\n    ]);\n};\n\nColor.prototype.isTransparent = function() {\n    return this.a === 0;\n};\n\nColor.prototype.isBlack = function() {\n    return this.r === 0 && this.g === 0 && this.b === 0;\n};\n\nColor.prototype.fromArray = function(array) {\n    if (Array.isArray(array)) {\n        this.r = Math.min(array[0], 255);\n        this.g = Math.min(array[1], 255);\n        this.b = Math.min(array[2], 255);\n        if (array.length > 3) {\n            this.a = array[3];\n        }\n    }\n\n    return (Array.isArray(array));\n};\n\nvar _hex3 = /^#([a-f0-9]{3})$/i;\n\nColor.prototype.hex3 = function(value) {\n    var match = null;\n    if ((match = value.match(_hex3)) !== null) {\n        this.r = parseInt(match[1][0] + match[1][0], 16);\n        this.g = parseInt(match[1][1] + match[1][1], 16);\n        this.b = parseInt(match[1][2] + match[1][2], 16);\n    }\n    return match !== null;\n};\n\nvar _hex6 = /^#([a-f0-9]{6})$/i;\n\nColor.prototype.hex6 = function(value) {\n    var match = null;\n    if ((match = value.match(_hex6)) !== null) {\n        this.r = parseInt(match[1].substring(0, 2), 16);\n        this.g = parseInt(match[1].substring(2, 4), 16);\n        this.b = parseInt(match[1].substring(4, 6), 16);\n    }\n    return match !== null;\n};\n\n\nvar _rgb = /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\n\nColor.prototype.rgb = function(value) {\n    var match = null;\n    if ((match = value.match(_rgb)) !== null) {\n        this.r = Number(match[1]);\n        this.g = Number(match[2]);\n        this.b = Number(match[3]);\n    }\n    return match !== null;\n};\n\nvar _rgba = /^rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d?\\.?\\d+)\\s*\\)$/;\n\nColor.prototype.rgba = function(value) {\n    var match = null;\n    if ((match = value.match(_rgba)) !== null) {\n        this.r = Number(match[1]);\n        this.g = Number(match[2]);\n        this.b = Number(match[3]);\n        this.a = Number(match[4]);\n    }\n    return match !== null;\n};\n\nColor.prototype.toString = function() {\n    return this.a !== null && this.a !== 1 ?\n    \"rgba(\" + [this.r, this.g, this.b, this.a].join(\",\") + \")\" :\n    \"rgb(\" + [this.r, this.g, this.b].join(\",\") + \")\";\n};\n\nColor.prototype.namedColor = function(value) {\n    value = value.toLowerCase();\n    var color = colors[value];\n    if (color) {\n        this.r = color[0];\n        this.g = color[1];\n        this.b = color[2];\n    } else if (value === \"transparent\") {\n        this.r = this.g = this.b = this.a = 0;\n        return true;\n    }\n\n    return !!color;\n};\n\nColor.prototype.isColor = true;\n\n// JSON.stringify([].slice.call($$('.named-color-table tr'), 1).map(function(row) { return [row.childNodes[3].textContent, row.childNodes[5].textContent.trim().split(\",\").map(Number)] }).reduce(function(data, row) {data[row[0]] = row[1]; return data}, {}))\nvar colors = {\n    \"aliceblue\": [240, 248, 255],\n    \"antiquewhite\": [250, 235, 215],\n    \"aqua\": [0, 255, 255],\n    \"aquamarine\": [127, 255, 212],\n    \"azure\": [240, 255, 255],\n    \"beige\": [245, 245, 220],\n    \"bisque\": [255, 228, 196],\n    \"black\": [0, 0, 0],\n    \"blanchedalmond\": [255, 235, 205],\n    \"blue\": [0, 0, 255],\n    \"blueviolet\": [138, 43, 226],\n    \"brown\": [165, 42, 42],\n    \"burlywood\": [222, 184, 135],\n    \"cadetblue\": [95, 158, 160],\n    \"chartreuse\": [127, 255, 0],\n    \"chocolate\": [210, 105, 30],\n    \"coral\": [255, 127, 80],\n    \"cornflowerblue\": [100, 149, 237],\n    \"cornsilk\": [255, 248, 220],\n    \"crimson\": [220, 20, 60],\n    \"cyan\": [0, 255, 255],\n    \"darkblue\": [0, 0, 139],\n    \"darkcyan\": [0, 139, 139],\n    \"darkgoldenrod\": [184, 134, 11],\n    \"darkgray\": [169, 169, 169],\n    \"darkgreen\": [0, 100, 0],\n    \"darkgrey\": [169, 169, 169],\n    \"darkkhaki\": [189, 183, 107],\n    \"darkmagenta\": [139, 0, 139],\n    \"darkolivegreen\": [85, 107, 47],\n    \"darkorange\": [255, 140, 0],\n    \"darkorchid\": [153, 50, 204],\n    \"darkred\": [139, 0, 0],\n    \"darksalmon\": [233, 150, 122],\n    \"darkseagreen\": [143, 188, 143],\n    \"darkslateblue\": [72, 61, 139],\n    \"darkslategray\": [47, 79, 79],\n    \"darkslategrey\": [47, 79, 79],\n    \"darkturquoise\": [0, 206, 209],\n    \"darkviolet\": [148, 0, 211],\n    \"deeppink\": [255, 20, 147],\n    \"deepskyblue\": [0, 191, 255],\n    \"dimgray\": [105, 105, 105],\n    \"dimgrey\": [105, 105, 105],\n    \"dodgerblue\": [30, 144, 255],\n    \"firebrick\": [178, 34, 34],\n    \"floralwhite\": [255, 250, 240],\n    \"forestgreen\": [34, 139, 34],\n    \"fuchsia\": [255, 0, 255],\n    \"gainsboro\": [220, 220, 220],\n    \"ghostwhite\": [248, 248, 255],\n    \"gold\": [255, 215, 0],\n    \"goldenrod\": [218, 165, 32],\n    \"gray\": [128, 128, 128],\n    \"green\": [0, 128, 0],\n    \"greenyellow\": [173, 255, 47],\n    \"grey\": [128, 128, 128],\n    \"honeydew\": [240, 255, 240],\n    \"hotpink\": [255, 105, 180],\n    \"indianred\": [205, 92, 92],\n    \"indigo\": [75, 0, 130],\n    \"ivory\": [255, 255, 240],\n    \"khaki\": [240, 230, 140],\n    \"lavender\": [230, 230, 250],\n    \"lavenderblush\": [255, 240, 245],\n    \"lawngreen\": [124, 252, 0],\n    \"lemonchiffon\": [255, 250, 205],\n    \"lightblue\": [173, 216, 230],\n    \"lightcoral\": [240, 128, 128],\n    \"lightcyan\": [224, 255, 255],\n    \"lightgoldenrodyellow\": [250, 250, 210],\n    \"lightgray\": [211, 211, 211],\n    \"lightgreen\": [144, 238, 144],\n    \"lightgrey\": [211, 211, 211],\n    \"lightpink\": [255, 182, 193],\n    \"lightsalmon\": [255, 160, 122],\n    \"lightseagreen\": [32, 178, 170],\n    \"lightskyblue\": [135, 206, 250],\n    \"lightslategray\": [119, 136, 153],\n    \"lightslategrey\": [119, 136, 153],\n    \"lightsteelblue\": [176, 196, 222],\n    \"lightyellow\": [255, 255, 224],\n    \"lime\": [0, 255, 0],\n    \"limegreen\": [50, 205, 50],\n    \"linen\": [250, 240, 230],\n    \"magenta\": [255, 0, 255],\n    \"maroon\": [128, 0, 0],\n    \"mediumaquamarine\": [102, 205, 170],\n    \"mediumblue\": [0, 0, 205],\n    \"mediumorchid\": [186, 85, 211],\n    \"mediumpurple\": [147, 112, 219],\n    \"mediumseagreen\": [60, 179, 113],\n    \"mediumslateblue\": [123, 104, 238],\n    \"mediumspringgreen\": [0, 250, 154],\n    \"mediumturquoise\": [72, 209, 204],\n    \"mediumvioletred\": [199, 21, 133],\n    \"midnightblue\": [25, 25, 112],\n    \"mintcream\": [245, 255, 250],\n    \"mistyrose\": [255, 228, 225],\n    \"moccasin\": [255, 228, 181],\n    \"navajowhite\": [255, 222, 173],\n    \"navy\": [0, 0, 128],\n    \"oldlace\": [253, 245, 230],\n    \"olive\": [128, 128, 0],\n    \"olivedrab\": [107, 142, 35],\n    \"orange\": [255, 165, 0],\n    \"orangered\": [255, 69, 0],\n    \"orchid\": [218, 112, 214],\n    \"palegoldenrod\": [238, 232, 170],\n    \"palegreen\": [152, 251, 152],\n    \"paleturquoise\": [175, 238, 238],\n    \"palevioletred\": [219, 112, 147],\n    \"papayawhip\": [255, 239, 213],\n    \"peachpuff\": [255, 218, 185],\n    \"peru\": [205, 133, 63],\n    \"pink\": [255, 192, 203],\n    \"plum\": [221, 160, 221],\n    \"powderblue\": [176, 224, 230],\n    \"purple\": [128, 0, 128],\n    \"rebeccapurple\": [102, 51, 153],\n    \"red\": [255, 0, 0],\n    \"rosybrown\": [188, 143, 143],\n    \"royalblue\": [65, 105, 225],\n    \"saddlebrown\": [139, 69, 19],\n    \"salmon\": [250, 128, 114],\n    \"sandybrown\": [244, 164, 96],\n    \"seagreen\": [46, 139, 87],\n    \"seashell\": [255, 245, 238],\n    \"sienna\": [160, 82, 45],\n    \"silver\": [192, 192, 192],\n    \"skyblue\": [135, 206, 235],\n    \"slateblue\": [106, 90, 205],\n    \"slategray\": [112, 128, 144],\n    \"slategrey\": [112, 128, 144],\n    \"snow\": [255, 250, 250],\n    \"springgreen\": [0, 255, 127],\n    \"steelblue\": [70, 130, 180],\n    \"tan\": [210, 180, 140],\n    \"teal\": [0, 128, 128],\n    \"thistle\": [216, 191, 216],\n    \"tomato\": [255, 99, 71],\n    \"turquoise\": [64, 224, 208],\n    \"violet\": [238, 130, 238],\n    \"wheat\": [245, 222, 179],\n    \"white\": [255, 255, 255],\n    \"whitesmoke\": [245, 245, 245],\n    \"yellow\": [255, 255, 0],\n    \"yellowgreen\": [154, 205, 50]\n};\n\nmodule.exports = Color;\n\n},{}],4:[function(_dereq_,module,exports){\nvar Support = _dereq_('./support');\nvar CanvasRenderer = _dereq_('./renderers/canvas');\nvar ImageLoader = _dereq_('./imageloader');\nvar NodeParser = _dereq_('./nodeparser');\nvar NodeContainer = _dereq_('./nodecontainer');\nvar log = _dereq_('./log');\nvar utils = _dereq_('./utils');\nvar createWindowClone = _dereq_('./clone');\nvar loadUrlDocument = _dereq_('./proxy').loadUrlDocument;\nvar getBounds = utils.getBounds;\n\nvar html2canvasNodeAttribute = \"data-html2canvas-node\";\nvar html2canvasCloneIndex = 0;\n\nfunction html2canvas(nodeList, options) {\n    var index = html2canvasCloneIndex++;\n    options = options || {};\n    if (options.logging) {\n        log.options.logging = true;\n        log.options.start = Date.now();\n    }\n\n    options.async = typeof(options.async) === \"undefined\" ? true : options.async;\n    options.allowTaint = typeof(options.allowTaint) === \"undefined\" ? false : options.allowTaint;\n    options.removeContainer = typeof(options.removeContainer) === \"undefined\" ? true : options.removeContainer;\n    options.javascriptEnabled = typeof(options.javascriptEnabled) === \"undefined\" ? false : options.javascriptEnabled;\n    options.imageTimeout = typeof(options.imageTimeout) === \"undefined\" ? 10000 : options.imageTimeout;\n    options.renderer = typeof(options.renderer) === \"function\" ? options.renderer : CanvasRenderer;\n    options.strict = !!options.strict;\n\n    if (typeof(nodeList) === \"string\") {\n        if (typeof(options.proxy) !== \"string\") {\n            return Promise.reject(\"Proxy must be used when rendering url\");\n        }\n        var width = options.width != null ? options.width : window.innerWidth;\n        var height = options.height != null ? options.height : window.innerHeight;\n        return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {\n            return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);\n        });\n    }\n\n    var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];\n    node.setAttribute(html2canvasNodeAttribute + index, index);\n    return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function(canvas) {\n        if (typeof(options.onrendered) === \"function\") {\n            log(\"options.onrendered is deprecated, html2canvas returns a Promise containing the canvas\");\n            options.onrendered(canvas);\n        }\n        return canvas;\n    });\n}\n\nhtml2canvas.CanvasRenderer = CanvasRenderer;\nhtml2canvas.NodeContainer = NodeContainer;\nhtml2canvas.log = log;\nhtml2canvas.utils = utils;\n\nvar html2canvasExport = (typeof(document) === \"undefined\" || typeof(Object.create) !== \"function\" || typeof(document.createElement(\"canvas\").getContext) !== \"function\") ? function() {\n    return Promise.reject(\"No canvas support\");\n} : html2canvas;\n\nmodule.exports = html2canvasExport;\n\nif (typeof(define) === 'function' && define.amd) {\n    define('html2canvas', [], function() {\n        return html2canvasExport;\n    });\n}\n\nfunction renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {\n    return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {\n        log(\"Document cloned\");\n        var attributeName = html2canvasNodeAttribute + html2canvasIndex;\n        var selector = \"[\" + attributeName + \"='\" + html2canvasIndex + \"']\";\n        document.querySelector(selector).removeAttribute(attributeName);\n        var clonedWindow = container.contentWindow;\n        var node = clonedWindow.document.querySelector(selector);\n        var oncloneHandler = (typeof(options.onclone) === \"function\") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);\n        return oncloneHandler.then(function() {\n            return renderWindow(node, container, options, windowWidth, windowHeight);\n        });\n    });\n}\n\nfunction renderWindow(node, container, options, windowWidth, windowHeight) {\n    var clonedWindow = container.contentWindow;\n    var support = new Support(clonedWindow.document);\n    var imageLoader = new ImageLoader(options, support);\n    var bounds = getBounds(node);\n    var width = options.type === \"view\" ? windowWidth : documentWidth(clonedWindow.document);\n    var height = options.type === \"view\" ? windowHeight : documentHeight(clonedWindow.document);\n    var renderer = new options.renderer(width, height, imageLoader, options, document);\n    var parser = new NodeParser(node, renderer, support, imageLoader, options);\n    return parser.ready.then(function() {\n        log(\"Finished rendering\");\n        var canvas;\n\n        if (options.type === \"view\") {\n            canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0});\n        } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {\n            canvas = renderer.canvas;\n        } else {\n            canvas = crop(renderer.canvas, {width:  options.width != null ? options.width : bounds.width, height: options.height != null ? options.height : bounds.height, top: bounds.top, left: bounds.left, x: 0, y: 0});\n        }\n\n        cleanupContainer(container, options);\n        return canvas;\n    });\n}\n\nfunction cleanupContainer(container, options) {\n    if (options.removeContainer) {\n        container.parentNode.removeChild(container);\n        log(\"Cleaned up container\");\n    }\n}\n\nfunction crop(canvas, bounds) {\n    var croppedCanvas = document.createElement(\"canvas\");\n    var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));\n    var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));\n    var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));\n    var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));\n    croppedCanvas.width = bounds.width;\n    croppedCanvas.height =  bounds.height;\n    var width = x2-x1;\n    var height = y2-y1;\n    log(\"Cropping canvas at:\", \"left:\", bounds.left, \"top:\", bounds.top, \"width:\", width, \"height:\", height);\n    log(\"Resulting crop with width\", bounds.width, \"and height\", bounds.height, \"with x\", x1, \"and y\", y1);\n    croppedCanvas.getContext(\"2d\").drawImage(canvas, x1, y1, width, height, bounds.x, bounds.y, width, height);\n    return croppedCanvas;\n}\n\nfunction documentWidth (doc) {\n    return Math.max(\n        Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),\n        Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),\n        Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)\n    );\n}\n\nfunction documentHeight (doc) {\n    return Math.max(\n        Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),\n        Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),\n        Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)\n    );\n}\n\nfunction absoluteUrl(url) {\n    var link = document.createElement(\"a\");\n    link.href = url;\n    link.href = link.href;\n    return link;\n}\n\n},{\"./clone\":2,\"./imageloader\":11,\"./log\":13,\"./nodecontainer\":14,\"./nodeparser\":15,\"./proxy\":16,\"./renderers/canvas\":20,\"./support\":22,\"./utils\":26}],5:[function(_dereq_,module,exports){\nvar log = _dereq_('./log');\nvar smallImage = _dereq_('./utils').smallImage;\n\nfunction DummyImageContainer(src) {\n    this.src = src;\n    log(\"DummyImageContainer for\", src);\n    if (!this.promise || !this.image) {\n        log(\"Initiating DummyImageContainer\");\n        DummyImageContainer.prototype.image = new Image();\n        var image = this.image;\n        DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {\n            image.onload = resolve;\n            image.onerror = reject;\n            image.src = smallImage();\n            if (image.complete === true) {\n                resolve(image);\n            }\n        });\n    }\n}\n\nmodule.exports = DummyImageContainer;\n\n},{\"./log\":13,\"./utils\":26}],6:[function(_dereq_,module,exports){\nvar smallImage = _dereq_('./utils').smallImage;\n\nfunction Font(family, size) {\n    var container = document.createElement('div'),\n        img = document.createElement('img'),\n        span = document.createElement('span'),\n        sampleText = 'Hidden Text',\n        baseline,\n        middle;\n\n    container.style.visibility = \"hidden\";\n    container.style.fontFamily = family;\n    container.style.fontSize = size;\n    container.style.margin = 0;\n    container.style.padding = 0;\n\n    document.body.appendChild(container);\n\n    img.src = smallImage();\n    img.width = 1;\n    img.height = 1;\n\n    img.style.margin = 0;\n    img.style.padding = 0;\n    img.style.verticalAlign = \"baseline\";\n\n    span.style.fontFamily = family;\n    span.style.fontSize = size;\n    span.style.margin = 0;\n    span.style.padding = 0;\n\n    span.appendChild(document.createTextNode(sampleText));\n    container.appendChild(span);\n    container.appendChild(img);\n    baseline = (img.offsetTop - span.offsetTop) + 1;\n\n    container.removeChild(span);\n    container.appendChild(document.createTextNode(sampleText));\n\n    container.style.lineHeight = \"normal\";\n    img.style.verticalAlign = \"super\";\n\n    middle = (img.offsetTop-container.offsetTop) + 1;\n\n    document.body.removeChild(container);\n\n    this.baseline = baseline;\n    this.lineWidth = 1;\n    this.middle = middle;\n}\n\nmodule.exports = Font;\n\n},{\"./utils\":26}],7:[function(_dereq_,module,exports){\nvar Font = _dereq_('./font');\n\nfunction FontMetrics() {\n    this.data = {};\n}\n\nFontMetrics.prototype.getMetrics = function(family, size) {\n    if (this.data[family + \"-\" + size] === undefined) {\n        this.data[family + \"-\" + size] = new Font(family, size);\n    }\n    return this.data[family + \"-\" + size];\n};\n\nmodule.exports = FontMetrics;\n\n},{\"./font\":6}],8:[function(_dereq_,module,exports){\nvar utils = _dereq_('./utils');\nvar getBounds = utils.getBounds;\nvar loadUrlDocument = _dereq_('./proxy').loadUrlDocument;\n\nfunction FrameContainer(container, sameOrigin, options) {\n    this.image = null;\n    this.src = container;\n    var self = this;\n    var bounds = getBounds(container);\n    this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {\n        if (container.contentWindow.document.URL === \"about:blank\" || container.contentWindow.document.documentElement == null) {\n            container.contentWindow.onload = container.onload = function() {\n                resolve(container);\n            };\n        } else {\n            resolve(container);\n        }\n    })).then(function(container) {\n        var html2canvas = _dereq_('./core');\n        return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2});\n    }).then(function(canvas) {\n        return self.image = canvas;\n    });\n}\n\nFrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {\n    var container = this.src;\n    return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);\n};\n\nmodule.exports = FrameContainer;\n\n},{\"./core\":4,\"./proxy\":16,\"./utils\":26}],9:[function(_dereq_,module,exports){\nfunction GradientContainer(imageData) {\n    this.src = imageData.value;\n    this.colorStops = [];\n    this.type = null;\n    this.x0 = 0.5;\n    this.y0 = 0.5;\n    this.x1 = 0.5;\n    this.y1 = 0.5;\n    this.promise = Promise.resolve(true);\n}\n\nGradientContainer.TYPES = {\n    LINEAR: 1,\n    RADIAL: 2\n};\n\n// TODO: support hsl[a], negative %/length values\n// TODO: support <angle> (e.g. -?\\d{1,3}(?:\\.\\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )\nGradientContainer.REGEXP_COLORSTOP = /^\\s*(rgba?\\(\\s*\\d{1,3},\\s*\\d{1,3},\\s*\\d{1,3}(?:,\\s*[0-9\\.]+)?\\s*\\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\\s+(\\d{1,3}(?:\\.\\d+)?)(%|px)?)?(?:\\s|$)/i;\n\nmodule.exports = GradientContainer;\n\n},{}],10:[function(_dereq_,module,exports){\nfunction ImageContainer(src, cors) {\n    this.src = src;\n    this.image = new Image();\n    var self = this;\n    this.tainted = null;\n    this.promise = new Promise(function(resolve, reject) {\n        self.image.onload = resolve;\n        self.image.onerror = reject;\n        if (cors) {\n            self.image.crossOrigin = \"anonymous\";\n        }\n        self.image.src = src;\n        if (self.image.complete === true) {\n            resolve(self.image);\n        }\n    });\n}\n\nmodule.exports = ImageContainer;\n\n},{}],11:[function(_dereq_,module,exports){\nvar log = _dereq_('./log');\nvar ImageContainer = _dereq_('./imagecontainer');\nvar DummyImageContainer = _dereq_('./dummyimagecontainer');\nvar ProxyImageContainer = _dereq_('./proxyimagecontainer');\nvar FrameContainer = _dereq_('./framecontainer');\nvar SVGContainer = _dereq_('./svgcontainer');\nvar SVGNodeContainer = _dereq_('./svgnodecontainer');\nvar LinearGradientContainer = _dereq_('./lineargradientcontainer');\nvar WebkitGradientContainer = _dereq_('./webkitgradientcontainer');\nvar bind = _dereq_('./utils').bind;\n\nfunction ImageLoader(options, support) {\n    this.link = null;\n    this.options = options;\n    this.support = support;\n    this.origin = this.getOrigin(window.location.href);\n}\n\nImageLoader.prototype.findImages = function(nodes) {\n    var images = [];\n    nodes.reduce(function(imageNodes, container) {\n        switch(container.node.nodeName) {\n        case \"IMG\":\n            return imageNodes.concat([{\n                args: [container.node.src],\n                method: \"url\"\n            }]);\n        case \"svg\":\n        case \"IFRAME\":\n            return imageNodes.concat([{\n                args: [container.node],\n                method: container.node.nodeName\n            }]);\n        }\n        return imageNodes;\n    }, []).forEach(this.addImage(images, this.loadImage), this);\n    return images;\n};\n\nImageLoader.prototype.findBackgroundImage = function(images, container) {\n    container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);\n    return images;\n};\n\nImageLoader.prototype.addImage = function(images, callback) {\n    return function(newImage) {\n        newImage.args.forEach(function(image) {\n            if (!this.imageExists(images, image)) {\n                images.splice(0, 0, callback.call(this, newImage));\n                log('Added image #' + (images.length), typeof(image) === \"string\" ? image.substring(0, 100) : image);\n            }\n        }, this);\n    };\n};\n\nImageLoader.prototype.hasImageBackground = function(imageData) {\n    return imageData.method !== \"none\";\n};\n\nImageLoader.prototype.loadImage = function(imageData) {\n    if (imageData.method === \"url\") {\n        var src = imageData.args[0];\n        if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {\n            return new SVGContainer(src);\n        } else if (src.match(/data:image\\/.*;base64,/i)) {\n            return new ImageContainer(src.replace(/url\\(['\"]{0,}|['\"]{0,}\\)$/ig, ''), false);\n        } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {\n            return new ImageContainer(src, false);\n        } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {\n            return new ImageContainer(src, true);\n        } else if (this.options.proxy) {\n            return new ProxyImageContainer(src, this.options.proxy);\n        } else {\n            return new DummyImageContainer(src);\n        }\n    } else if (imageData.method === \"linear-gradient\") {\n        return new LinearGradientContainer(imageData);\n    } else if (imageData.method === \"gradient\") {\n        return new WebkitGradientContainer(imageData);\n    } else if (imageData.method === \"svg\") {\n        return new SVGNodeContainer(imageData.args[0], this.support.svg);\n    } else if (imageData.method === \"IFRAME\") {\n        return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);\n    } else {\n        return new DummyImageContainer(imageData);\n    }\n};\n\nImageLoader.prototype.isSVG = function(src) {\n    return src.substring(src.length - 3).toLowerCase() === \"svg\" || SVGContainer.prototype.isInline(src);\n};\n\nImageLoader.prototype.imageExists = function(images, src) {\n    return images.some(function(image) {\n        return image.src === src;\n    });\n};\n\nImageLoader.prototype.isSameOrigin = function(url) {\n    return (this.getOrigin(url) === this.origin);\n};\n\nImageLoader.prototype.getOrigin = function(url) {\n    var link = this.link || (this.link = document.createElement(\"a\"));\n    link.href = url;\n    link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/\n    return link.protocol + link.hostname + link.port;\n};\n\nImageLoader.prototype.getPromise = function(container) {\n    return this.timeout(container, this.options.imageTimeout)['catch'](function() {\n        var dummy = new DummyImageContainer(container.src);\n        return dummy.promise.then(function(image) {\n            container.image = image;\n        });\n    });\n};\n\nImageLoader.prototype.get = function(src) {\n    var found = null;\n    return this.images.some(function(img) {\n        return (found = img).src === src;\n    }) ? found : null;\n};\n\nImageLoader.prototype.fetch = function(nodes) {\n    this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));\n    this.images.forEach(function(image, index) {\n        image.promise.then(function() {\n            log(\"Succesfully loaded image #\"+ (index+1), image);\n        }, function(e) {\n            log(\"Failed loading image #\"+ (index+1), image, e);\n        });\n    });\n    this.ready = Promise.all(this.images.map(this.getPromise, this));\n    log(\"Finished searching images\");\n    return this;\n};\n\nImageLoader.prototype.timeout = function(container, timeout) {\n    var timer;\n    var promise = Promise.race([container.promise, new Promise(function(res, reject) {\n        timer = setTimeout(function() {\n            log(\"Timed out loading image\", container);\n            reject(container);\n        }, timeout);\n    })]).then(function(container) {\n        clearTimeout(timer);\n        return container;\n    });\n    promise['catch'](function() {\n        clearTimeout(timer);\n    });\n    return promise;\n};\n\nmodule.exports = ImageLoader;\n\n},{\"./dummyimagecontainer\":5,\"./framecontainer\":8,\"./imagecontainer\":10,\"./lineargradientcontainer\":12,\"./log\":13,\"./proxyimagecontainer\":17,\"./svgcontainer\":23,\"./svgnodecontainer\":24,\"./utils\":26,\"./webkitgradientcontainer\":27}],12:[function(_dereq_,module,exports){\nvar GradientContainer = _dereq_('./gradientcontainer');\nvar Color = _dereq_('./color');\n\nfunction LinearGradientContainer(imageData) {\n    GradientContainer.apply(this, arguments);\n    this.type = GradientContainer.TYPES.LINEAR;\n\n    var hasDirection = LinearGradientContainer.REGEXP_DIRECTION.test( imageData.args[0] ) ||\n        !GradientContainer.REGEXP_COLORSTOP.test( imageData.args[0] );\n\n    if (hasDirection) {\n        imageData.args[0].split(/\\s+/).reverse().forEach(function(position, index) {\n            switch(position) {\n            case \"left\":\n                this.x0 = 0;\n                this.x1 = 1;\n                break;\n            case \"top\":\n                this.y0 = 0;\n                this.y1 = 1;\n                break;\n            case \"right\":\n                this.x0 = 1;\n                this.x1 = 0;\n                break;\n            case \"bottom\":\n                this.y0 = 1;\n                this.y1 = 0;\n                break;\n            case \"to\":\n                var y0 = this.y0;\n                var x0 = this.x0;\n                this.y0 = this.y1;\n                this.x0 = this.x1;\n                this.x1 = x0;\n                this.y1 = y0;\n                break;\n            case \"center\":\n                break; // centered by default\n            // Firefox internally converts position keywords to percentages:\n            // http://www.w3.org/TR/2010/WD-CSS2-20101207/colors.html#propdef-background-position\n            default: // percentage or absolute length\n                // TODO: support absolute start point positions (e.g., use bounds to convert px to a ratio)\n                var ratio = parseFloat(position, 10) * 1e-2;\n                if (isNaN(ratio)) { // invalid or unhandled value\n                    break;\n                }\n                if (index === 0) {\n                    this.y0 = ratio;\n                    this.y1 = 1 - this.y0;\n                } else {\n                    this.x0 = ratio;\n                    this.x1 = 1 - this.x0;\n                }\n                break;\n            }\n        }, this);\n    } else {\n        this.y0 = 0;\n        this.y1 = 1;\n    }\n\n    this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {\n        var colorStopMatch = colorStop.match(GradientContainer.REGEXP_COLORSTOP);\n        var value = +colorStopMatch[2];\n        var unit = value === 0 ? \"%\" : colorStopMatch[3]; // treat \"0\" as \"0%\"\n        return {\n            color: new Color(colorStopMatch[1]),\n            // TODO: support absolute stop positions (e.g., compute gradient line length & convert px to ratio)\n            stop: unit === \"%\" ? value / 100 : null\n        };\n    });\n\n    if (this.colorStops[0].stop === null) {\n        this.colorStops[0].stop = 0;\n    }\n\n    if (this.colorStops[this.colorStops.length - 1].stop === null) {\n        this.colorStops[this.colorStops.length - 1].stop = 1;\n    }\n\n    // calculates and fills-in explicit stop positions when omitted from rule\n    this.colorStops.forEach(function(colorStop, index) {\n        if (colorStop.stop === null) {\n            this.colorStops.slice(index).some(function(find, count) {\n                if (find.stop !== null) {\n                    colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;\n                    return true;\n                } else {\n                    return false;\n                }\n            }, this);\n        }\n    }, this);\n}\n\nLinearGradientContainer.prototype = Object.create(GradientContainer.prototype);\n\n// TODO: support <angle> (e.g. -?\\d{1,3}(?:\\.\\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )\nLinearGradientContainer.REGEXP_DIRECTION = /^\\s*(?:to|left|right|top|bottom|center|\\d{1,3}(?:\\.\\d+)?%?)(?:\\s|$)/i;\n\nmodule.exports = LinearGradientContainer;\n\n},{\"./color\":3,\"./gradientcontainer\":9}],13:[function(_dereq_,module,exports){\nvar logger = function() {\n    if (logger.options.logging && window.console && window.console.log) {\n        Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - logger.options.start) + \"ms\", \"html2canvas:\"].concat([].slice.call(arguments, 0)));\n    }\n};\n\nlogger.options = {logging: false};\nmodule.exports = logger;\n\n},{}],14:[function(_dereq_,module,exports){\nvar Color = _dereq_('./color');\nvar utils = _dereq_('./utils');\nvar getBounds = utils.getBounds;\nvar parseBackgrounds = utils.parseBackgrounds;\nvar offsetBounds = utils.offsetBounds;\n\nfunction NodeContainer(node, parent) {\n    this.node = node;\n    this.parent = parent;\n    this.stack = null;\n    this.bounds = null;\n    this.borders = null;\n    this.clip = [];\n    this.backgroundClip = [];\n    this.offsetBounds = null;\n    this.visible = null;\n    this.computedStyles = null;\n    this.colors = {};\n    this.styles = {};\n    this.backgroundImages = null;\n    this.transformData = null;\n    this.transformMatrix = null;\n    this.isPseudoElement = false;\n    this.opacity = null;\n}\n\nNodeContainer.prototype.cloneTo = function(stack) {\n    stack.visible = this.visible;\n    stack.borders = this.borders;\n    stack.bounds = this.bounds;\n    stack.clip = this.clip;\n    stack.backgroundClip = this.backgroundClip;\n    stack.computedStyles = this.computedStyles;\n    stack.styles = this.styles;\n    stack.backgroundImages = this.backgroundImages;\n    stack.opacity = this.opacity;\n};\n\nNodeContainer.prototype.getOpacity = function() {\n    return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;\n};\n\nNodeContainer.prototype.assignStack = function(stack) {\n    this.stack = stack;\n    stack.children.push(this);\n};\n\nNodeContainer.prototype.isElementVisible = function() {\n    return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (\n        this.css('display') !== \"none\" &&\n        this.css('visibility') !== \"hidden\" &&\n        !this.node.hasAttribute(\"data-html2canvas-ignore\") &&\n        (this.node.nodeName !== \"INPUT\" || this.node.getAttribute(\"type\") !== \"hidden\")\n    );\n};\n\nNodeContainer.prototype.css = function(attribute) {\n    if (!this.computedStyles) {\n        this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? \":before\" : \":after\") : this.computedStyle(null);\n    }\n\n    return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);\n};\n\nNodeContainer.prototype.prefixedCss = function(attribute) {\n    var prefixes = [\"webkit\", \"moz\", \"ms\", \"o\"];\n    var value = this.css(attribute);\n    if (value === undefined) {\n        prefixes.some(function(prefix) {\n            value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));\n            return value !== undefined;\n        }, this);\n    }\n    return value === undefined ? null : value;\n};\n\nNodeContainer.prototype.computedStyle = function(type) {\n    return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);\n};\n\nNodeContainer.prototype.cssInt = function(attribute) {\n    var value = parseInt(this.css(attribute), 10);\n    return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html\n};\n\nNodeContainer.prototype.color = function(attribute) {\n    return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));\n};\n\nNodeContainer.prototype.cssFloat = function(attribute) {\n    var value = parseFloat(this.css(attribute));\n    return (isNaN(value)) ? 0 : value;\n};\n\nNodeContainer.prototype.fontWeight = function() {\n    var weight = this.css(\"fontWeight\");\n    switch(parseInt(weight, 10)){\n    case 401:\n        weight = \"bold\";\n        break;\n    case 400:\n        weight = \"normal\";\n        break;\n    }\n    return weight;\n};\n\nNodeContainer.prototype.parseClip = function() {\n    var matches = this.css('clip').match(this.CLIP);\n    if (matches) {\n        return {\n            top: parseInt(matches[1], 10),\n            right: parseInt(matches[2], 10),\n            bottom: parseInt(matches[3], 10),\n            left: parseInt(matches[4], 10)\n        };\n    }\n    return null;\n};\n\nNodeContainer.prototype.parseBackgroundImages = function() {\n    return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css(\"backgroundImage\")));\n};\n\nNodeContainer.prototype.cssList = function(property, index) {\n    var value = (this.css(property) || '').split(',');\n    value = value[index || 0] || value[0] || 'auto';\n    value = value.trim().split(' ');\n    if (value.length === 1) {\n        value = [value[0], isPercentage(value[0]) ? 'auto' : value[0]];\n    }\n    return value;\n};\n\nNodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {\n    var size = this.cssList(\"backgroundSize\", index);\n    var width, height;\n\n    if (isPercentage(size[0])) {\n        width = bounds.width * parseFloat(size[0]) / 100;\n    } else if (/contain|cover/.test(size[0])) {\n        var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height;\n        return (targetRatio < currentRatio ^ size[0] === 'contain') ?  {width: bounds.height * currentRatio, height: bounds.height} : {width: bounds.width, height: bounds.width / currentRatio};\n    } else {\n        width = parseInt(size[0], 10);\n    }\n\n    if (size[0] === 'auto' && size[1] === 'auto') {\n        height = image.height;\n    } else if (size[1] === 'auto') {\n        height = width / image.width * image.height;\n    } else if (isPercentage(size[1])) {\n        height =  bounds.height * parseFloat(size[1]) / 100;\n    } else {\n        height = parseInt(size[1], 10);\n    }\n\n    if (size[0] === 'auto') {\n        width = height / image.height * image.width;\n    }\n\n    return {width: width, height: height};\n};\n\nNodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {\n    var position = this.cssList('backgroundPosition', index);\n    var left, top;\n\n    if (isPercentage(position[0])){\n        left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);\n    } else {\n        left = parseInt(position[0], 10);\n    }\n\n    if (position[1] === 'auto') {\n        top = left / image.width * image.height;\n    } else if (isPercentage(position[1])){\n        top =  (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;\n    } else {\n        top = parseInt(position[1], 10);\n    }\n\n    if (position[0] === 'auto') {\n        left = top / image.height * image.width;\n    }\n\n    return {left: left, top: top};\n};\n\nNodeContainer.prototype.parseBackgroundRepeat = function(index) {\n    return this.cssList(\"backgroundRepeat\", index)[0];\n};\n\nNodeContainer.prototype.parseTextShadows = function() {\n    var textShadow = this.css(\"textShadow\");\n    var results = [];\n\n    if (textShadow && textShadow !== 'none') {\n        var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);\n        for (var i = 0; shadows && (i < shadows.length); i++) {\n            var s = shadows[i].match(this.TEXT_SHADOW_VALUES);\n            results.push({\n                color: new Color(s[0]),\n                offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,\n                offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,\n                blur: s[3] ? s[3].replace('px', '') : 0\n            });\n        }\n    }\n    return results;\n};\n\nNodeContainer.prototype.parseTransform = function() {\n    if (!this.transformData) {\n        if (this.hasTransform()) {\n            var offset = this.parseBounds();\n            var origin = this.prefixedCss(\"transformOrigin\").split(\" \").map(removePx).map(asFloat);\n            origin[0] += offset.left;\n            origin[1] += offset.top;\n            this.transformData = {\n                origin: origin,\n                matrix: this.parseTransformMatrix()\n            };\n        } else {\n            this.transformData = {\n                origin: [0, 0],\n                matrix: [1, 0, 0, 1, 0, 0]\n            };\n        }\n    }\n    return this.transformData;\n};\n\nNodeContainer.prototype.parseTransformMatrix = function() {\n    if (!this.transformMatrix) {\n        var transform = this.prefixedCss(\"transform\");\n        var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;\n        this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];\n    }\n    return this.transformMatrix;\n};\n\nNodeContainer.prototype.parseBounds = function() {\n    return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));\n};\n\nNodeContainer.prototype.hasTransform = function() {\n    return this.parseTransformMatrix().join(\",\") !== \"1,0,0,1,0,0\" || (this.parent && this.parent.hasTransform());\n};\n\nNodeContainer.prototype.getValue = function() {\n    var value = this.node.value || \"\";\n    if (this.node.tagName === \"SELECT\") {\n        value = selectionValue(this.node);\n    } else if (this.node.type === \"password\") {\n        value = Array(value.length + 1).join('\\u2022'); // jshint ignore:line\n    }\n    return value.length === 0 ? (this.node.placeholder || \"\") : value;\n};\n\nNodeContainer.prototype.MATRIX_PROPERTY = /(matrix|matrix3d)\\((.+)\\)/;\nNodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\\([^\\)]+\\)(\\s-?\\d+px){0,})/g;\nNodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\\d+px)|(#.+)|(rgb\\(.+\\))|(rgba\\(.+\\))/g;\nNodeContainer.prototype.CLIP = /^rect\\((\\d+)px,? (\\d+)px,? (\\d+)px,? (\\d+)px\\)$/;\n\nfunction selectionValue(node) {\n    var option = node.options[node.selectedIndex || 0];\n    return option ? (option.text || \"\") : \"\";\n}\n\nfunction parseMatrix(match) {\n    if (match && match[1] === \"matrix\") {\n        return match[2].split(\",\").map(function(s) {\n            return parseFloat(s.trim());\n        });\n    } else if (match && match[1] === \"matrix3d\") {\n        var matrix3d = match[2].split(\",\").map(function(s) {\n          return parseFloat(s.trim());\n        });\n        return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];\n    }\n}\n\nfunction isPercentage(value) {\n    return value.toString().indexOf(\"%\") !== -1;\n}\n\nfunction removePx(str) {\n    return str.replace(\"px\", \"\");\n}\n\nfunction asFloat(str) {\n    return parseFloat(str);\n}\n\nmodule.exports = NodeContainer;\n\n},{\"./color\":3,\"./utils\":26}],15:[function(_dereq_,module,exports){\nvar log = _dereq_('./log');\nvar punycode = _dereq_('punycode');\nvar NodeContainer = _dereq_('./nodecontainer');\nvar TextContainer = _dereq_('./textcontainer');\nvar PseudoElementContainer = _dereq_('./pseudoelementcontainer');\nvar FontMetrics = _dereq_('./fontmetrics');\nvar Color = _dereq_('./color');\nvar StackingContext = _dereq_('./stackingcontext');\nvar utils = _dereq_('./utils');\nvar bind = utils.bind;\nvar getBounds = utils.getBounds;\nvar parseBackgrounds = utils.parseBackgrounds;\nvar offsetBounds = utils.offsetBounds;\n\nfunction NodeParser(element, renderer, support, imageLoader, options) {\n    log(\"Starting NodeParser\");\n    this.renderer = renderer;\n    this.options = options;\n    this.range = null;\n    this.support = support;\n    this.renderQueue = [];\n    this.stack = new StackingContext(true, 1, element.ownerDocument, null);\n    var parent = new NodeContainer(element, null);\n    if (options.background) {\n        renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));\n    }\n    if (element === element.ownerDocument.documentElement) {\n        // http://www.w3.org/TR/css3-background/#special-backgrounds\n        var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);\n        renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));\n    }\n    parent.visibile = parent.isElementVisible();\n    this.createPseudoHideStyles(element.ownerDocument);\n    this.disableAnimations(element.ownerDocument);\n    this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {\n        return container.visible = container.isElementVisible();\n    }).map(this.getPseudoElements, this));\n    this.fontMetrics = new FontMetrics();\n    log(\"Fetched nodes, total:\", this.nodes.length);\n    log(\"Calculate overflow clips\");\n    this.calculateOverflowClips();\n    log(\"Start fetching images\");\n    this.images = imageLoader.fetch(this.nodes.filter(isElement));\n    this.ready = this.images.ready.then(bind(function() {\n        log(\"Images loaded, starting parsing\");\n        log(\"Creating stacking contexts\");\n        this.createStackingContexts();\n        log(\"Sorting stacking contexts\");\n        this.sortStackingContexts(this.stack);\n        this.parse(this.stack);\n        log(\"Render queue created with \" + this.renderQueue.length + \" items\");\n        return new Promise(bind(function(resolve) {\n            if (!options.async) {\n                this.renderQueue.forEach(this.paint, this);\n                resolve();\n            } else if (typeof(options.async) === \"function\") {\n                options.async.call(this, this.renderQueue, resolve);\n            } else if (this.renderQueue.length > 0){\n                this.renderIndex = 0;\n                this.asyncRenderer(this.renderQueue, resolve);\n            } else {\n                resolve();\n            }\n        }, this));\n    }, this));\n}\n\nNodeParser.prototype.calculateOverflowClips = function() {\n    this.nodes.forEach(function(container) {\n        if (isElement(container)) {\n            if (isPseudoElement(container)) {\n                container.appendToDOM();\n            }\n            container.borders = this.parseBorders(container);\n            var clip = (container.css('overflow') === \"hidden\") ? [container.borders.clip] : [];\n            var cssClip = container.parseClip();\n            if (cssClip && [\"absolute\", \"fixed\"].indexOf(container.css('position')) !== -1) {\n                clip.push([[\"rect\",\n                        container.bounds.left + cssClip.left,\n                        container.bounds.top + cssClip.top,\n                        cssClip.right - cssClip.left,\n                        cssClip.bottom - cssClip.top\n                ]]);\n            }\n            container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;\n            container.backgroundClip = (container.css('overflow') !== \"hidden\") ? container.clip.concat([container.borders.clip]) : container.clip;\n            if (isPseudoElement(container)) {\n                container.cleanDOM();\n            }\n        } else if (isTextNode(container)) {\n            container.clip = hasParentClip(container) ? container.parent.clip : [];\n        }\n        if (!isPseudoElement(container)) {\n            container.bounds = null;\n        }\n    }, this);\n};\n\nfunction hasParentClip(container) {\n    return container.parent && container.parent.clip.length;\n}\n\nNodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {\n    asyncTimer = asyncTimer || Date.now();\n    this.paint(queue[this.renderIndex++]);\n    if (queue.length === this.renderIndex) {\n        resolve();\n    } else if (asyncTimer + 20 > Date.now()) {\n        this.asyncRenderer(queue, resolve, asyncTimer);\n    } else {\n        setTimeout(bind(function() {\n            this.asyncRenderer(queue, resolve);\n        }, this), 0);\n    }\n};\n\nNodeParser.prototype.createPseudoHideStyles = function(document) {\n    this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: \"\" !important; display: none !important; }' +\n        '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: \"\" !important; display: none !important; }');\n};\n\nNodeParser.prototype.disableAnimations = function(document) {\n    this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +\n        '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');\n};\n\nNodeParser.prototype.createStyles = function(document, styles) {\n    var hidePseudoElements = document.createElement('style');\n    hidePseudoElements.innerHTML = styles;\n    document.body.appendChild(hidePseudoElements);\n};\n\nNodeParser.prototype.getPseudoElements = function(container) {\n    var nodes = [[container]];\n    if (container.node.nodeType === Node.ELEMENT_NODE) {\n        var before = this.getPseudoElement(container, \":before\");\n        var after = this.getPseudoElement(container, \":after\");\n\n        if (before) {\n            nodes.push(before);\n        }\n\n        if (after) {\n            nodes.push(after);\n        }\n    }\n    return flatten(nodes);\n};\n\nfunction toCamelCase(str) {\n    return str.replace(/(\\-[a-z])/g, function(match){\n        return match.toUpperCase().replace('-','');\n    });\n}\n\nNodeParser.prototype.getPseudoElement = function(container, type) {\n    var style = container.computedStyle(type);\n    if(!style || !style.content || style.content === \"none\" || style.content === \"-moz-alt-content\" || style.display === \"none\") {\n        return null;\n    }\n\n    var content = stripQuotes(style.content);\n    var isImage = content.substr(0, 3) === 'url';\n    var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');\n    var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);\n\n    for (var i = style.length-1; i >= 0; i--) {\n        var property = toCamelCase(style.item(i));\n        pseudoNode.style[property] = style[property];\n    }\n\n    pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + \" \" + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;\n\n    if (isImage) {\n        pseudoNode.src = parseBackgrounds(content)[0].args[0];\n        return [pseudoContainer];\n    } else {\n        var text = document.createTextNode(content);\n        pseudoNode.appendChild(text);\n        return [pseudoContainer, new TextContainer(text, pseudoContainer)];\n    }\n};\n\n\nNodeParser.prototype.getChildren = function(parentContainer) {\n    return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {\n        var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);\n        return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== \"TEXTAREA\" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;\n    }, this));\n};\n\nNodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {\n    var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);\n    container.cloneTo(stack);\n    var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;\n    parentStack.contexts.push(stack);\n    container.stack = stack;\n};\n\nNodeParser.prototype.createStackingContexts = function() {\n    this.nodes.forEach(function(container) {\n        if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {\n            this.newStackingContext(container, true);\n        } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {\n            this.newStackingContext(container, false);\n        } else {\n            container.assignStack(container.parent.stack);\n        }\n    }, this);\n};\n\nNodeParser.prototype.isBodyWithTransparentRoot = function(container) {\n    return container.node.nodeName === \"BODY\" && container.parent.color('backgroundColor').isTransparent();\n};\n\nNodeParser.prototype.isRootElement = function(container) {\n    return container.parent === null;\n};\n\nNodeParser.prototype.sortStackingContexts = function(stack) {\n    stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));\n    stack.contexts.forEach(this.sortStackingContexts, this);\n};\n\nNodeParser.prototype.parseTextBounds = function(container) {\n    return function(text, index, textList) {\n        if (container.parent.css(\"textDecoration\").substr(0, 4) !== \"none\" || text.trim().length !== 0) {\n            if (this.support.rangeBounds && !container.parent.hasTransform()) {\n                var offset = textList.slice(0, index).join(\"\").length;\n                return this.getRangeBounds(container.node, offset, text.length);\n            } else if (container.node && typeof(container.node.data) === \"string\") {\n                var replacementNode = container.node.splitText(text.length);\n                var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());\n                container.node = replacementNode;\n                return bounds;\n            }\n        } else if(!this.support.rangeBounds || container.parent.hasTransform()){\n            container.node = container.node.splitText(text.length);\n        }\n        return {};\n    };\n};\n\nNodeParser.prototype.getWrapperBounds = function(node, transform) {\n    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');\n    var parent = node.parentNode,\n        backupText = node.cloneNode(true);\n\n    wrapper.appendChild(node.cloneNode(true));\n    parent.replaceChild(wrapper, node);\n    var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);\n    parent.replaceChild(backupText, wrapper);\n    return bounds;\n};\n\nNodeParser.prototype.getRangeBounds = function(node, offset, length) {\n    var range = this.range || (this.range = node.ownerDocument.createRange());\n    range.setStart(node, offset);\n    range.setEnd(node, offset + length);\n    return range.getBoundingClientRect();\n};\n\nfunction ClearTransform() {}\n\nNodeParser.prototype.parse = function(stack) {\n    // http://www.w3.org/TR/CSS21/visuren.html#z-index\n    var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).\n    var descendantElements = stack.children.filter(isElement);\n    var descendantNonFloats = descendantElements.filter(not(isFloating));\n    var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.\n    var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.\n    var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.\n    var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.\n    var text = stack.children.filter(isTextNode).filter(hasText);\n    var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).\n    negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)\n        .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {\n            this.renderQueue.push(container);\n            if (isStackingContext(container)) {\n                this.parse(container);\n                this.renderQueue.push(new ClearTransform());\n            }\n        }, this);\n};\n\nNodeParser.prototype.paint = function(container) {\n    try {\n        if (container instanceof ClearTransform) {\n            this.renderer.ctx.restore();\n        } else if (isTextNode(container)) {\n            if (isPseudoElement(container.parent)) {\n                container.parent.appendToDOM();\n            }\n            this.paintText(container);\n            if (isPseudoElement(container.parent)) {\n                container.parent.cleanDOM();\n            }\n        } else {\n            this.paintNode(container);\n        }\n    } catch(e) {\n        log(e);\n        if (this.options.strict) {\n            throw e;\n        }\n    }\n};\n\nNodeParser.prototype.paintNode = function(container) {\n    if (isStackingContext(container)) {\n        this.renderer.setOpacity(container.opacity);\n        this.renderer.ctx.save();\n        if (container.hasTransform()) {\n            this.renderer.setTransform(container.parseTransform());\n        }\n    }\n\n    if (container.node.nodeName === \"INPUT\" && container.node.type === \"checkbox\") {\n        this.paintCheckbox(container);\n    } else if (container.node.nodeName === \"INPUT\" && container.node.type === \"radio\") {\n        this.paintRadio(container);\n    } else {\n        this.paintElement(container);\n    }\n};\n\nNodeParser.prototype.paintElement = function(container) {\n    var bounds = container.parseBounds();\n    this.renderer.clip(container.backgroundClip, function() {\n        this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));\n    }, this);\n\n    this.renderer.clip(container.clip, function() {\n        this.renderer.renderBorders(container.borders.borders);\n    }, this);\n\n    this.renderer.clip(container.backgroundClip, function() {\n        switch (container.node.nodeName) {\n        case \"svg\":\n        case \"IFRAME\":\n            var imgContainer = this.images.get(container.node);\n            if (imgContainer) {\n                this.renderer.renderImage(container, bounds, container.borders, imgContainer);\n            } else {\n                log(\"Error loading <\" + container.node.nodeName + \">\", container.node);\n            }\n            break;\n        case \"IMG\":\n            var imageContainer = this.images.get(container.node.src);\n            if (imageContainer) {\n                this.renderer.renderImage(container, bounds, container.borders, imageContainer);\n            } else {\n                log(\"Error loading <img>\", container.node.src);\n            }\n            break;\n        case \"CANVAS\":\n            this.renderer.renderImage(container, bounds, container.borders, {image: container.node});\n            break;\n        case \"SELECT\":\n        case \"INPUT\":\n        case \"TEXTAREA\":\n            this.paintFormValue(container);\n            break;\n        }\n    }, this);\n};\n\nNodeParser.prototype.paintCheckbox = function(container) {\n    var b = container.parseBounds();\n\n    var size = Math.min(b.width, b.height);\n    var bounds = {width: size - 1, height: size - 1, top: b.top, left: b.left};\n    var r = [3, 3];\n    var radius = [r, r, r, r];\n    var borders = [1,1,1,1].map(function(w) {\n        return {color: new Color('#A5A5A5'), width: w};\n    });\n\n    var borderPoints = calculateCurvePoints(bounds, radius, borders);\n\n    this.renderer.clip(container.backgroundClip, function() {\n        this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color(\"#DEDEDE\"));\n        this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));\n        if (container.node.checked) {\n            this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + \"px\", 'arial');\n            this.renderer.text(\"\\u2714\", bounds.left + size / 6, bounds.top + size - 1);\n        }\n    }, this);\n};\n\nNodeParser.prototype.paintRadio = function(container) {\n    var bounds = container.parseBounds();\n\n    var size = Math.min(bounds.width, bounds.height) - 2;\n\n    this.renderer.clip(container.backgroundClip, function() {\n        this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));\n        if (container.node.checked) {\n            this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));\n        }\n    }, this);\n};\n\nNodeParser.prototype.paintFormValue = function(container) {\n    var value = container.getValue();\n    if (value.length > 0) {\n        var document = container.node.ownerDocument;\n        var wrapper = document.createElement('html2canvaswrapper');\n        var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',\n            'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',\n            'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',\n            'boxSizing', 'whiteSpace', 'wordWrap'];\n\n        properties.forEach(function(property) {\n            try {\n                wrapper.style[property] = container.css(property);\n            } catch(e) {\n                // Older IE has issues with \"border\"\n                log(\"html2canvas: Parse: Exception caught in renderFormValue: \" + e.message);\n            }\n        });\n        var bounds = container.parseBounds();\n        wrapper.style.position = \"fixed\";\n        wrapper.style.left = bounds.left + \"px\";\n        wrapper.style.top = bounds.top + \"px\";\n        wrapper.textContent = value;\n        document.body.appendChild(wrapper);\n        this.paintText(new TextContainer(wrapper.firstChild, container));\n        document.body.removeChild(wrapper);\n    }\n};\n\nNodeParser.prototype.paintText = function(container) {\n    container.applyTextTransform();\n    var characters = punycode.ucs2.decode(container.node.data);\n    var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {\n        return punycode.ucs2.encode([character]);\n    });\n\n    var weight = container.parent.fontWeight();\n    var size = container.parent.css('fontSize');\n    var family = container.parent.css('fontFamily');\n    var shadows = container.parent.parseTextShadows();\n\n    this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);\n    if (shadows.length) {\n        // TODO: support multiple text shadows\n        this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);\n    } else {\n        this.renderer.clearShadow();\n    }\n\n    this.renderer.clip(container.parent.clip, function() {\n        textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {\n            if (bounds) {\n                this.renderer.text(textList[index], bounds.left, bounds.bottom);\n                this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));\n            }\n        }, this);\n    }, this);\n};\n\nNodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {\n    switch(container.css(\"textDecoration\").split(\" \")[0]) {\n    case \"underline\":\n        // Draws a line at the baseline of the font\n        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size\n        this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color(\"color\"));\n        break;\n    case \"overline\":\n        this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color(\"color\"));\n        break;\n    case \"line-through\":\n        // TODO try and find exact position for line-through\n        this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color(\"color\"));\n        break;\n    }\n};\n\nvar borderColorTransforms = {\n    inset: [\n        [\"darken\", 0.60],\n        [\"darken\", 0.10],\n        [\"darken\", 0.10],\n        [\"darken\", 0.60]\n    ]\n};\n\nNodeParser.prototype.parseBorders = function(container) {\n    var nodeBounds = container.parseBounds();\n    var radius = getBorderRadiusData(container);\n    var borders = [\"Top\", \"Right\", \"Bottom\", \"Left\"].map(function(side, index) {\n        var style = container.css('border' + side + 'Style');\n        var color = container.color('border' + side + 'Color');\n        if (style === \"inset\" && color.isBlack()) {\n            color = new Color([255, 255, 255, color.a]); // this is wrong, but\n        }\n        var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;\n        return {\n            width: container.cssInt('border' + side + 'Width'),\n            color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,\n            args: null\n        };\n    });\n    var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);\n\n    return {\n        clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),\n        borders: calculateBorders(borders, nodeBounds, borderPoints, radius)\n    };\n};\n\nfunction calculateBorders(borders, nodeBounds, borderPoints, radius) {\n    return borders.map(function(border, borderSide) {\n        if (border.width > 0) {\n            var bx = nodeBounds.left;\n            var by = nodeBounds.top;\n            var bw = nodeBounds.width;\n            var bh = nodeBounds.height - (borders[2].width);\n\n            switch(borderSide) {\n            case 0:\n                // top border\n                bh = borders[0].width;\n                border.args = drawSide({\n                        c1: [bx, by],\n                        c2: [bx + bw, by],\n                        c3: [bx + bw - borders[1].width, by + bh],\n                        c4: [bx + borders[3].width, by + bh]\n                    }, radius[0], radius[1],\n                    borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);\n                break;\n            case 1:\n                // right border\n                bx = nodeBounds.left + nodeBounds.width - (borders[1].width);\n                bw = borders[1].width;\n\n                border.args = drawSide({\n                        c1: [bx + bw, by],\n                        c2: [bx + bw, by + bh + borders[2].width],\n                        c3: [bx, by + bh],\n                        c4: [bx, by + borders[0].width]\n                    }, radius[1], radius[2],\n                    borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);\n                break;\n            case 2:\n                // bottom border\n                by = (by + nodeBounds.height) - (borders[2].width);\n                bh = borders[2].width;\n                border.args = drawSide({\n                        c1: [bx + bw, by + bh],\n                        c2: [bx, by + bh],\n                        c3: [bx + borders[3].width, by],\n                        c4: [bx + bw - borders[3].width, by]\n                    }, radius[2], radius[3],\n                    borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);\n                break;\n            case 3:\n                // left border\n                bw = borders[3].width;\n                border.args = drawSide({\n                        c1: [bx, by + bh + borders[2].width],\n                        c2: [bx, by],\n                        c3: [bx + bw, by + borders[0].width],\n                        c4: [bx + bw, by + bh]\n                    }, radius[3], radius[0],\n                    borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);\n                break;\n            }\n        }\n        return border;\n    });\n}\n\nNodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {\n    var backgroundClip = container.css('backgroundClip'),\n        borderArgs = [];\n\n    switch(backgroundClip) {\n    case \"content-box\":\n    case \"padding-box\":\n        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);\n        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);\n        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);\n        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);\n        break;\n\n    default:\n        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);\n        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);\n        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);\n        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);\n        break;\n    }\n\n    return borderArgs;\n};\n\nfunction getCurvePoints(x, y, r1, r2) {\n    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);\n    var ox = (r1) * kappa, // control point offset horizontal\n        oy = (r2) * kappa, // control point offset vertical\n        xm = x + r1, // x-middle\n        ym = y + r2; // y-middle\n    return {\n        topLeft: bezierCurve({x: x, y: ym}, {x: x, y: ym - oy}, {x: xm - ox, y: y}, {x: xm, y: y}),\n        topRight: bezierCurve({x: x, y: y}, {x: x + ox,y: y}, {x: xm, y: ym - oy}, {x: xm, y: ym}),\n        bottomRight: bezierCurve({x: xm, y: y}, {x: xm, y: y + oy}, {x: x + ox, y: ym}, {x: x, y: ym}),\n        bottomLeft: bezierCurve({x: xm, y: ym}, {x: xm - ox, y: ym}, {x: x, y: y + oy}, {x: x, y:y})\n    };\n}\n\nfunction calculateCurvePoints(bounds, borderRadius, borders) {\n    var x = bounds.left,\n        y = bounds.top,\n        width = bounds.width,\n        height = bounds.height,\n\n        tlh = borderRadius[0][0] < width / 2 ? borderRadius[0][0] : width / 2,\n        tlv = borderRadius[0][1] < height / 2 ? borderRadius[0][1] : height / 2,\n        trh = borderRadius[1][0] < width / 2 ? borderRadius[1][0] : width / 2,\n        trv = borderRadius[1][1] < height / 2 ? borderRadius[1][1] : height / 2,\n        brh = borderRadius[2][0] < width / 2 ? borderRadius[2][0] : width / 2,\n        brv = borderRadius[2][1] < height / 2 ? borderRadius[2][1] : height / 2,\n        blh = borderRadius[3][0] < width / 2 ? borderRadius[3][0] : width / 2,\n        blv = borderRadius[3][1] < height / 2 ? borderRadius[3][1] : height / 2;\n\n    var topWidth = width - trh,\n        rightHeight = height - brv,\n        bottomWidth = width - brh,\n        leftHeight = height - blv;\n\n    return {\n        topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),\n        topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),\n        topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),\n        topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),\n        bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),\n        bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width),  brv - borders[2].width).bottomRight.subdivide(0.5),\n        bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),\n        bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)\n    };\n}\n\nfunction bezierCurve(start, startControl, endControl, end) {\n    var lerp = function (a, b, t) {\n        return {\n            x: a.x + (b.x - a.x) * t,\n            y: a.y + (b.y - a.y) * t\n        };\n    };\n\n    return {\n        start: start,\n        startControl: startControl,\n        endControl: endControl,\n        end: end,\n        subdivide: function(t) {\n            var ab = lerp(start, startControl, t),\n                bc = lerp(startControl, endControl, t),\n                cd = lerp(endControl, end, t),\n                abbc = lerp(ab, bc, t),\n                bccd = lerp(bc, cd, t),\n                dest = lerp(abbc, bccd, t);\n            return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];\n        },\n        curveTo: function(borderArgs) {\n            borderArgs.push([\"bezierCurve\", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);\n        },\n        curveToReversed: function(borderArgs) {\n            borderArgs.push([\"bezierCurve\", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);\n        }\n    };\n}\n\nfunction drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {\n    var borderArgs = [];\n\n    if (radius1[0] > 0 || radius1[1] > 0) {\n        borderArgs.push([\"line\", outer1[1].start.x, outer1[1].start.y]);\n        outer1[1].curveTo(borderArgs);\n    } else {\n        borderArgs.push([ \"line\", borderData.c1[0], borderData.c1[1]]);\n    }\n\n    if (radius2[0] > 0 || radius2[1] > 0) {\n        borderArgs.push([\"line\", outer2[0].start.x, outer2[0].start.y]);\n        outer2[0].curveTo(borderArgs);\n        borderArgs.push([\"line\", inner2[0].end.x, inner2[0].end.y]);\n        inner2[0].curveToReversed(borderArgs);\n    } else {\n        borderArgs.push([\"line\", borderData.c2[0], borderData.c2[1]]);\n        borderArgs.push([\"line\", borderData.c3[0], borderData.c3[1]]);\n    }\n\n    if (radius1[0] > 0 || radius1[1] > 0) {\n        borderArgs.push([\"line\", inner1[1].end.x, inner1[1].end.y]);\n        inner1[1].curveToReversed(borderArgs);\n    } else {\n        borderArgs.push([\"line\", borderData.c4[0], borderData.c4[1]]);\n    }\n\n    return borderArgs;\n}\n\nfunction parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {\n    if (radius1[0] > 0 || radius1[1] > 0) {\n        borderArgs.push([\"line\", corner1[0].start.x, corner1[0].start.y]);\n        corner1[0].curveTo(borderArgs);\n        corner1[1].curveTo(borderArgs);\n    } else {\n        borderArgs.push([\"line\", x, y]);\n    }\n\n    if (radius2[0] > 0 || radius2[1] > 0) {\n        borderArgs.push([\"line\", corner2[0].start.x, corner2[0].start.y]);\n    }\n}\n\nfunction negativeZIndex(container) {\n    return container.cssInt(\"zIndex\") < 0;\n}\n\nfunction positiveZIndex(container) {\n    return container.cssInt(\"zIndex\") > 0;\n}\n\nfunction zIndex0(container) {\n    return container.cssInt(\"zIndex\") === 0;\n}\n\nfunction inlineLevel(container) {\n    return [\"inline\", \"inline-block\", \"inline-table\"].indexOf(container.css(\"display\")) !== -1;\n}\n\nfunction isStackingContext(container) {\n    return (container instanceof StackingContext);\n}\n\nfunction hasText(container) {\n    return container.node.data.trim().length > 0;\n}\n\nfunction noLetterSpacing(container) {\n    return (/^(normal|none|0px)$/.test(container.parent.css(\"letterSpacing\")));\n}\n\nfunction getBorderRadiusData(container) {\n    return [\"TopLeft\", \"TopRight\", \"BottomRight\", \"BottomLeft\"].map(function(side) {\n        var value = container.css('border' + side + 'Radius');\n        var arr = value.split(\" \");\n        if (arr.length <= 1) {\n            arr[1] = arr[0];\n        }\n        return arr.map(asInt);\n    });\n}\n\nfunction renderableNode(node) {\n    return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);\n}\n\nfunction isPositionedForStacking(container) {\n    var position = container.css(\"position\");\n    var zIndex = ([\"absolute\", \"relative\", \"fixed\"].indexOf(position) !== -1) ? container.css(\"zIndex\") : \"auto\";\n    return zIndex !== \"auto\";\n}\n\nfunction isPositioned(container) {\n    return container.css(\"position\") !== \"static\";\n}\n\nfunction isFloating(container) {\n    return container.css(\"float\") !== \"none\";\n}\n\nfunction isInlineBlock(container) {\n    return [\"inline-block\", \"inline-table\"].indexOf(container.css(\"display\")) !== -1;\n}\n\nfunction not(callback) {\n    var context = this;\n    return function() {\n        return !callback.apply(context, arguments);\n    };\n}\n\nfunction isElement(container) {\n    return container.node.nodeType === Node.ELEMENT_NODE;\n}\n\nfunction isPseudoElement(container) {\n    return container.isPseudoElement === true;\n}\n\nfunction isTextNode(container) {\n    return container.node.nodeType === Node.TEXT_NODE;\n}\n\nfunction zIndexSort(contexts) {\n    return function(a, b) {\n        return (a.cssInt(\"zIndex\") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt(\"zIndex\") + (contexts.indexOf(b) / contexts.length));\n    };\n}\n\nfunction hasOpacity(container) {\n    return container.getOpacity() < 1;\n}\n\nfunction asInt(value) {\n    return parseInt(value, 10);\n}\n\nfunction getWidth(border) {\n    return border.width;\n}\n\nfunction nonIgnoredElement(nodeContainer) {\n    return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || [\"SCRIPT\", \"HEAD\", \"TITLE\", \"OBJECT\", \"BR\", \"OPTION\"].indexOf(nodeContainer.node.nodeName) === -1);\n}\n\nfunction flatten(arrays) {\n    return [].concat.apply([], arrays);\n}\n\nfunction stripQuotes(content) {\n    var first = content.substr(0, 1);\n    return (first === content.substr(content.length - 1) && first.match(/'|\"/)) ? content.substr(1, content.length - 2) : content;\n}\n\nfunction getWords(characters) {\n    var words = [], i = 0, onWordBoundary = false, word;\n    while(characters.length) {\n        if (isWordBoundary(characters[i]) === onWordBoundary) {\n            word = characters.splice(0, i);\n            if (word.length) {\n                words.push(punycode.ucs2.encode(word));\n            }\n            onWordBoundary =! onWordBoundary;\n            i = 0;\n        } else {\n            i++;\n        }\n\n        if (i >= characters.length) {\n            word = characters.splice(0, i);\n            if (word.length) {\n                words.push(punycode.ucs2.encode(word));\n            }\n        }\n    }\n    return words;\n}\n\nfunction isWordBoundary(characterCode) {\n    return [\n        32, // <space>\n        13, // \\r\n        10, // \\n\n        9, // \\t\n        45 // -\n    ].indexOf(characterCode) !== -1;\n}\n\nfunction hasUnicode(string) {\n    return (/[^\\u0000-\\u00ff]/).test(string);\n}\n\nmodule.exports = NodeParser;\n\n},{\"./color\":3,\"./fontmetrics\":7,\"./log\":13,\"./nodecontainer\":14,\"./pseudoelementcontainer\":18,\"./stackingcontext\":21,\"./textcontainer\":25,\"./utils\":26,\"punycode\":1}],16:[function(_dereq_,module,exports){\nvar XHR = _dereq_('./xhr');\nvar utils = _dereq_('./utils');\nvar log = _dereq_('./log');\nvar createWindowClone = _dereq_('./clone');\nvar decode64 = utils.decode64;\n\nfunction Proxy(src, proxyUrl, document) {\n    var supportsCORS = ('withCredentials' in new XMLHttpRequest());\n    if (!proxyUrl) {\n        return Promise.reject(\"No proxy configured\");\n    }\n    var callback = createCallback(supportsCORS);\n    var url = createProxyUrl(proxyUrl, src, callback);\n\n    return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {\n        return decode64(response.content);\n    }));\n}\nvar proxyCount = 0;\n\nfunction ProxyURL(src, proxyUrl, document) {\n    var supportsCORSImage = ('crossOrigin' in new Image());\n    var callback = createCallback(supportsCORSImage);\n    var url = createProxyUrl(proxyUrl, src, callback);\n    return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {\n        return \"data:\" + response.type + \";base64,\" + response.content;\n    }));\n}\n\nfunction jsonp(document, url, callback) {\n    return new Promise(function(resolve, reject) {\n        var s = document.createElement(\"script\");\n        var cleanup = function() {\n            delete window.html2canvas.proxy[callback];\n            document.body.removeChild(s);\n        };\n        window.html2canvas.proxy[callback] = function(response) {\n            cleanup();\n            resolve(response);\n        };\n        s.src = url;\n        s.onerror = function(e) {\n            cleanup();\n            reject(e);\n        };\n        document.body.appendChild(s);\n    });\n}\n\nfunction createCallback(useCORS) {\n    return !useCORS ? \"html2canvas_\" + Date.now() + \"_\" + (++proxyCount) + \"_\" + Math.round(Math.random() * 100000) : \"\";\n}\n\nfunction createProxyUrl(proxyUrl, src, callback) {\n    return proxyUrl + \"?url=\" + encodeURIComponent(src) + (callback.length ? \"&callback=html2canvas.proxy.\" + callback : \"\");\n}\n\nfunction documentFromHTML(src) {\n    return function(html) {\n        var parser = new DOMParser(), doc;\n        try {\n            doc = parser.parseFromString(html, \"text/html\");\n        } catch(e) {\n            log(\"DOMParser not supported, falling back to createHTMLDocument\");\n            doc = document.implementation.createHTMLDocument(\"\");\n            try {\n                doc.open();\n                doc.write(html);\n                doc.close();\n            } catch(ee) {\n                log(\"createHTMLDocument write not supported, falling back to document.body.innerHTML\");\n                doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement\n            }\n        }\n\n        var b = doc.querySelector(\"base\");\n        if (!b || !b.href.host) {\n            var base = doc.createElement(\"base\");\n            base.href = src;\n            doc.head.insertBefore(base, doc.head.firstChild);\n        }\n\n        return doc;\n    };\n}\n\nfunction loadUrlDocument(src, proxy, document, width, height, options) {\n    return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {\n        return createWindowClone(doc, document, width, height, options, 0, 0);\n    });\n}\n\nexports.Proxy = Proxy;\nexports.ProxyURL = ProxyURL;\nexports.loadUrlDocument = loadUrlDocument;\n\n},{\"./clone\":2,\"./log\":13,\"./utils\":26,\"./xhr\":28}],17:[function(_dereq_,module,exports){\nvar ProxyURL = _dereq_('./proxy').ProxyURL;\n\nfunction ProxyImageContainer(src, proxy) {\n    var link = document.createElement(\"a\");\n    link.href = src;\n    src = link.href;\n    this.src = src;\n    this.image = new Image();\n    var self = this;\n    this.promise = new Promise(function(resolve, reject) {\n        self.image.crossOrigin = \"Anonymous\";\n        self.image.onload = resolve;\n        self.image.onerror = reject;\n\n        new ProxyURL(src, proxy, document).then(function(url) {\n            self.image.src = url;\n        })['catch'](reject);\n    });\n}\n\nmodule.exports = ProxyImageContainer;\n\n},{\"./proxy\":16}],18:[function(_dereq_,module,exports){\nvar NodeContainer = _dereq_('./nodecontainer');\n\nfunction PseudoElementContainer(node, parent, type) {\n    NodeContainer.call(this, node, parent);\n    this.isPseudoElement = true;\n    this.before = type === \":before\";\n}\n\nPseudoElementContainer.prototype.cloneTo = function(stack) {\n    PseudoElementContainer.prototype.cloneTo.call(this, stack);\n    stack.isPseudoElement = true;\n    stack.before = this.before;\n};\n\nPseudoElementContainer.prototype = Object.create(NodeContainer.prototype);\n\nPseudoElementContainer.prototype.appendToDOM = function() {\n    if (this.before) {\n        this.parent.node.insertBefore(this.node, this.parent.node.firstChild);\n    } else {\n        this.parent.node.appendChild(this.node);\n    }\n    this.parent.node.className += \" \" + this.getHideClass();\n};\n\nPseudoElementContainer.prototype.cleanDOM = function() {\n    this.node.parentNode.removeChild(this.node);\n    this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), \"\");\n};\n\nPseudoElementContainer.prototype.getHideClass = function() {\n    return this[\"PSEUDO_HIDE_ELEMENT_CLASS_\" + (this.before ? \"BEFORE\" : \"AFTER\")];\n};\n\nPseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = \"___html2canvas___pseudoelement_before\";\nPseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = \"___html2canvas___pseudoelement_after\";\n\nmodule.exports = PseudoElementContainer;\n\n},{\"./nodecontainer\":14}],19:[function(_dereq_,module,exports){\nvar log = _dereq_('./log');\n\nfunction Renderer(width, height, images, options, document) {\n    this.width = width;\n    this.height = height;\n    this.images = images;\n    this.options = options;\n    this.document = document;\n}\n\nRenderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {\n    var paddingLeft = container.cssInt('paddingLeft'),\n        paddingTop = container.cssInt('paddingTop'),\n        paddingRight = container.cssInt('paddingRight'),\n        paddingBottom = container.cssInt('paddingBottom'),\n        borders = borderData.borders;\n\n    var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);\n    var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);\n    this.drawImage(\n        imageContainer,\n        0,\n        0,\n        imageContainer.image.width || width,\n        imageContainer.image.height || height,\n        bounds.left + paddingLeft + borders[3].width,\n        bounds.top + paddingTop + borders[0].width,\n        width,\n        height\n    );\n};\n\nRenderer.prototype.renderBackground = function(container, bounds, borderData) {\n    if (bounds.height > 0 && bounds.width > 0) {\n        this.renderBackgroundColor(container, bounds);\n        this.renderBackgroundImage(container, bounds, borderData);\n    }\n};\n\nRenderer.prototype.renderBackgroundColor = function(container, bounds) {\n    var color = container.color(\"backgroundColor\");\n    if (!color.isTransparent()) {\n        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);\n    }\n};\n\nRenderer.prototype.renderBorders = function(borders) {\n    borders.forEach(this.renderBorder, this);\n};\n\nRenderer.prototype.renderBorder = function(data) {\n    if (!data.color.isTransparent() && data.args !== null) {\n        this.drawShape(data.args, data.color);\n    }\n};\n\nRenderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {\n    var backgroundImages = container.parseBackgroundImages();\n    backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {\n        switch(backgroundImage.method) {\n        case \"url\":\n            var image = this.images.get(backgroundImage.args[0]);\n            if (image) {\n                this.renderBackgroundRepeating(container, bounds, image, arr.length - (index+1), borderData);\n            } else {\n                log(\"Error loading background-image\", backgroundImage.args[0]);\n            }\n            break;\n        case \"linear-gradient\":\n        case \"gradient\":\n            var gradientImage = this.images.get(backgroundImage.value);\n            if (gradientImage) {\n                this.renderBackgroundGradient(gradientImage, bounds, borderData);\n            } else {\n                log(\"Error loading background-image\", backgroundImage.args[0]);\n            }\n            break;\n        case \"none\":\n            break;\n        default:\n            log(\"Unknown background-image type\", backgroundImage.args[0]);\n        }\n    }, this);\n};\n\nRenderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {\n    var size = container.parseBackgroundSize(bounds, imageContainer.image, index);\n    var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);\n    var repeat = container.parseBackgroundRepeat(index);\n    switch (repeat) {\n    case \"repeat-x\":\n    case \"repeat no-repeat\":\n        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);\n        break;\n    case \"repeat-y\":\n    case \"no-repeat repeat\":\n        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);\n        break;\n    case \"no-repeat\":\n        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);\n        break;\n    default:\n        this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left}, borderData[3], borderData[0]);\n        break;\n    }\n};\n\nmodule.exports = Renderer;\n\n},{\"./log\":13}],20:[function(_dereq_,module,exports){\nvar Renderer = _dereq_('../renderer');\nvar LinearGradientContainer = _dereq_('../lineargradientcontainer');\nvar log = _dereq_('../log');\n\nfunction CanvasRenderer(width, height) {\n    Renderer.apply(this, arguments);\n    this.canvas = this.options.canvas || this.document.createElement(\"canvas\");\n    if (!this.options.canvas) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n    }\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.taintCtx = this.document.createElement(\"canvas\").getContext(\"2d\");\n    this.ctx.textBaseline = \"bottom\";\n    this.variables = {};\n    log(\"Initialized CanvasRenderer with size\", width, \"x\", height);\n}\n\nCanvasRenderer.prototype = Object.create(Renderer.prototype);\n\nCanvasRenderer.prototype.setFillStyle = function(fillStyle) {\n    this.ctx.fillStyle = typeof(fillStyle) === \"object\" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;\n    return this.ctx;\n};\n\nCanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {\n    this.setFillStyle(color).fillRect(left, top, width, height);\n};\n\nCanvasRenderer.prototype.circle = function(left, top, size, color) {\n    this.setFillStyle(color);\n    this.ctx.beginPath();\n    this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI*2, true);\n    this.ctx.closePath();\n    this.ctx.fill();\n};\n\nCanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {\n    this.circle(left, top, size, color);\n    this.ctx.strokeStyle = strokeColor.toString();\n    this.ctx.stroke();\n};\n\nCanvasRenderer.prototype.drawShape = function(shape, color) {\n    this.shape(shape);\n    this.setFillStyle(color).fill();\n};\n\nCanvasRenderer.prototype.taints = function(imageContainer) {\n    if (imageContainer.tainted === null) {\n        this.taintCtx.drawImage(imageContainer.image, 0, 0);\n        try {\n            this.taintCtx.getImageData(0, 0, 1, 1);\n            imageContainer.tainted = false;\n        } catch(e) {\n            this.taintCtx = document.createElement(\"canvas\").getContext(\"2d\");\n            imageContainer.tainted = true;\n        }\n    }\n\n    return imageContainer.tainted;\n};\n\nCanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {\n    if (!this.taints(imageContainer) || this.options.allowTaint) {\n        this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);\n    }\n};\n\nCanvasRenderer.prototype.clip = function(shapes, callback, context) {\n    this.ctx.save();\n    shapes.filter(hasEntries).forEach(function(shape) {\n        this.shape(shape).clip();\n    }, this);\n    callback.call(context);\n    this.ctx.restore();\n};\n\nCanvasRenderer.prototype.shape = function(shape) {\n    this.ctx.beginPath();\n    shape.forEach(function(point, index) {\n        if (point[0] === \"rect\") {\n            this.ctx.rect.apply(this.ctx, point.slice(1));\n        } else {\n            this.ctx[(index === 0) ? \"moveTo\" : point[0] + \"To\" ].apply(this.ctx, point.slice(1));\n        }\n    }, this);\n    this.ctx.closePath();\n    return this.ctx;\n};\n\nCanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {\n    this.setFillStyle(color).font = [style, variant, weight, size, family].join(\" \").split(\",\")[0];\n};\n\nCanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {\n    this.setVariable(\"shadowColor\", color.toString())\n        .setVariable(\"shadowOffsetY\", offsetX)\n        .setVariable(\"shadowOffsetX\", offsetY)\n        .setVariable(\"shadowBlur\", blur);\n};\n\nCanvasRenderer.prototype.clearShadow = function() {\n    this.setVariable(\"shadowColor\", \"rgba(0,0,0,0)\");\n};\n\nCanvasRenderer.prototype.setOpacity = function(opacity) {\n    this.ctx.globalAlpha = opacity;\n};\n\nCanvasRenderer.prototype.setTransform = function(transform) {\n    this.ctx.translate(transform.origin[0], transform.origin[1]);\n    this.ctx.transform.apply(this.ctx, transform.matrix);\n    this.ctx.translate(-transform.origin[0], -transform.origin[1]);\n};\n\nCanvasRenderer.prototype.setVariable = function(property, value) {\n    if (this.variables[property] !== value) {\n        this.variables[property] = this.ctx[property] = value;\n    }\n\n    return this;\n};\n\nCanvasRenderer.prototype.text = function(text, left, bottom) {\n    this.ctx.fillText(text, left, bottom);\n};\n\nCanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {\n    var shape = [\n        [\"line\", Math.round(left), Math.round(top)],\n        [\"line\", Math.round(left + width), Math.round(top)],\n        [\"line\", Math.round(left + width), Math.round(height + top)],\n        [\"line\", Math.round(left), Math.round(height + top)]\n    ];\n    this.clip([shape], function() {\n        this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);\n    }, this);\n};\n\nCanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {\n    var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);\n    this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), \"repeat\"));\n    this.ctx.translate(offsetX, offsetY);\n    this.ctx.fill();\n    this.ctx.translate(-offsetX, -offsetY);\n};\n\nCanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {\n    if (gradientImage instanceof LinearGradientContainer) {\n        var gradient = this.ctx.createLinearGradient(\n            bounds.left + bounds.width * gradientImage.x0,\n            bounds.top + bounds.height * gradientImage.y0,\n            bounds.left +  bounds.width * gradientImage.x1,\n            bounds.top +  bounds.height * gradientImage.y1);\n        gradientImage.colorStops.forEach(function(colorStop) {\n            gradient.addColorStop(colorStop.stop, colorStop.color.toString());\n        });\n        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);\n    }\n};\n\nCanvasRenderer.prototype.resizeImage = function(imageContainer, size) {\n    var image = imageContainer.image;\n    if(image.width === size.width && image.height === size.height) {\n        return image;\n    }\n\n    var ctx, canvas = document.createElement('canvas');\n    canvas.width = size.width;\n    canvas.height = size.height;\n    ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height );\n    return canvas;\n};\n\nfunction hasEntries(array) {\n    return array.length > 0;\n}\n\nmodule.exports = CanvasRenderer;\n\n},{\"../lineargradientcontainer\":12,\"../log\":13,\"../renderer\":19}],21:[function(_dereq_,module,exports){\nvar NodeContainer = _dereq_('./nodecontainer');\n\nfunction StackingContext(hasOwnStacking, opacity, element, parent) {\n    NodeContainer.call(this, element, parent);\n    this.ownStacking = hasOwnStacking;\n    this.contexts = [];\n    this.children = [];\n    this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;\n}\n\nStackingContext.prototype = Object.create(NodeContainer.prototype);\n\nStackingContext.prototype.getParentStack = function(context) {\n    var parentStack = (this.parent) ? this.parent.stack : null;\n    return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;\n};\n\nmodule.exports = StackingContext;\n\n},{\"./nodecontainer\":14}],22:[function(_dereq_,module,exports){\nfunction Support(document) {\n    this.rangeBounds = this.testRangeBounds(document);\n    this.cors = this.testCORS();\n    this.svg = this.testSVG();\n}\n\nSupport.prototype.testRangeBounds = function(document) {\n    var range, testElement, rangeBounds, rangeHeight, support = false;\n\n    if (document.createRange) {\n        range = document.createRange();\n        if (range.getBoundingClientRect) {\n            testElement = document.createElement('boundtest');\n            testElement.style.height = \"123px\";\n            testElement.style.display = \"block\";\n            document.body.appendChild(testElement);\n\n            range.selectNode(testElement);\n            rangeBounds = range.getBoundingClientRect();\n            rangeHeight = rangeBounds.height;\n\n            if (rangeHeight === 123) {\n                support = true;\n            }\n            document.body.removeChild(testElement);\n        }\n    }\n\n    return support;\n};\n\nSupport.prototype.testCORS = function() {\n    return typeof((new Image()).crossOrigin) !== \"undefined\";\n};\n\nSupport.prototype.testSVG = function() {\n    var img = new Image();\n    var canvas = document.createElement(\"canvas\");\n    var ctx =  canvas.getContext(\"2d\");\n    img.src = \"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>\";\n\n    try {\n        ctx.drawImage(img, 0, 0);\n        canvas.toDataURL();\n    } catch(e) {\n        return false;\n    }\n    return true;\n};\n\nmodule.exports = Support;\n\n},{}],23:[function(_dereq_,module,exports){\nvar XHR = _dereq_('./xhr');\nvar decode64 = _dereq_('./utils').decode64;\n\nfunction SVGContainer(src) {\n    this.src = src;\n    this.image = null;\n    var self = this;\n\n    this.promise = this.hasFabric().then(function() {\n        return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));\n    }).then(function(svg) {\n        return new Promise(function(resolve) {\n            window.html2canvas.svg.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));\n        });\n    });\n}\n\nSVGContainer.prototype.hasFabric = function() {\n    return !window.html2canvas.svg || !window.html2canvas.svg.fabric ? Promise.reject(new Error(\"html2canvas.svg.js is not loaded, cannot render svg\")) : Promise.resolve();\n};\n\nSVGContainer.prototype.inlineFormatting = function(src) {\n    return (/^data:image\\/svg\\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);\n};\n\nSVGContainer.prototype.removeContentType = function(src) {\n    return src.replace(/^data:image\\/svg\\+xml(;base64)?,/,'');\n};\n\nSVGContainer.prototype.isInline = function(src) {\n    return (/^data:image\\/svg\\+xml/i.test(src));\n};\n\nSVGContainer.prototype.createCanvas = function(resolve) {\n    var self = this;\n    return function (objects, options) {\n        var canvas = new window.html2canvas.svg.fabric.StaticCanvas('c');\n        self.image = canvas.lowerCanvasEl;\n        canvas\n            .setWidth(options.width)\n            .setHeight(options.height)\n            .add(window.html2canvas.svg.fabric.util.groupSVGElements(objects, options))\n            .renderAll();\n        resolve(canvas.lowerCanvasEl);\n    };\n};\n\nSVGContainer.prototype.decode64 = function(str) {\n    return (typeof(window.atob) === \"function\") ? window.atob(str) : decode64(str);\n};\n\nmodule.exports = SVGContainer;\n\n},{\"./utils\":26,\"./xhr\":28}],24:[function(_dereq_,module,exports){\nvar SVGContainer = _dereq_('./svgcontainer');\n\nfunction SVGNodeContainer(node, _native) {\n    this.src = node;\n    this.image = null;\n    var self = this;\n\n    this.promise = _native ? new Promise(function(resolve, reject) {\n        self.image = new Image();\n        self.image.onload = resolve;\n        self.image.onerror = reject;\n        self.image.src = \"data:image/svg+xml,\" + (new XMLSerializer()).serializeToString(node);\n        if (self.image.complete === true) {\n            resolve(self.image);\n        }\n    }) : this.hasFabric().then(function() {\n        return new Promise(function(resolve) {\n            window.html2canvas.svg.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));\n        });\n    });\n}\n\nSVGNodeContainer.prototype = Object.create(SVGContainer.prototype);\n\nmodule.exports = SVGNodeContainer;\n\n},{\"./svgcontainer\":23}],25:[function(_dereq_,module,exports){\nvar NodeContainer = _dereq_('./nodecontainer');\n\nfunction TextContainer(node, parent) {\n    NodeContainer.call(this, node, parent);\n}\n\nTextContainer.prototype = Object.create(NodeContainer.prototype);\n\nTextContainer.prototype.applyTextTransform = function() {\n    this.node.data = this.transform(this.parent.css(\"textTransform\"));\n};\n\nTextContainer.prototype.transform = function(transform) {\n    var text = this.node.data;\n    switch(transform){\n        case \"lowercase\":\n            return text.toLowerCase();\n        case \"capitalize\":\n            return text.replace(/(^|\\s|:|-|\\(|\\))([a-z])/g, capitalize);\n        case \"uppercase\":\n            return text.toUpperCase();\n        default:\n            return text;\n    }\n};\n\nfunction capitalize(m, p1, p2) {\n    if (m.length > 0) {\n        return p1 + p2.toUpperCase();\n    }\n}\n\nmodule.exports = TextContainer;\n\n},{\"./nodecontainer\":14}],26:[function(_dereq_,module,exports){\nexports.smallImage = function smallImage() {\n    return \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n};\n\nexports.bind = function(callback, context) {\n    return function() {\n        return callback.apply(context, arguments);\n    };\n};\n\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nexports.decode64 = function(base64) {\n    var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;\n\n    var output = \"\";\n\n    for (i = 0; i < len; i+=4) {\n        encoded1 = chars.indexOf(base64[i]);\n        encoded2 = chars.indexOf(base64[i+1]);\n        encoded3 = chars.indexOf(base64[i+2]);\n        encoded4 = chars.indexOf(base64[i+3]);\n\n        byte1 = (encoded1 << 2) | (encoded2 >> 4);\n        byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        byte3 = ((encoded3 & 3) << 6) | encoded4;\n        if (encoded3 === 64) {\n            output += String.fromCharCode(byte1);\n        } else if (encoded4 === 64 || encoded4 === -1) {\n            output += String.fromCharCode(byte1, byte2);\n        } else{\n            output += String.fromCharCode(byte1, byte2, byte3);\n        }\n    }\n\n    return output;\n};\n\nexports.getBounds = function(node) {\n    if (node.getBoundingClientRect) {\n        var clientRect = node.getBoundingClientRect();\n        var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;\n        return {\n            top: clientRect.top,\n            bottom: clientRect.bottom || (clientRect.top + clientRect.height),\n            right: clientRect.left + width,\n            left: clientRect.left,\n            width:  width,\n            height: node.offsetHeight == null ? clientRect.height : node.offsetHeight\n        };\n    }\n    return {};\n};\n\nexports.offsetBounds = function(node) {\n    var parent = node.offsetParent ? exports.offsetBounds(node.offsetParent) : {top: 0, left: 0};\n\n    return {\n        top: node.offsetTop + parent.top,\n        bottom: node.offsetTop + node.offsetHeight + parent.top,\n        right: node.offsetLeft + parent.left + node.offsetWidth,\n        left: node.offsetLeft + parent.left,\n        width: node.offsetWidth,\n        height: node.offsetHeight\n    };\n};\n\nexports.parseBackgrounds = function(backgroundImage) {\n    var whitespace = ' \\r\\n\\t',\n        method, definition, prefix, prefix_i, block, results = [],\n        mode = 0, numParen = 0, quote, args;\n    var appendResult = function() {\n        if(method) {\n            if (definition.substr(0, 1) === '\"') {\n                definition = definition.substr(1, definition.length - 2);\n            }\n            if (definition) {\n                args.push(definition);\n            }\n            if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1 ) + 1) > 0) {\n                prefix = method.substr(0, prefix_i);\n                method = method.substr(prefix_i);\n            }\n            results.push({\n                prefix: prefix,\n                method: method.toLowerCase(),\n                value: block,\n                args: args,\n                image: null\n            });\n        }\n        args = [];\n        method = prefix = definition = block = '';\n    };\n    args = [];\n    method = prefix = definition = block = '';\n    backgroundImage.split(\"\").forEach(function(c) {\n        if (mode === 0 && whitespace.indexOf(c) > -1) {\n            return;\n        }\n        switch(c) {\n        case '\"':\n            if(!quote) {\n                quote = c;\n            } else if(quote === c) {\n                quote = null;\n            }\n            break;\n        case '(':\n            if(quote) {\n                break;\n            } else if(mode === 0) {\n                mode = 1;\n                block += c;\n                return;\n            } else {\n                numParen++;\n            }\n            break;\n        case ')':\n            if (quote) {\n                break;\n            } else if(mode === 1) {\n                if(numParen === 0) {\n                    mode = 0;\n                    block += c;\n                    appendResult();\n                    return;\n                } else {\n                    numParen--;\n                }\n            }\n            break;\n\n        case ',':\n            if (quote) {\n                break;\n            } else if(mode === 0) {\n                appendResult();\n                return;\n            } else if (mode === 1) {\n                if (numParen === 0 && !method.match(/^url$/i)) {\n                    args.push(definition);\n                    definition = '';\n                    block += c;\n                    return;\n                }\n            }\n            break;\n        }\n\n        block += c;\n        if (mode === 0) {\n            method += c;\n        } else {\n            definition += c;\n        }\n    });\n\n    appendResult();\n    return results;\n};\n\n},{}],27:[function(_dereq_,module,exports){\nvar GradientContainer = _dereq_('./gradientcontainer');\n\nfunction WebkitGradientContainer(imageData) {\n    GradientContainer.apply(this, arguments);\n    this.type = imageData.args[0] === \"linear\" ? GradientContainer.TYPES.LINEAR : GradientContainer.TYPES.RADIAL;\n}\n\nWebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);\n\nmodule.exports = WebkitGradientContainer;\n\n},{\"./gradientcontainer\":9}],28:[function(_dereq_,module,exports){\nfunction XHR(url) {\n    return new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url);\n\n        xhr.onload = function() {\n            if (xhr.status === 200) {\n                resolve(xhr.responseText);\n            } else {\n                reject(new Error(xhr.statusText));\n            }\n        };\n\n        xhr.onerror = function() {\n            reject(new Error(\"Network Error\"));\n        };\n\n        xhr.send();\n    });\n}\n\nmodule.exports = XHR;\n\n},{}]},{},[4])(4)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vaHRtbDJjYW52YXMvZGlzdC9odG1sMmNhbnZhcy5qcz81YTVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIGh0bWwyY2FudmFzIDAuNS4wLWJldGE0IDxodHRwOi8vaHRtbDJjYW52YXMuaGVydHplbi5jb20+XG4gIENvcHlyaWdodCAoYykgMjAxNiBOaWtsYXMgdm9uIEhlcnR6ZW5cblxuICBSZWxlYXNlZCB1bmRlciAgTGljZW5zZVxuKi9cblxuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuaHRtbDJjYW52YXMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGxvZyA9IF9kZXJlcV8oJy4vbG9nJyk7XG5cbmZ1bmN0aW9uIHJlc3RvcmVPd25lclNjcm9sbChvd25lckRvY3VtZW50LCB4LCB5KSB7XG4gICAgaWYgKG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgKHggIT09IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcucGFnZVhPZmZzZXQgfHwgeSAhPT0gb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldCkpIHtcbiAgICAgICAgb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5zY3JvbGxUbyh4LCB5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ2FudmFzQ29udGVudHMoY2FudmFzLCBjbG9uZWRDYW52YXMpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY2xvbmVkQ2FudmFzKSB7XG4gICAgICAgICAgICBjbG9uZWRDYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjbG9uZWRDYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIGNsb25lZENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCksIDAsIDApO1xuICAgICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxvZyhcIlVuYWJsZSB0byBjb3B5IGNhbnZhcyBjb250ZW50IGZyb21cIiwgY2FudmFzLCBlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlLCBqYXZhc2NyaXB0RW5hYmxlZCkge1xuICAgIHZhciBjbG9uZSA9IG5vZGUubm9kZVR5cGUgPT09IDMgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLm5vZGVWYWx1ZSkgOiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG5cbiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUoY2hpbGQpIHtcbiAgICAgICAgaWYgKGphdmFzY3JpcHRFbmFibGVkID09PSB0cnVlIHx8IGNoaWxkLm5vZGVUeXBlICE9PSAxIHx8IGNoaWxkLm5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY2xvbmUuYXBwZW5kQ2hpbGQoY2xvbmVOb2RlKGNoaWxkLCBqYXZhc2NyaXB0RW5hYmxlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY2xvbmUuX3Njcm9sbFRvcCA9IG5vZGUuc2Nyb2xsVG9wO1xuICAgICAgICBjbG9uZS5fc2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgICAgIGNsb25lQ2FudmFzQ29udGVudHMobm9kZSwgY2xvbmUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIiB8fCBub2RlLm5vZGVOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gICAgICAgICAgICBjbG9uZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIGluaXROb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBub2RlLnNjcm9sbFRvcCA9IG5vZGUuX3Njcm9sbFRvcDtcbiAgICAgICAgbm9kZS5zY3JvbGxMZWZ0ID0gbm9kZS5fc2Nyb2xsTGVmdDtcblxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlKGNoaWxkKSB7XG4gICAgICAgICAgICBpbml0Tm9kZShjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG93bmVyRG9jdW1lbnQsIGNvbnRhaW5lckRvY3VtZW50LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLCB4ICx5KSB7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGNsb25lTm9kZShvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgb3B0aW9ucy5qYXZhc2NyaXB0RW5hYmxlZCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG5cbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJodG1sMmNhbnZhcy1jb250YWluZXJcIjtcbiAgICBjb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCItMTAwMDBweFwiO1xuICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSBcIjBcIjtcbiAgICBjb250YWluZXIud2lkdGggPSB3aWR0aDtcbiAgICBjb250YWluZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnRhaW5lci5zY3JvbGxpbmcgPSBcIm5vXCI7IC8vIGlvcyB3b24ndCBzY3JvbGwgd2l0aG91dCBpdFxuICAgIGNvbnRhaW5lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHZhciBkb2N1bWVudENsb25lID0gY29udGFpbmVyLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgLyogQ2hyb21lIGRvZXNuJ3QgZGV0ZWN0IHJlbGF0aXZlIGJhY2tncm91bmQtaW1hZ2VzIGFzc2lnbmVkIGluIGlubGluZSA8c3R5bGU+IHNoZWV0cyB3aGVuIGZldGNoZWQgdGhyb3VnaCBnZXRDb21wdXRlZFN0eWxlXG4gICAgICAgICBpZiB3aW5kb3cgdXJsIGlzIGFib3V0OmJsYW5rLCB3ZSBjYW4gYXNzaWduIHRoZSB1cmwgdG8gY3VycmVudCBieSB3cml0aW5nIG9udG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXIuY29udGVudFdpbmRvdy5vbmxvYWQgPSBjb250YWluZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnRDbG9uZS5ib2R5LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0Tm9kZShkb2N1bWVudENsb25lLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSBcInZpZXdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNvbnRlbnRXaW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKC8oaVBhZHxpUGhvbmV8aVBvZCkvZykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAoY29udGFpbmVyLmNvbnRlbnRXaW5kb3cuc2Nyb2xsWSAhPT0geSB8fCBjb250YWluZXIuY29udGVudFdpbmRvdy5zY3JvbGxYICE9PSB4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Q2xvbmUuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRvcCA9ICgteSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDbG9uZS5kb2N1bWVudEVsZW1lbnQuc3R5bGUubGVmdCA9ICgteCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDbG9uZS5kb2N1bWVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnRDbG9uZS5vcGVuKCk7XG4gICAgICAgIGRvY3VtZW50Q2xvbmUud3JpdGUoXCI8IURPQ1RZUEUgaHRtbD48aHRtbD48L2h0bWw+XCIpO1xuICAgICAgICAvLyBDaHJvbWUgc2Nyb2xscyB0aGUgcGFyZW50IGRvY3VtZW50IGZvciBzb21lIHJlYXNvbiBhZnRlciB0aGUgd3JpdGUgdG8gdGhlIGNsb25lZCB3aW5kb3c/Pz9cbiAgICAgICAgcmVzdG9yZU93bmVyU2Nyb2xsKG93bmVyRG9jdW1lbnQsIHgsIHkpO1xuICAgICAgICBkb2N1bWVudENsb25lLnJlcGxhY2VDaGlsZChkb2N1bWVudENsb25lLmFkb3B0Tm9kZShkb2N1bWVudEVsZW1lbnQpLCBkb2N1bWVudENsb25lLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgIGRvY3VtZW50Q2xvbmUuY2xvc2UoKTtcbiAgICB9KTtcbn07XG5cbn0se1wiLi9sb2dcIjoxM31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yL1xuXG5mdW5jdGlvbiBDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuciA9IDA7XG4gICAgdGhpcy5nID0gMDtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuYSA9IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZnJvbUFycmF5KHZhbHVlKSB8fFxuICAgICAgICB0aGlzLm5hbWVkQ29sb3IodmFsdWUpIHx8XG4gICAgICAgIHRoaXMucmdiKHZhbHVlKSB8fFxuICAgICAgICB0aGlzLnJnYmEodmFsdWUpIHx8XG4gICAgICAgIHRoaXMuaGV4Nih2YWx1ZSkgfHxcbiAgICAgICAgdGhpcy5oZXgzKHZhbHVlKTtcbn1cblxuQ29sb3IucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHZhciBhID0gMSAtIGFtb3VudDtcbiAgICByZXR1cm4gIG5ldyBDb2xvcihbXG4gICAgICAgIE1hdGgucm91bmQodGhpcy5yICogYSksXG4gICAgICAgIE1hdGgucm91bmQodGhpcy5nICogYSksXG4gICAgICAgIE1hdGgucm91bmQodGhpcy5iICogYSksXG4gICAgICAgIHRoaXMuYVxuICAgIF0pO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmlzVHJhbnNwYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hID09PSAwO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmlzQmxhY2sgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yID09PSAwICYmIHRoaXMuZyA9PT0gMCAmJiB0aGlzLmIgPT09IDA7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oYXJyYXlbMF0sIDI1NSk7XG4gICAgICAgIHRoaXMuZyA9IE1hdGgubWluKGFycmF5WzFdLCAyNTUpO1xuICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbihhcnJheVsyXSwgMjU1KTtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHRoaXMuYSA9IGFycmF5WzNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFycmF5KSk7XG59O1xuXG52YXIgX2hleDMgPSAvXiMoW2EtZjAtOV17M30pJC9pO1xuXG5Db2xvci5wcm90b3R5cGUuaGV4MyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICBpZiAoKG1hdGNoID0gdmFsdWUubWF0Y2goX2hleDMpKSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXVswXSArIG1hdGNoWzFdWzBdLCAxNik7XG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzFdWzFdICsgbWF0Y2hbMV1bMV0sIDE2KTtcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbMV1bMl0gKyBtYXRjaFsxXVsyXSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2ggIT09IG51bGw7XG59O1xuXG52YXIgX2hleDYgPSAvXiMoW2EtZjAtOV17Nn0pJC9pO1xuXG5Db2xvci5wcm90b3R5cGUuaGV4NiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICBpZiAoKG1hdGNoID0gdmFsdWUubWF0Y2goX2hleDYpKSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXS5zdWJzdHJpbmcoMCwgMiksIDE2KTtcbiAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMV0uc3Vic3RyaW5nKDIsIDQpLCAxNik7XG4gICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KG1hdGNoWzFdLnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2ggIT09IG51bGw7XG59O1xuXG5cbnZhciBfcmdiID0gL15yZ2JcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKlxcKSQvO1xuXG5Db2xvci5wcm90b3R5cGUucmdiID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgIGlmICgobWF0Y2ggPSB2YWx1ZS5tYXRjaChfcmdiKSkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yID0gTnVtYmVyKG1hdGNoWzFdKTtcbiAgICAgICAgdGhpcy5nID0gTnVtYmVyKG1hdGNoWzJdKTtcbiAgICAgICAgdGhpcy5iID0gTnVtYmVyKG1hdGNoWzNdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoICE9PSBudWxsO1xufTtcblxudmFyIF9yZ2JhID0gL15yZ2JhXFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGQ/XFwuP1xcZCspXFxzKlxcKSQvO1xuXG5Db2xvci5wcm90b3R5cGUucmdiYSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICBpZiAoKG1hdGNoID0gdmFsdWUubWF0Y2goX3JnYmEpKSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnIgPSBOdW1iZXIobWF0Y2hbMV0pO1xuICAgICAgICB0aGlzLmcgPSBOdW1iZXIobWF0Y2hbMl0pO1xuICAgICAgICB0aGlzLmIgPSBOdW1iZXIobWF0Y2hbM10pO1xuICAgICAgICB0aGlzLmEgPSBOdW1iZXIobWF0Y2hbNF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2ggIT09IG51bGw7XG59O1xuXG5Db2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hICE9PSBudWxsICYmIHRoaXMuYSAhPT0gMSA/XG4gICAgXCJyZ2JhKFwiICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV0uam9pbihcIixcIikgKyBcIilcIiA6XG4gICAgXCJyZ2IoXCIgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYl0uam9pbihcIixcIikgKyBcIilcIjtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5uYW1lZENvbG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNvbG9yID0gY29sb3JzW3ZhbHVlXTtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgdGhpcy5yID0gY29sb3JbMF07XG4gICAgICAgIHRoaXMuZyA9IGNvbG9yWzFdO1xuICAgICAgICB0aGlzLmIgPSBjb2xvclsyXTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gMDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhY29sb3I7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuaXNDb2xvciA9IHRydWU7XG5cbi8vIEpTT04uc3RyaW5naWZ5KFtdLnNsaWNlLmNhbGwoJCQoJy5uYW1lZC1jb2xvci10YWJsZSB0cicpLCAxKS5tYXAoZnVuY3Rpb24ocm93KSB7IHJldHVybiBbcm93LmNoaWxkTm9kZXNbM10udGV4dENvbnRlbnQsIHJvdy5jaGlsZE5vZGVzWzVdLnRleHRDb250ZW50LnRyaW0oKS5zcGxpdChcIixcIikubWFwKE51bWJlcildIH0pLnJlZHVjZShmdW5jdGlvbihkYXRhLCByb3cpIHtkYXRhW3Jvd1swXV0gPSByb3dbMV07IHJldHVybiBkYXRhfSwge30pKVxudmFyIGNvbG9ycyA9IHtcbiAgICBcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxuICAgIFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgXCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgXCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgXCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxuICAgIFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxuICAgIFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcbiAgICBcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXG4gICAgXCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxuICAgIFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcbiAgICBcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcbiAgICBcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxuICAgIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxuICAgIFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxuICAgIFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXG4gICAgXCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxuICAgIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcbiAgICBcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcbiAgICBcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXG4gICAgXCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxuICAgIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcbiAgICBcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcbiAgICBcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXG4gICAgXCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxuICAgIFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxuICAgIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXG4gICAgXCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcbiAgICBcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcbiAgICBcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcbiAgICBcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxuICAgIFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcbiAgICBcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxuICAgIFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgXCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxuICAgIFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXG4gICAgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXG4gICAgXCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxuICAgIFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxuICAgIFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcbiAgICBcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxuICAgIFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxuICAgIFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxuICAgIFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJncmVlblwiOiBbMCwgMTI4LCAwXSxcbiAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxuICAgIFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgXCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICBcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxuICAgIFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcbiAgICBcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICBcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICBcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxuICAgIFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXG4gICAgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICBcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxuICAgIFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICBcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgXCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgXCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxuICAgIFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcbiAgICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgXCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgXCJsaW1lXCI6IFswLCAyNTUsIDBdLFxuICAgIFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXG4gICAgXCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgXCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgXCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXG4gICAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXG4gICAgXCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXG4gICAgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxuICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXG4gICAgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxuICAgIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcbiAgICBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcbiAgICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcbiAgICBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxuICAgIFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcbiAgICBcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgXCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgXCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgXCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxuICAgIFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgXCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxuICAgIFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxuICAgIFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXG4gICAgXCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxuICAgIFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcbiAgICBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxuICAgIFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcbiAgICBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxuICAgIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgXCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICBcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgXCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxuICAgIFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgXCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcbiAgICBcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxuICAgIFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXG4gICAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxuICAgIFwicmVkXCI6IFsyNTUsIDAsIDBdLFxuICAgIFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcbiAgICBcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXG4gICAgXCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxuICAgIFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXG4gICAgXCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgXCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcbiAgICBcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgXCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICBcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgXCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxuICAgIFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgXCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxuICAgIFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxuICAgIFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcbiAgICBcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcbiAgICBcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxuICAgIFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXG4gICAgXCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXG4gICAgXCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxuICAgIFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxuICAgIFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxuICAgIFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgXCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcbiAgICBcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuXG59LHt9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTdXBwb3J0ID0gX2RlcmVxXygnLi9zdXBwb3J0Jyk7XG52YXIgQ2FudmFzUmVuZGVyZXIgPSBfZGVyZXFfKCcuL3JlbmRlcmVycy9jYW52YXMnKTtcbnZhciBJbWFnZUxvYWRlciA9IF9kZXJlcV8oJy4vaW1hZ2Vsb2FkZXInKTtcbnZhciBOb2RlUGFyc2VyID0gX2RlcmVxXygnLi9ub2RlcGFyc2VyJyk7XG52YXIgTm9kZUNvbnRhaW5lciA9IF9kZXJlcV8oJy4vbm9kZWNvbnRhaW5lcicpO1xudmFyIGxvZyA9IF9kZXJlcV8oJy4vbG9nJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWxzJyk7XG52YXIgY3JlYXRlV2luZG93Q2xvbmUgPSBfZGVyZXFfKCcuL2Nsb25lJyk7XG52YXIgbG9hZFVybERvY3VtZW50ID0gX2RlcmVxXygnLi9wcm94eScpLmxvYWRVcmxEb2N1bWVudDtcbnZhciBnZXRCb3VuZHMgPSB1dGlscy5nZXRCb3VuZHM7XG5cbnZhciBodG1sMmNhbnZhc05vZGVBdHRyaWJ1dGUgPSBcImRhdGEtaHRtbDJjYW52YXMtbm9kZVwiO1xudmFyIGh0bWwyY2FudmFzQ2xvbmVJbmRleCA9IDA7XG5cbmZ1bmN0aW9uIGh0bWwyY2FudmFzKG5vZGVMaXN0LCBvcHRpb25zKSB7XG4gICAgdmFyIGluZGV4ID0gaHRtbDJjYW52YXNDbG9uZUluZGV4Kys7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMubG9nZ2luZykge1xuICAgICAgICBsb2cub3B0aW9ucy5sb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgbG9nLm9wdGlvbnMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYXN5bmMgPSB0eXBlb2Yob3B0aW9ucy5hc3luYykgPT09IFwidW5kZWZpbmVkXCIgPyB0cnVlIDogb3B0aW9ucy5hc3luYztcbiAgICBvcHRpb25zLmFsbG93VGFpbnQgPSB0eXBlb2Yob3B0aW9ucy5hbGxvd1RhaW50KSA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogb3B0aW9ucy5hbGxvd1RhaW50O1xuICAgIG9wdGlvbnMucmVtb3ZlQ29udGFpbmVyID0gdHlwZW9mKG9wdGlvbnMucmVtb3ZlQ29udGFpbmVyKSA9PT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBvcHRpb25zLnJlbW92ZUNvbnRhaW5lcjtcbiAgICBvcHRpb25zLmphdmFzY3JpcHRFbmFibGVkID0gdHlwZW9mKG9wdGlvbnMuamF2YXNjcmlwdEVuYWJsZWQpID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBvcHRpb25zLmphdmFzY3JpcHRFbmFibGVkO1xuICAgIG9wdGlvbnMuaW1hZ2VUaW1lb3V0ID0gdHlwZW9mKG9wdGlvbnMuaW1hZ2VUaW1lb3V0KSA9PT0gXCJ1bmRlZmluZWRcIiA/IDEwMDAwIDogb3B0aW9ucy5pbWFnZVRpbWVvdXQ7XG4gICAgb3B0aW9ucy5yZW5kZXJlciA9IHR5cGVvZihvcHRpb25zLnJlbmRlcmVyKSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZW5kZXJlciA6IENhbnZhc1JlbmRlcmVyO1xuICAgIG9wdGlvbnMuc3RyaWN0ID0gISFvcHRpb25zLnN0cmljdDtcblxuICAgIGlmICh0eXBlb2Yobm9kZUxpc3QpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2Yob3B0aW9ucy5wcm94eSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlByb3h5IG11c3QgYmUgdXNlZCB3aGVuIHJlbmRlcmluZyB1cmxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCAhPSBudWxsID8gb3B0aW9ucy53aWR0aCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgIT0gbnVsbCA/IG9wdGlvbnMuaGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICByZXR1cm4gbG9hZFVybERvY3VtZW50KGFic29sdXRlVXJsKG5vZGVMaXN0KSwgb3B0aW9ucy5wcm94eSwgZG9jdW1lbnQsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyV2luZG93KGNvbnRhaW5lci5jb250ZW50V2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgY29udGFpbmVyLCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSAoKG5vZGVMaXN0ID09PSB1bmRlZmluZWQpID8gW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0gOiAoKG5vZGVMaXN0Lmxlbmd0aCkgPyBub2RlTGlzdCA6IFtub2RlTGlzdF0pKVswXTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShodG1sMmNhbnZhc05vZGVBdHRyaWJ1dGUgKyBpbmRleCwgaW5kZXgpO1xuICAgIHJldHVybiByZW5kZXJEb2N1bWVudChub2RlLm93bmVyRG9jdW1lbnQsIG9wdGlvbnMsIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5pbm5lcldpZHRoLCBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuaW5uZXJIZWlnaHQsIGluZGV4KS50aGVuKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMub25yZW5kZXJlZCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9nKFwib3B0aW9ucy5vbnJlbmRlcmVkIGlzIGRlcHJlY2F0ZWQsIGh0bWwyY2FudmFzIHJldHVybnMgYSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGNhbnZhc1wiKTtcbiAgICAgICAgICAgIG9wdGlvbnMub25yZW5kZXJlZChjYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSk7XG59XG5cbmh0bWwyY2FudmFzLkNhbnZhc1JlbmRlcmVyID0gQ2FudmFzUmVuZGVyZXI7XG5odG1sMmNhbnZhcy5Ob2RlQ29udGFpbmVyID0gTm9kZUNvbnRhaW5lcjtcbmh0bWwyY2FudmFzLmxvZyA9IGxvZztcbmh0bWwyY2FudmFzLnV0aWxzID0gdXRpbHM7XG5cbnZhciBodG1sMmNhbnZhc0V4cG9ydCA9ICh0eXBlb2YoZG9jdW1lbnQpID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZihPYmplY3QuY3JlYXRlKSAhPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZihkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQpICE9PSBcImZ1bmN0aW9uXCIpID8gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiTm8gY2FudmFzIHN1cHBvcnRcIik7XG59IDogaHRtbDJjYW52YXM7XG5cbm1vZHVsZS5leHBvcnRzID0gaHRtbDJjYW52YXNFeHBvcnQ7XG5cbmlmICh0eXBlb2YoZGVmaW5lKSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdodG1sMmNhbnZhcycsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGh0bWwyY2FudmFzRXhwb3J0O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJEb2N1bWVudChkb2N1bWVudCwgb3B0aW9ucywgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCwgaHRtbDJjYW52YXNJbmRleCkge1xuICAgIHJldHVybiBjcmVhdGVXaW5kb3dDbG9uZShkb2N1bWVudCwgZG9jdW1lbnQsIHdpbmRvd1dpZHRoLCB3aW5kb3dIZWlnaHQsIG9wdGlvbnMsIGRvY3VtZW50LmRlZmF1bHRWaWV3LnBhZ2VYT2Zmc2V0LCBkb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldCkudGhlbihmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgbG9nKFwiRG9jdW1lbnQgY2xvbmVkXCIpO1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGh0bWwyY2FudmFzTm9kZUF0dHJpYnV0ZSArIGh0bWwyY2FudmFzSW5kZXg7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IFwiW1wiICsgYXR0cmlidXRlTmFtZSArIFwiPSdcIiArIGh0bWwyY2FudmFzSW5kZXggKyBcIiddXCI7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgdmFyIGNsb25lZFdpbmRvdyA9IGNvbnRhaW5lci5jb250ZW50V2luZG93O1xuICAgICAgICB2YXIgbm9kZSA9IGNsb25lZFdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgdmFyIG9uY2xvbmVIYW5kbGVyID0gKHR5cGVvZihvcHRpb25zLm9uY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpID8gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMub25jbG9uZShjbG9uZWRXaW5kb3cuZG9jdW1lbnQpKSA6IFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIG9uY2xvbmVIYW5kbGVyLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyV2luZG93KG5vZGUsIGNvbnRhaW5lciwgb3B0aW9ucywgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaW5kb3cobm9kZSwgY29udGFpbmVyLCBvcHRpb25zLCB3aW5kb3dXaWR0aCwgd2luZG93SGVpZ2h0KSB7XG4gICAgdmFyIGNsb25lZFdpbmRvdyA9IGNvbnRhaW5lci5jb250ZW50V2luZG93O1xuICAgIHZhciBzdXBwb3J0ID0gbmV3IFN1cHBvcnQoY2xvbmVkV2luZG93LmRvY3VtZW50KTtcbiAgICB2YXIgaW1hZ2VMb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIob3B0aW9ucywgc3VwcG9ydCk7XG4gICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyhub2RlKTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLnR5cGUgPT09IFwidmlld1wiID8gd2luZG93V2lkdGggOiBkb2N1bWVudFdpZHRoKGNsb25lZFdpbmRvdy5kb2N1bWVudCk7XG4gICAgdmFyIGhlaWdodCA9IG9wdGlvbnMudHlwZSA9PT0gXCJ2aWV3XCIgPyB3aW5kb3dIZWlnaHQgOiBkb2N1bWVudEhlaWdodChjbG9uZWRXaW5kb3cuZG9jdW1lbnQpO1xuICAgIHZhciByZW5kZXJlciA9IG5ldyBvcHRpb25zLnJlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIGltYWdlTG9hZGVyLCBvcHRpb25zLCBkb2N1bWVudCk7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBOb2RlUGFyc2VyKG5vZGUsIHJlbmRlcmVyLCBzdXBwb3J0LCBpbWFnZUxvYWRlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlci5yZWFkeS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2coXCJGaW5pc2hlZCByZW5kZXJpbmdcIik7XG4gICAgICAgIHZhciBjYW52YXM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IGNyb3AocmVuZGVyZXIuY2FudmFzLCB7d2lkdGg6IHJlbmRlcmVyLmNhbnZhcy53aWR0aCwgaGVpZ2h0OiByZW5kZXJlci5jYW52YXMuaGVpZ2h0LCB0b3A6IDAsIGxlZnQ6IDAsIHg6IDAsIHk6IDB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlID09PSBjbG9uZWRXaW5kb3cuZG9jdW1lbnQuYm9keSB8fCBub2RlID09PSBjbG9uZWRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG9wdGlvbnMuY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IHJlbmRlcmVyLmNhbnZhcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IGNyb3AocmVuZGVyZXIuY2FudmFzLCB7d2lkdGg6ICBvcHRpb25zLndpZHRoICE9IG51bGwgPyBvcHRpb25zLndpZHRoIDogYm91bmRzLndpZHRoLCBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwgPyBvcHRpb25zLmhlaWdodCA6IGJvdW5kcy5oZWlnaHQsIHRvcDogYm91bmRzLnRvcCwgbGVmdDogYm91bmRzLmxlZnQsIHg6IDAsIHk6IDB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFudXBDb250YWluZXIoY29udGFpbmVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cENvbnRhaW5lcihjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZW1vdmVDb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgbG9nKFwiQ2xlYW5lZCB1cCBjb250YWluZXJcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcm9wKGNhbnZhcywgYm91bmRzKSB7XG4gICAgdmFyIGNyb3BwZWRDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHZhciB4MSA9IE1hdGgubWluKGNhbnZhcy53aWR0aCAtIDEsIE1hdGgubWF4KDAsIGJvdW5kcy5sZWZ0KSk7XG4gICAgdmFyIHgyID0gTWF0aC5taW4oY2FudmFzLndpZHRoLCBNYXRoLm1heCgxLCBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCkpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKGNhbnZhcy5oZWlnaHQgLSAxLCBNYXRoLm1heCgwLCBib3VuZHMudG9wKSk7XG4gICAgdmFyIHkyID0gTWF0aC5taW4oY2FudmFzLmhlaWdodCwgTWF0aC5tYXgoMSwgYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpKTtcbiAgICBjcm9wcGVkQ2FudmFzLndpZHRoID0gYm91bmRzLndpZHRoO1xuICAgIGNyb3BwZWRDYW52YXMuaGVpZ2h0ID0gIGJvdW5kcy5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0geDIteDE7XG4gICAgdmFyIGhlaWdodCA9IHkyLXkxO1xuICAgIGxvZyhcIkNyb3BwaW5nIGNhbnZhcyBhdDpcIiwgXCJsZWZ0OlwiLCBib3VuZHMubGVmdCwgXCJ0b3A6XCIsIGJvdW5kcy50b3AsIFwid2lkdGg6XCIsIHdpZHRoLCBcImhlaWdodDpcIiwgaGVpZ2h0KTtcbiAgICBsb2coXCJSZXN1bHRpbmcgY3JvcCB3aXRoIHdpZHRoXCIsIGJvdW5kcy53aWR0aCwgXCJhbmQgaGVpZ2h0XCIsIGJvdW5kcy5oZWlnaHQsIFwid2l0aCB4XCIsIHgxLCBcImFuZCB5XCIsIHkxKTtcbiAgICBjcm9wcGVkQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoY2FudmFzLCB4MSwgeTEsIHdpZHRoLCBoZWlnaHQsIGJvdW5kcy54LCBib3VuZHMueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIGNyb3BwZWRDYW52YXM7XG59XG5cbmZ1bmN0aW9uIGRvY3VtZW50V2lkdGggKGRvYykge1xuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgTWF0aC5tYXgoZG9jLmJvZHkuc2Nyb2xsV2lkdGgsIGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGgpLFxuICAgICAgICBNYXRoLm1heChkb2MuYm9keS5vZmZzZXRXaWR0aCwgZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCksXG4gICAgICAgIE1hdGgubWF4KGRvYy5ib2R5LmNsaWVudFdpZHRoLCBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGRvY3VtZW50SGVpZ2h0IChkb2MpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgIE1hdGgubWF4KGRvYy5ib2R5LnNjcm9sbEhlaWdodCwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpLFxuICAgICAgICBNYXRoLm1heChkb2MuYm9keS5vZmZzZXRIZWlnaHQsIGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgTWF0aC5tYXgoZG9jLmJvZHkuY2xpZW50SGVpZ2h0LCBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodClcbiAgICApO1xufVxuXG5mdW5jdGlvbiBhYnNvbHV0ZVVybCh1cmwpIHtcbiAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBsaW5rLmhyZWYgPSBsaW5rLmhyZWY7XG4gICAgcmV0dXJuIGxpbms7XG59XG5cbn0se1wiLi9jbG9uZVwiOjIsXCIuL2ltYWdlbG9hZGVyXCI6MTEsXCIuL2xvZ1wiOjEzLFwiLi9ub2RlY29udGFpbmVyXCI6MTQsXCIuL25vZGVwYXJzZXJcIjoxNSxcIi4vcHJveHlcIjoxNixcIi4vcmVuZGVyZXJzL2NhbnZhc1wiOjIwLFwiLi9zdXBwb3J0XCI6MjIsXCIuL3V0aWxzXCI6MjZ9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBsb2cgPSBfZGVyZXFfKCcuL2xvZycpO1xudmFyIHNtYWxsSW1hZ2UgPSBfZGVyZXFfKCcuL3V0aWxzJykuc21hbGxJbWFnZTtcblxuZnVuY3Rpb24gRHVtbXlJbWFnZUNvbnRhaW5lcihzcmMpIHtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICBsb2coXCJEdW1teUltYWdlQ29udGFpbmVyIGZvclwiLCBzcmMpO1xuICAgIGlmICghdGhpcy5wcm9taXNlIHx8ICF0aGlzLmltYWdlKSB7XG4gICAgICAgIGxvZyhcIkluaXRpYXRpbmcgRHVtbXlJbWFnZUNvbnRhaW5lclwiKTtcbiAgICAgICAgRHVtbXlJbWFnZUNvbnRhaW5lci5wcm90b3R5cGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgRHVtbXlJbWFnZUNvbnRhaW5lci5wcm90b3R5cGUucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBzbWFsbEltYWdlKCk7XG4gICAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IER1bW15SW1hZ2VDb250YWluZXI7XG5cbn0se1wiLi9sb2dcIjoxMyxcIi4vdXRpbHNcIjoyNn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHNtYWxsSW1hZ2UgPSBfZGVyZXFfKCcuL3V0aWxzJykuc21hbGxJbWFnZTtcblxuZnVuY3Rpb24gRm9udChmYW1pbHksIHNpemUpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpLFxuICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuICAgICAgICBzYW1wbGVUZXh0ID0gJ0hpZGRlbiBUZXh0JyxcbiAgICAgICAgYmFzZWxpbmUsXG4gICAgICAgIG1pZGRsZTtcblxuICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBjb250YWluZXIuc3R5bGUuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgICBjb250YWluZXIuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgIGNvbnRhaW5lci5zdHlsZS5tYXJnaW4gPSAwO1xuICAgIGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gMDtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIGltZy5zcmMgPSBzbWFsbEltYWdlKCk7XG4gICAgaW1nLndpZHRoID0gMTtcbiAgICBpbWcuaGVpZ2h0ID0gMTtcblxuICAgIGltZy5zdHlsZS5tYXJnaW4gPSAwO1xuICAgIGltZy5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICBpbWcuc3R5bGUudmVydGljYWxBbGlnbiA9IFwiYmFzZWxpbmVcIjtcblxuICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgICBzcGFuLnN0eWxlLmZvbnRTaXplID0gc2l6ZTtcbiAgICBzcGFuLnN0eWxlLm1hcmdpbiA9IDA7XG4gICAgc3Bhbi5zdHlsZS5wYWRkaW5nID0gMDtcblxuICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2FtcGxlVGV4dCkpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICBiYXNlbGluZSA9IChpbWcub2Zmc2V0VG9wIC0gc3Bhbi5vZmZzZXRUb3ApICsgMTtcblxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChzcGFuKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2FtcGxlVGV4dCkpO1xuXG4gICAgY29udGFpbmVyLnN0eWxlLmxpbmVIZWlnaHQgPSBcIm5vcm1hbFwiO1xuICAgIGltZy5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJzdXBlclwiO1xuXG4gICAgbWlkZGxlID0gKGltZy5vZmZzZXRUb3AtY29udGFpbmVyLm9mZnNldFRvcCkgKyAxO1xuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gICAgdGhpcy5iYXNlbGluZSA9IGJhc2VsaW5lO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLm1pZGRsZSA9IG1pZGRsZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb250O1xuXG59LHtcIi4vdXRpbHNcIjoyNn1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEZvbnQgPSBfZGVyZXFfKCcuL2ZvbnQnKTtcblxuZnVuY3Rpb24gRm9udE1ldHJpY3MoKSB7XG4gICAgdGhpcy5kYXRhID0ge307XG59XG5cbkZvbnRNZXRyaWNzLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oZmFtaWx5LCBzaXplKSB7XG4gICAgaWYgKHRoaXMuZGF0YVtmYW1pbHkgKyBcIi1cIiArIHNpemVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kYXRhW2ZhbWlseSArIFwiLVwiICsgc2l6ZV0gPSBuZXcgRm9udChmYW1pbHksIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhW2ZhbWlseSArIFwiLVwiICsgc2l6ZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvbnRNZXRyaWNzO1xuXG59LHtcIi4vZm9udFwiOjZ9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbHMnKTtcbnZhciBnZXRCb3VuZHMgPSB1dGlscy5nZXRCb3VuZHM7XG52YXIgbG9hZFVybERvY3VtZW50ID0gX2RlcmVxXygnLi9wcm94eScpLmxvYWRVcmxEb2N1bWVudDtcblxuZnVuY3Rpb24gRnJhbWVDb250YWluZXIoY29udGFpbmVyLCBzYW1lT3JpZ2luLCBvcHRpb25zKSB7XG4gICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgdGhpcy5zcmMgPSBjb250YWluZXI7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBib3VuZHMgPSBnZXRCb3VuZHMoY29udGFpbmVyKTtcbiAgICB0aGlzLnByb21pc2UgPSAoIXNhbWVPcmlnaW4gPyB0aGlzLnByb3h5TG9hZChvcHRpb25zLnByb3h5LCBib3VuZHMsIG9wdGlvbnMpIDogbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBpZiAoY29udGFpbmVyLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuVVJMID09PSBcImFib3V0OmJsYW5rXCIgfHwgY29udGFpbmVyLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jb250ZW50V2luZG93Lm9ubG9hZCA9IGNvbnRhaW5lci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBodG1sMmNhbnZhcyA9IF9kZXJlcV8oJy4vY29yZScpO1xuICAgICAgICByZXR1cm4gaHRtbDJjYW52YXMoY29udGFpbmVyLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7dHlwZTogJ3ZpZXcnLCB3aWR0aDogY29udGFpbmVyLndpZHRoLCBoZWlnaHQ6IGNvbnRhaW5lci5oZWlnaHQsIHByb3h5OiBvcHRpb25zLnByb3h5LCBqYXZhc2NyaXB0RW5hYmxlZDogb3B0aW9ucy5qYXZhc2NyaXB0RW5hYmxlZCwgcmVtb3ZlQ29udGFpbmVyOiBvcHRpb25zLnJlbW92ZUNvbnRhaW5lciwgYWxsb3dUYWludDogb3B0aW9ucy5hbGxvd1RhaW50LCBpbWFnZVRpbWVvdXQ6IG9wdGlvbnMuaW1hZ2VUaW1lb3V0IC8gMn0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmltYWdlID0gY2FudmFzO1xuICAgIH0pO1xufVxuXG5GcmFtZUNvbnRhaW5lci5wcm90b3R5cGUucHJveHlMb2FkID0gZnVuY3Rpb24ocHJveHksIGJvdW5kcywgb3B0aW9ucykge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLnNyYztcbiAgICByZXR1cm4gbG9hZFVybERvY3VtZW50KGNvbnRhaW5lci5zcmMsIHByb3h5LCBjb250YWluZXIub3duZXJEb2N1bWVudCwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWVDb250YWluZXI7XG5cbn0se1wiLi9jb3JlXCI6NCxcIi4vcHJveHlcIjoxNixcIi4vdXRpbHNcIjoyNn1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gR3JhZGllbnRDb250YWluZXIoaW1hZ2VEYXRhKSB7XG4gICAgdGhpcy5zcmMgPSBpbWFnZURhdGEudmFsdWU7XG4gICAgdGhpcy5jb2xvclN0b3BzID0gW107XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLngwID0gMC41O1xuICAgIHRoaXMueTAgPSAwLjU7XG4gICAgdGhpcy54MSA9IDAuNTtcbiAgICB0aGlzLnkxID0gMC41O1xuICAgIHRoaXMucHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbn1cblxuR3JhZGllbnRDb250YWluZXIuVFlQRVMgPSB7XG4gICAgTElORUFSOiAxLFxuICAgIFJBRElBTDogMlxufTtcblxuLy8gVE9ETzogc3VwcG9ydCBoc2xbYV0sIG5lZ2F0aXZlICUvbGVuZ3RoIHZhbHVlc1xuLy8gVE9ETzogc3VwcG9ydCA8YW5nbGU+IChlLmcuIC0/XFxkezEsM30oPzpcXC5cXGQrKWRlZywgZXRjLiA6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9hbmdsZSApXG5HcmFkaWVudENvbnRhaW5lci5SRUdFWFBfQ09MT1JTVE9QID0gL15cXHMqKHJnYmE/XFwoXFxzKlxcZHsxLDN9LFxccypcXGR7MSwzfSxcXHMqXFxkezEsM30oPzosXFxzKlswLTlcXC5dKyk/XFxzKlxcKXxbYS16XXszLDIwfXwjW2EtZjAtOV17Myw2fSkoPzpcXHMrKFxcZHsxLDN9KD86XFwuXFxkKyk/KSglfHB4KT8pPyg/Olxcc3wkKS9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYWRpZW50Q29udGFpbmVyO1xuXG59LHt9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBJbWFnZUNvbnRhaW5lcihzcmMsIGNvcnMpIHtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudGFpbnRlZCA9IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYuaW1hZ2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2VsZi5pbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBpZiAoY29ycykge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pbWFnZS5zcmMgPSBzcmM7XG4gICAgICAgIGlmIChzZWxmLmltYWdlLmNvbXBsZXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHNlbGYuaW1hZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VDb250YWluZXI7XG5cbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBsb2cgPSBfZGVyZXFfKCcuL2xvZycpO1xudmFyIEltYWdlQ29udGFpbmVyID0gX2RlcmVxXygnLi9pbWFnZWNvbnRhaW5lcicpO1xudmFyIER1bW15SW1hZ2VDb250YWluZXIgPSBfZGVyZXFfKCcuL2R1bW15aW1hZ2Vjb250YWluZXInKTtcbnZhciBQcm94eUltYWdlQ29udGFpbmVyID0gX2RlcmVxXygnLi9wcm94eWltYWdlY29udGFpbmVyJyk7XG52YXIgRnJhbWVDb250YWluZXIgPSBfZGVyZXFfKCcuL2ZyYW1lY29udGFpbmVyJyk7XG52YXIgU1ZHQ29udGFpbmVyID0gX2RlcmVxXygnLi9zdmdjb250YWluZXInKTtcbnZhciBTVkdOb2RlQ29udGFpbmVyID0gX2RlcmVxXygnLi9zdmdub2RlY29udGFpbmVyJyk7XG52YXIgTGluZWFyR3JhZGllbnRDb250YWluZXIgPSBfZGVyZXFfKCcuL2xpbmVhcmdyYWRpZW50Y29udGFpbmVyJyk7XG52YXIgV2Via2l0R3JhZGllbnRDb250YWluZXIgPSBfZGVyZXFfKCcuL3dlYmtpdGdyYWRpZW50Y29udGFpbmVyJyk7XG52YXIgYmluZCA9IF9kZXJlcV8oJy4vdXRpbHMnKS5iaW5kO1xuXG5mdW5jdGlvbiBJbWFnZUxvYWRlcihvcHRpb25zLCBzdXBwb3J0KSB7XG4gICAgdGhpcy5saW5rID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgdGhpcy5vcmlnaW4gPSB0aGlzLmdldE9yaWdpbih3aW5kb3cubG9jYXRpb24uaHJlZik7XG59XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5maW5kSW1hZ2VzID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICB2YXIgaW1hZ2VzID0gW107XG4gICAgbm9kZXMucmVkdWNlKGZ1bmN0aW9uKGltYWdlTm9kZXMsIGNvbnRhaW5lcikge1xuICAgICAgICBzd2l0Y2goY29udGFpbmVyLm5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgY2FzZSBcIklNR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGltYWdlTm9kZXMuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgYXJnczogW2NvbnRhaW5lci5ub2RlLnNyY10sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInVybFwiXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgY2FzZSBcIklGUkFNRVwiOlxuICAgICAgICAgICAgcmV0dXJuIGltYWdlTm9kZXMuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgYXJnczogW2NvbnRhaW5lci5ub2RlXSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNvbnRhaW5lci5ub2RlLm5vZGVOYW1lXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlTm9kZXM7XG4gICAgfSwgW10pLmZvckVhY2godGhpcy5hZGRJbWFnZShpbWFnZXMsIHRoaXMubG9hZEltYWdlKSwgdGhpcyk7XG4gICAgcmV0dXJuIGltYWdlcztcbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5maW5kQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24oaW1hZ2VzLCBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIucGFyc2VCYWNrZ3JvdW5kSW1hZ2VzKCkuZmlsdGVyKHRoaXMuaGFzSW1hZ2VCYWNrZ3JvdW5kKS5mb3JFYWNoKHRoaXMuYWRkSW1hZ2UoaW1hZ2VzLCB0aGlzLmxvYWRJbWFnZSksIHRoaXMpO1xuICAgIHJldHVybiBpbWFnZXM7XG59O1xuXG5JbWFnZUxvYWRlci5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbihpbWFnZXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5ld0ltYWdlKSB7XG4gICAgICAgIG5ld0ltYWdlLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihpbWFnZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmltYWdlRXhpc3RzKGltYWdlcywgaW1hZ2UpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VzLnNwbGljZSgwLCAwLCBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld0ltYWdlKSk7XG4gICAgICAgICAgICAgICAgbG9nKCdBZGRlZCBpbWFnZSAjJyArIChpbWFnZXMubGVuZ3RoKSwgdHlwZW9mKGltYWdlKSA9PT0gXCJzdHJpbmdcIiA/IGltYWdlLnN1YnN0cmluZygwLCAxMDApIDogaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xufTtcblxuSW1hZ2VMb2FkZXIucHJvdG90eXBlLmhhc0ltYWdlQmFja2dyb3VuZCA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHJldHVybiBpbWFnZURhdGEubWV0aG9kICE9PSBcIm5vbmVcIjtcbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICBpZiAoaW1hZ2VEYXRhLm1ldGhvZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICB2YXIgc3JjID0gaW1hZ2VEYXRhLmFyZ3NbMF07XG4gICAgICAgIGlmICh0aGlzLmlzU1ZHKHNyYykgJiYgIXRoaXMuc3VwcG9ydC5zdmcgJiYgIXRoaXMub3B0aW9ucy5hbGxvd1RhaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNWR0NvbnRhaW5lcihzcmMpO1xuICAgICAgICB9IGVsc2UgaWYgKHNyYy5tYXRjaCgvZGF0YTppbWFnZVxcLy4qO2Jhc2U2NCwvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VDb250YWluZXIoc3JjLnJlcGxhY2UoL3VybFxcKFsnXCJdezAsfXxbJ1wiXXswLH1cXCkkL2lnLCAnJyksIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2FtZU9yaWdpbihzcmMpIHx8IHRoaXMub3B0aW9ucy5hbGxvd1RhaW50ID09PSB0cnVlIHx8IHRoaXMuaXNTVkcoc3JjKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZUNvbnRhaW5lcihzcmMsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN1cHBvcnQuY29ycyAmJiAhdGhpcy5vcHRpb25zLmFsbG93VGFpbnQgJiYgdGhpcy5vcHRpb25zLnVzZUNPUlMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VDb250YWluZXIoc3JjLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucHJveHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHlJbWFnZUNvbnRhaW5lcihzcmMsIHRoaXMub3B0aW9ucy5wcm94eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1bW15SW1hZ2VDb250YWluZXIoc3JjKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW1hZ2VEYXRhLm1ldGhvZCA9PT0gXCJsaW5lYXItZ3JhZGllbnRcIikge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVhckdyYWRpZW50Q29udGFpbmVyKGltYWdlRGF0YSk7XG4gICAgfSBlbHNlIGlmIChpbWFnZURhdGEubWV0aG9kID09PSBcImdyYWRpZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJraXRHcmFkaWVudENvbnRhaW5lcihpbWFnZURhdGEpO1xuICAgIH0gZWxzZSBpZiAoaW1hZ2VEYXRhLm1ldGhvZCA9PT0gXCJzdmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IFNWR05vZGVDb250YWluZXIoaW1hZ2VEYXRhLmFyZ3NbMF0sIHRoaXMuc3VwcG9ydC5zdmcpO1xuICAgIH0gZWxzZSBpZiAoaW1hZ2VEYXRhLm1ldGhvZCA9PT0gXCJJRlJBTUVcIikge1xuICAgICAgICByZXR1cm4gbmV3IEZyYW1lQ29udGFpbmVyKGltYWdlRGF0YS5hcmdzWzBdLCB0aGlzLmlzU2FtZU9yaWdpbihpbWFnZURhdGEuYXJnc1swXS5zcmMpLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRHVtbXlJbWFnZUNvbnRhaW5lcihpbWFnZURhdGEpO1xuICAgIH1cbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5pc1NWRyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIHJldHVybiBzcmMuc3Vic3RyaW5nKHNyYy5sZW5ndGggLSAzKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiIHx8IFNWR0NvbnRhaW5lci5wcm90b3R5cGUuaXNJbmxpbmUoc3JjKTtcbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5pbWFnZUV4aXN0cyA9IGZ1bmN0aW9uKGltYWdlcywgc3JjKSB7XG4gICAgcmV0dXJuIGltYWdlcy5zb21lKGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICAgIHJldHVybiBpbWFnZS5zcmMgPT09IHNyYztcbiAgICB9KTtcbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0T3JpZ2luKHVybCkgPT09IHRoaXMub3JpZ2luKTtcbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS5nZXRPcmlnaW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgbGluayA9IHRoaXMubGluayB8fCAodGhpcy5saW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBsaW5rLmhyZWYgPSBsaW5rLmhyZWY7IC8vIElFOSwgTE9MISAtIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbmlrbGFzdmgvMmU0OGIvXG4gICAgcmV0dXJuIGxpbmsucHJvdG9jb2wgKyBsaW5rLmhvc3RuYW1lICsgbGluay5wb3J0O1xufTtcblxuSW1hZ2VMb2FkZXIucHJvdG90eXBlLmdldFByb21pc2UgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lb3V0KGNvbnRhaW5lciwgdGhpcy5vcHRpb25zLmltYWdlVGltZW91dClbJ2NhdGNoJ10oZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkdW1teSA9IG5ldyBEdW1teUltYWdlQ29udGFpbmVyKGNvbnRhaW5lci5zcmMpO1xuICAgICAgICByZXR1cm4gZHVtbXkucHJvbWlzZS50aGVuKGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICAgICAgICBjb250YWluZXIuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5JbWFnZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgdmFyIGZvdW5kID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5pbWFnZXMuc29tZShmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgcmV0dXJuIChmb3VuZCA9IGltZykuc3JjID09PSBzcmM7XG4gICAgfSkgPyBmb3VuZCA6IG51bGw7XG59O1xuXG5JbWFnZUxvYWRlci5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihub2Rlcykge1xuICAgIHRoaXMuaW1hZ2VzID0gbm9kZXMucmVkdWNlKGJpbmQodGhpcy5maW5kQmFja2dyb3VuZEltYWdlLCB0aGlzKSwgdGhpcy5maW5kSW1hZ2VzKG5vZGVzKSk7XG4gICAgdGhpcy5pbWFnZXMuZm9yRWFjaChmdW5jdGlvbihpbWFnZSwgaW5kZXgpIHtcbiAgICAgICAgaW1hZ2UucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9nKFwiU3VjY2VzZnVsbHkgbG9hZGVkIGltYWdlICNcIisgKGluZGV4KzEpLCBpbWFnZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxvZyhcIkZhaWxlZCBsb2FkaW5nIGltYWdlICNcIisgKGluZGV4KzEpLCBpbWFnZSwgZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMucmVhZHkgPSBQcm9taXNlLmFsbCh0aGlzLmltYWdlcy5tYXAodGhpcy5nZXRQcm9taXNlLCB0aGlzKSk7XG4gICAgbG9nKFwiRmluaXNoZWQgc2VhcmNoaW5nIGltYWdlc1wiKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkltYWdlTG9hZGVyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24oY29udGFpbmVyLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVyO1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yYWNlKFtjb250YWluZXIucHJvbWlzZSwgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzLCByZWplY3QpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9nKFwiVGltZWQgb3V0IGxvYWRpbmcgaW1hZ2VcIiwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJlamVjdChjb250YWluZXIpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KV0pLnRoZW4oZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSk7XG4gICAgcHJvbWlzZVsnY2F0Y2gnXShmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VMb2FkZXI7XG5cbn0se1wiLi9kdW1teWltYWdlY29udGFpbmVyXCI6NSxcIi4vZnJhbWVjb250YWluZXJcIjo4LFwiLi9pbWFnZWNvbnRhaW5lclwiOjEwLFwiLi9saW5lYXJncmFkaWVudGNvbnRhaW5lclwiOjEyLFwiLi9sb2dcIjoxMyxcIi4vcHJveHlpbWFnZWNvbnRhaW5lclwiOjE3LFwiLi9zdmdjb250YWluZXJcIjoyMyxcIi4vc3Znbm9kZWNvbnRhaW5lclwiOjI0LFwiLi91dGlsc1wiOjI2LFwiLi93ZWJraXRncmFkaWVudGNvbnRhaW5lclwiOjI3fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEdyYWRpZW50Q29udGFpbmVyID0gX2RlcmVxXygnLi9ncmFkaWVudGNvbnRhaW5lcicpO1xudmFyIENvbG9yID0gX2RlcmVxXygnLi9jb2xvcicpO1xuXG5mdW5jdGlvbiBMaW5lYXJHcmFkaWVudENvbnRhaW5lcihpbWFnZURhdGEpIHtcbiAgICBHcmFkaWVudENvbnRhaW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IEdyYWRpZW50Q29udGFpbmVyLlRZUEVTLkxJTkVBUjtcblxuICAgIHZhciBoYXNEaXJlY3Rpb24gPSBMaW5lYXJHcmFkaWVudENvbnRhaW5lci5SRUdFWFBfRElSRUNUSU9OLnRlc3QoIGltYWdlRGF0YS5hcmdzWzBdICkgfHxcbiAgICAgICAgIUdyYWRpZW50Q29udGFpbmVyLlJFR0VYUF9DT0xPUlNUT1AudGVzdCggaW1hZ2VEYXRhLmFyZ3NbMF0gKTtcblxuICAgIGlmIChoYXNEaXJlY3Rpb24pIHtcbiAgICAgICAgaW1hZ2VEYXRhLmFyZ3NbMF0uc3BsaXQoL1xccysvKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLngwID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnkwID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHRoaXMueDAgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICAgIHRoaXMueTAgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMueTEgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICAgICAgdmFyIHkwID0gdGhpcy55MDtcbiAgICAgICAgICAgICAgICB2YXIgeDAgPSB0aGlzLngwO1xuICAgICAgICAgICAgICAgIHRoaXMueTAgPSB0aGlzLnkxO1xuICAgICAgICAgICAgICAgIHRoaXMueDAgPSB0aGlzLngxO1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB4MDtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0geTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGNlbnRlcmVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggaW50ZXJuYWxseSBjb252ZXJ0cyBwb3NpdGlvbiBrZXl3b3JkcyB0byBwZXJjZW50YWdlczpcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTAvV0QtQ1NTMi0yMDEwMTIwNy9jb2xvcnMuaHRtbCNwcm9wZGVmLWJhY2tncm91bmQtcG9zaXRpb25cbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIHBlcmNlbnRhZ2Ugb3IgYWJzb2x1dGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhYnNvbHV0ZSBzdGFydCBwb2ludCBwb3NpdGlvbnMgKGUuZy4sIHVzZSBib3VuZHMgdG8gY29udmVydCBweCB0byBhIHJhdGlvKVxuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHBhcnNlRmxvYXQocG9zaXRpb24sIDEwKSAqIDFlLTI7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHJhdGlvKSkgeyAvLyBpbnZhbGlkIG9yIHVuaGFuZGxlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueTAgPSByYXRpbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55MSA9IDEgLSB0aGlzLnkwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueDAgPSByYXRpbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54MSA9IDEgLSB0aGlzLngwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55MCA9IDA7XG4gICAgICAgIHRoaXMueTEgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY29sb3JTdG9wcyA9IGltYWdlRGF0YS5hcmdzLnNsaWNlKGhhc0RpcmVjdGlvbiA/IDEgOiAwKS5tYXAoZnVuY3Rpb24oY29sb3JTdG9wKSB7XG4gICAgICAgIHZhciBjb2xvclN0b3BNYXRjaCA9IGNvbG9yU3RvcC5tYXRjaChHcmFkaWVudENvbnRhaW5lci5SRUdFWFBfQ09MT1JTVE9QKTtcbiAgICAgICAgdmFyIHZhbHVlID0gK2NvbG9yU3RvcE1hdGNoWzJdO1xuICAgICAgICB2YXIgdW5pdCA9IHZhbHVlID09PSAwID8gXCIlXCIgOiBjb2xvclN0b3BNYXRjaFszXTsgLy8gdHJlYXQgXCIwXCIgYXMgXCIwJVwiXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IENvbG9yKGNvbG9yU3RvcE1hdGNoWzFdKSxcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYWJzb2x1dGUgc3RvcCBwb3NpdGlvbnMgKGUuZy4sIGNvbXB1dGUgZ3JhZGllbnQgbGluZSBsZW5ndGggJiBjb252ZXJ0IHB4IHRvIHJhdGlvKVxuICAgICAgICAgICAgc3RvcDogdW5pdCA9PT0gXCIlXCIgPyB2YWx1ZSAvIDEwMCA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNvbG9yU3RvcHNbMF0uc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbG9yU3RvcHNbMF0uc3RvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29sb3JTdG9wc1t0aGlzLmNvbG9yU3RvcHMubGVuZ3RoIC0gMV0uc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbG9yU3RvcHNbdGhpcy5jb2xvclN0b3BzLmxlbmd0aCAtIDFdLnN0b3AgPSAxO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZXMgYW5kIGZpbGxzLWluIGV4cGxpY2l0IHN0b3AgcG9zaXRpb25zIHdoZW4gb21pdHRlZCBmcm9tIHJ1bGVcbiAgICB0aGlzLmNvbG9yU3RvcHMuZm9yRWFjaChmdW5jdGlvbihjb2xvclN0b3AsIGluZGV4KSB7XG4gICAgICAgIGlmIChjb2xvclN0b3Auc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnNsaWNlKGluZGV4KS5zb21lKGZ1bmN0aW9uKGZpbmQsIGNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmQuc3RvcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3Auc3RvcCA9ICgoZmluZC5zdG9wIC0gdGhpcy5jb2xvclN0b3BzW2luZGV4IC0gMV0uc3RvcCkgLyAoY291bnQgKyAxKSkgKyB0aGlzLmNvbG9yU3RvcHNbaW5kZXggLSAxXS5zdG9wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn1cblxuTGluZWFyR3JhZGllbnRDb250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcmFkaWVudENvbnRhaW5lci5wcm90b3R5cGUpO1xuXG4vLyBUT0RPOiBzdXBwb3J0IDxhbmdsZT4gKGUuZy4gLT9cXGR7MSwzfSg/OlxcLlxcZCspZGVnLCBldGMuIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL2FuZ2xlIClcbkxpbmVhckdyYWRpZW50Q29udGFpbmVyLlJFR0VYUF9ESVJFQ1RJT04gPSAvXlxccyooPzp0b3xsZWZ0fHJpZ2h0fHRvcHxib3R0b218Y2VudGVyfFxcZHsxLDN9KD86XFwuXFxkKyk/JT8pKD86XFxzfCQpL2k7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyR3JhZGllbnRDb250YWluZXI7XG5cbn0se1wiLi9jb2xvclwiOjMsXCIuL2dyYWRpZW50Y29udGFpbmVyXCI6OX1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBsb2dnZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobG9nZ2VyLm9wdGlvbnMubG9nZ2luZyAmJiB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbCh3aW5kb3cuY29uc29sZS5sb2csICh3aW5kb3cuY29uc29sZSkpLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBbKERhdGUubm93KCkgLSBsb2dnZXIub3B0aW9ucy5zdGFydCkgKyBcIm1zXCIsIFwiaHRtbDJjYW52YXM6XCJdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9XG59O1xuXG5sb2dnZXIub3B0aW9ucyA9IHtsb2dnaW5nOiBmYWxzZX07XG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbG9yID0gX2RlcmVxXygnLi9jb2xvcicpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIGdldEJvdW5kcyA9IHV0aWxzLmdldEJvdW5kcztcbnZhciBwYXJzZUJhY2tncm91bmRzID0gdXRpbHMucGFyc2VCYWNrZ3JvdW5kcztcbnZhciBvZmZzZXRCb3VuZHMgPSB1dGlscy5vZmZzZXRCb3VuZHM7XG5cbmZ1bmN0aW9uIE5vZGVDb250YWluZXIobm9kZSwgcGFyZW50KSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnN0YWNrID0gbnVsbDtcbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5ib3JkZXJzID0gbnVsbDtcbiAgICB0aGlzLmNsaXAgPSBbXTtcbiAgICB0aGlzLmJhY2tncm91bmRDbGlwID0gW107XG4gICAgdGhpcy5vZmZzZXRCb3VuZHMgPSBudWxsO1xuICAgIHRoaXMudmlzaWJsZSA9IG51bGw7XG4gICAgdGhpcy5jb21wdXRlZFN0eWxlcyA9IG51bGw7XG4gICAgdGhpcy5jb2xvcnMgPSB7fTtcbiAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgIHRoaXMuYmFja2dyb3VuZEltYWdlcyA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm1EYXRhID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5pc1BzZXVkb0VsZW1lbnQgPSBmYWxzZTtcbiAgICB0aGlzLm9wYWNpdHkgPSBudWxsO1xufVxuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5jbG9uZVRvID0gZnVuY3Rpb24oc3RhY2spIHtcbiAgICBzdGFjay52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgIHN0YWNrLmJvcmRlcnMgPSB0aGlzLmJvcmRlcnM7XG4gICAgc3RhY2suYm91bmRzID0gdGhpcy5ib3VuZHM7XG4gICAgc3RhY2suY2xpcCA9IHRoaXMuY2xpcDtcbiAgICBzdGFjay5iYWNrZ3JvdW5kQ2xpcCA9IHRoaXMuYmFja2dyb3VuZENsaXA7XG4gICAgc3RhY2suY29tcHV0ZWRTdHlsZXMgPSB0aGlzLmNvbXB1dGVkU3R5bGVzO1xuICAgIHN0YWNrLnN0eWxlcyA9IHRoaXMuc3R5bGVzO1xuICAgIHN0YWNrLmJhY2tncm91bmRJbWFnZXMgPSB0aGlzLmJhY2tncm91bmRJbWFnZXM7XG4gICAgc3RhY2sub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLmdldE9wYWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSBudWxsID8gKHRoaXMub3BhY2l0eSA9IHRoaXMuY3NzRmxvYXQoJ29wYWNpdHknKSkgOiB0aGlzLm9wYWNpdHk7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5hc3NpZ25TdGFjayA9IGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHN0YWNrLmNoaWxkcmVuLnB1c2godGhpcyk7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5pc0VsZW1lbnRWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyB0aGlzLnBhcmVudC52aXNpYmxlIDogKFxuICAgICAgICB0aGlzLmNzcygnZGlzcGxheScpICE9PSBcIm5vbmVcIiAmJlxuICAgICAgICB0aGlzLmNzcygndmlzaWJpbGl0eScpICE9PSBcImhpZGRlblwiICYmXG4gICAgICAgICF0aGlzLm5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1odG1sMmNhbnZhcy1pZ25vcmVcIikgJiZcbiAgICAgICAgKHRoaXMubm9kZS5ub2RlTmFtZSAhPT0gXCJJTlBVVFwiIHx8IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICE9PSBcImhpZGRlblwiKVxuICAgICk7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRTdHlsZXMpIHtcbiAgICAgICAgdGhpcy5jb21wdXRlZFN0eWxlcyA9IHRoaXMuaXNQc2V1ZG9FbGVtZW50ID8gdGhpcy5wYXJlbnQuY29tcHV0ZWRTdHlsZSh0aGlzLmJlZm9yZSA/IFwiOmJlZm9yZVwiIDogXCI6YWZ0ZXJcIikgOiB0aGlzLmNvbXB1dGVkU3R5bGUobnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzW2F0dHJpYnV0ZV0gfHwgKHRoaXMuc3R5bGVzW2F0dHJpYnV0ZV0gPSB0aGlzLmNvbXB1dGVkU3R5bGVzW2F0dHJpYnV0ZV0pO1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUucHJlZml4ZWRDc3MgPSBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICB2YXIgcHJlZml4ZXMgPSBbXCJ3ZWJraXRcIiwgXCJtb3pcIiwgXCJtc1wiLCBcIm9cIl07XG4gICAgdmFyIHZhbHVlID0gdGhpcy5jc3MoYXR0cmlidXRlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmVmaXhlcy5zb21lKGZ1bmN0aW9uKHByZWZpeCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNzcyhwcmVmaXggKyBhdHRyaWJ1dGUuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBhdHRyaWJ1dGUuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWU7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5jb21wdXRlZFN0eWxlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgdHlwZSk7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5jc3NJbnQgPSBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJzZUludCh0aGlzLmNzcyhhdHRyaWJ1dGUpLCAxMCk7XG4gICAgcmV0dXJuIChpc05hTih2YWx1ZSkpID8gMCA6IHZhbHVlOyAvLyBib3JkZXJzIGluIG9sZCBJRSBhcmUgdGhyb3dpbmcgJ21lZGl1bScgZm9yIGRlbW8uaHRtbFxufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUuY29sb3IgPSBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcnNbYXR0cmlidXRlXSB8fCAodGhpcy5jb2xvcnNbYXR0cmlidXRlXSA9IG5ldyBDb2xvcih0aGlzLmNzcyhhdHRyaWJ1dGUpKSk7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5jc3NGbG9hdCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5jc3MoYXR0cmlidXRlKSk7XG4gICAgcmV0dXJuIChpc05hTih2YWx1ZSkpID8gMCA6IHZhbHVlO1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUuZm9udFdlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ZWlnaHQgPSB0aGlzLmNzcyhcImZvbnRXZWlnaHRcIik7XG4gICAgc3dpdGNoKHBhcnNlSW50KHdlaWdodCwgMTApKXtcbiAgICBjYXNlIDQwMTpcbiAgICAgICAgd2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDAwOlxuICAgICAgICB3ZWlnaHQgPSBcIm5vcm1hbFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHdlaWdodDtcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLnBhcnNlQ2xpcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5jc3MoJ2NsaXAnKS5tYXRjaCh0aGlzLkNMSVApO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUludChtYXRjaGVzWzJdLCAxMCksXG4gICAgICAgICAgICBib3R0b206IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKSxcbiAgICAgICAgICAgIGxlZnQ6IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLnBhcnNlQmFja2dyb3VuZEltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRJbWFnZXMgfHwgKHRoaXMuYmFja2dyb3VuZEltYWdlcyA9IHBhcnNlQmFja2dyb3VuZHModGhpcy5jc3MoXCJiYWNrZ3JvdW5kSW1hZ2VcIikpKTtcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLmNzc0xpc3QgPSBmdW5jdGlvbihwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWUgPSAodGhpcy5jc3MocHJvcGVydHkpIHx8ICcnKS5zcGxpdCgnLCcpO1xuICAgIHZhbHVlID0gdmFsdWVbaW5kZXggfHwgMF0gfHwgdmFsdWVbMF0gfHwgJ2F1dG8nO1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZVswXSwgaXNQZXJjZW50YWdlKHZhbHVlWzBdKSA/ICdhdXRvJyA6IHZhbHVlWzBdXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUucGFyc2VCYWNrZ3JvdW5kU2l6ZSA9IGZ1bmN0aW9uKGJvdW5kcywgaW1hZ2UsIGluZGV4KSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmNzc0xpc3QoXCJiYWNrZ3JvdW5kU2l6ZVwiLCBpbmRleCk7XG4gICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoaXNQZXJjZW50YWdlKHNpemVbMF0pKSB7XG4gICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoICogcGFyc2VGbG9hdChzaXplWzBdKSAvIDEwMDtcbiAgICB9IGVsc2UgaWYgKC9jb250YWlufGNvdmVyLy50ZXN0KHNpemVbMF0pKSB7XG4gICAgICAgIHZhciB0YXJnZXRSYXRpbyA9IGJvdW5kcy53aWR0aCAvIGJvdW5kcy5oZWlnaHQsIGN1cnJlbnRSYXRpbyA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gKHRhcmdldFJhdGlvIDwgY3VycmVudFJhdGlvIF4gc2l6ZVswXSA9PT0gJ2NvbnRhaW4nKSA/ICB7d2lkdGg6IGJvdW5kcy5oZWlnaHQgKiBjdXJyZW50UmF0aW8sIGhlaWdodDogYm91bmRzLmhlaWdodH0gOiB7d2lkdGg6IGJvdW5kcy53aWR0aCwgaGVpZ2h0OiBib3VuZHMud2lkdGggLyBjdXJyZW50UmF0aW99O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gcGFyc2VJbnQoc2l6ZVswXSwgMTApO1xuICAgIH1cblxuICAgIGlmIChzaXplWzBdID09PSAnYXV0bycgJiYgc2l6ZVsxXSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHNpemVbMV0gPT09ICdhdXRvJykge1xuICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGltYWdlLndpZHRoICogaW1hZ2UuaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaXNQZXJjZW50YWdlKHNpemVbMV0pKSB7XG4gICAgICAgIGhlaWdodCA9ICBib3VuZHMuaGVpZ2h0ICogcGFyc2VGbG9hdChzaXplWzFdKSAvIDEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoZWlnaHQgPSBwYXJzZUludChzaXplWzFdLCAxMCk7XG4gICAgfVxuXG4gICAgaWYgKHNpemVbMF0gPT09ICdhdXRvJykge1xuICAgICAgICB3aWR0aCA9IGhlaWdodCAvIGltYWdlLmhlaWdodCAqIGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiB7d2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodH07XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5wYXJzZUJhY2tncm91bmRQb3NpdGlvbiA9IGZ1bmN0aW9uKGJvdW5kcywgaW1hZ2UsIGluZGV4LCBiYWNrZ3JvdW5kU2l6ZSkge1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuY3NzTGlzdCgnYmFja2dyb3VuZFBvc2l0aW9uJywgaW5kZXgpO1xuICAgIHZhciBsZWZ0LCB0b3A7XG5cbiAgICBpZiAoaXNQZXJjZW50YWdlKHBvc2l0aW9uWzBdKSl7XG4gICAgICAgIGxlZnQgPSAoYm91bmRzLndpZHRoIC0gKGJhY2tncm91bmRTaXplIHx8IGltYWdlKS53aWR0aCkgKiAocGFyc2VGbG9hdChwb3NpdGlvblswXSkgLyAxMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwYXJzZUludChwb3NpdGlvblswXSwgMTApO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvblsxXSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRvcCA9IGxlZnQgLyBpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGlzUGVyY2VudGFnZShwb3NpdGlvblsxXSkpe1xuICAgICAgICB0b3AgPSAgKGJvdW5kcy5oZWlnaHQgLSAoYmFja2dyb3VuZFNpemUgfHwgaW1hZ2UpLmhlaWdodCkgKiBwYXJzZUZsb2F0KHBvc2l0aW9uWzFdKSAvIDEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBwYXJzZUludChwb3NpdGlvblsxXSwgMTApO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvblswXSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGxlZnQgPSB0b3AgLyBpbWFnZS5oZWlnaHQgKiBpbWFnZS53aWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHRvcDogdG9wfTtcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLnBhcnNlQmFja2dyb3VuZFJlcGVhdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzTGlzdChcImJhY2tncm91bmRSZXBlYXRcIiwgaW5kZXgpWzBdO1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUucGFyc2VUZXh0U2hhZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXh0U2hhZG93ID0gdGhpcy5jc3MoXCJ0ZXh0U2hhZG93XCIpO1xuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICBpZiAodGV4dFNoYWRvdyAmJiB0ZXh0U2hhZG93ICE9PSAnbm9uZScpIHtcbiAgICAgICAgdmFyIHNoYWRvd3MgPSB0ZXh0U2hhZG93Lm1hdGNoKHRoaXMuVEVYVF9TSEFET1dfUFJPUEVSVFkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgc2hhZG93cyAmJiAoaSA8IHNoYWRvd3MubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNoYWRvd3NbaV0ubWF0Y2godGhpcy5URVhUX1NIQURPV19WQUxVRVMpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IENvbG9yKHNbMF0pLFxuICAgICAgICAgICAgICAgIG9mZnNldFg6IHNbMV0gPyBwYXJzZUZsb2F0KHNbMV0ucmVwbGFjZSgncHgnLCAnJykpIDogMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiBzWzJdID8gcGFyc2VGbG9hdChzWzJdLnJlcGxhY2UoJ3B4JywgJycpKSA6IDAsXG4gICAgICAgICAgICAgICAgYmx1cjogc1szXSA/IHNbM10ucmVwbGFjZSgncHgnLCAnJykgOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLnBhcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zZm9ybURhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVHJhbnNmb3JtKCkpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnBhcnNlQm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5wcmVmaXhlZENzcyhcInRyYW5zZm9ybU9yaWdpblwiKS5zcGxpdChcIiBcIikubWFwKHJlbW92ZVB4KS5tYXAoYXNGbG9hdCk7XG4gICAgICAgICAgICBvcmlnaW5bMF0gKz0gb2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICBvcmlnaW5bMV0gKz0gb2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICBtYXRyaXg6IHRoaXMucGFyc2VUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFswLCAwXSxcbiAgICAgICAgICAgICAgICBtYXRyaXg6IFsxLCAwLCAwLCAxLCAwLCAwXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1EYXRhO1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUucGFyc2VUcmFuc2Zvcm1NYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnByZWZpeGVkQ3NzKFwidHJhbnNmb3JtXCIpO1xuICAgICAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtID8gcGFyc2VNYXRyaXgodHJhbnNmb3JtLm1hdGNoKHRoaXMuTUFUUklYX1BST1BFUlRZKSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG1hdHJpeCA/IG1hdHJpeCA6IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWF0cml4O1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUucGFyc2VCb3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMgfHwgKHRoaXMuYm91bmRzID0gdGhpcy5oYXNUcmFuc2Zvcm0oKSA/IG9mZnNldEJvdW5kcyh0aGlzLm5vZGUpIDogZ2V0Qm91bmRzKHRoaXMubm9kZSkpO1xufTtcblxuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUuaGFzVHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUcmFuc2Zvcm1NYXRyaXgoKS5qb2luKFwiLFwiKSAhPT0gXCIxLDAsMCwxLDAsMFwiIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oYXNUcmFuc2Zvcm0oKSk7XG59O1xuXG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMubm9kZS52YWx1ZSB8fCBcIlwiO1xuICAgIGlmICh0aGlzLm5vZGUudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICAgICAgICB2YWx1ZSA9IHNlbGVjdGlvblZhbHVlKHRoaXMubm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGUudHlwZSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICAgIHZhbHVlID0gQXJyYXkodmFsdWUubGVuZ3RoICsgMSkuam9pbignXFx1MjAyMicpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMCA/ICh0aGlzLm5vZGUucGxhY2Vob2xkZXIgfHwgXCJcIikgOiB2YWx1ZTtcbn07XG5cbk5vZGVDb250YWluZXIucHJvdG90eXBlLk1BVFJJWF9QUk9QRVJUWSA9IC8obWF0cml4fG1hdHJpeDNkKVxcKCguKylcXCkvO1xuTm9kZUNvbnRhaW5lci5wcm90b3R5cGUuVEVYVF9TSEFET1dfUFJPUEVSVFkgPSAvKChyZ2JhfHJnYilcXChbXlxcKV0rXFwpKFxccy0/XFxkK3B4KXswLH0pL2c7XG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5URVhUX1NIQURPV19WQUxVRVMgPSAvKC0/XFxkK3B4KXwoIy4rKXwocmdiXFwoLitcXCkpfChyZ2JhXFwoLitcXCkpL2c7XG5Ob2RlQ29udGFpbmVyLnByb3RvdHlwZS5DTElQID0gL15yZWN0XFwoKFxcZCspcHgsPyAoXFxkKylweCw/IChcXGQrKXB4LD8gKFxcZCspcHhcXCkkLztcblxuZnVuY3Rpb24gc2VsZWN0aW9uVmFsdWUobm9kZSkge1xuICAgIHZhciBvcHRpb24gPSBub2RlLm9wdGlvbnNbbm9kZS5zZWxlY3RlZEluZGV4IHx8IDBdO1xuICAgIHJldHVybiBvcHRpb24gPyAob3B0aW9uLnRleHQgfHwgXCJcIikgOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hdHJpeChtYXRjaCkge1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgICByZXR1cm4gbWF0Y2hbMl0uc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0gPT09IFwibWF0cml4M2RcIikge1xuICAgICAgICB2YXIgbWF0cml4M2QgPSBtYXRjaFsyXS5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW21hdHJpeDNkWzBdLCBtYXRyaXgzZFsxXSwgbWF0cml4M2RbNF0sIG1hdHJpeDNkWzVdLCBtYXRyaXgzZFsxMl0sIG1hdHJpeDNkWzEzXV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVB4KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShcInB4XCIsIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBhc0Zsb2F0KHN0cikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZUNvbnRhaW5lcjtcblxufSx7XCIuL2NvbG9yXCI6MyxcIi4vdXRpbHNcIjoyNn1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBsb2cgPSBfZGVyZXFfKCcuL2xvZycpO1xudmFyIHB1bnljb2RlID0gX2RlcmVxXygncHVueWNvZGUnKTtcbnZhciBOb2RlQ29udGFpbmVyID0gX2RlcmVxXygnLi9ub2RlY29udGFpbmVyJyk7XG52YXIgVGV4dENvbnRhaW5lciA9IF9kZXJlcV8oJy4vdGV4dGNvbnRhaW5lcicpO1xudmFyIFBzZXVkb0VsZW1lbnRDb250YWluZXIgPSBfZGVyZXFfKCcuL3BzZXVkb2VsZW1lbnRjb250YWluZXInKTtcbnZhciBGb250TWV0cmljcyA9IF9kZXJlcV8oJy4vZm9udG1ldHJpY3MnKTtcbnZhciBDb2xvciA9IF9kZXJlcV8oJy4vY29sb3InKTtcbnZhciBTdGFja2luZ0NvbnRleHQgPSBfZGVyZXFfKCcuL3N0YWNraW5nY29udGV4dCcpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIGJpbmQgPSB1dGlscy5iaW5kO1xudmFyIGdldEJvdW5kcyA9IHV0aWxzLmdldEJvdW5kcztcbnZhciBwYXJzZUJhY2tncm91bmRzID0gdXRpbHMucGFyc2VCYWNrZ3JvdW5kcztcbnZhciBvZmZzZXRCb3VuZHMgPSB1dGlscy5vZmZzZXRCb3VuZHM7XG5cbmZ1bmN0aW9uIE5vZGVQYXJzZXIoZWxlbWVudCwgcmVuZGVyZXIsIHN1cHBvcnQsIGltYWdlTG9hZGVyLCBvcHRpb25zKSB7XG4gICAgbG9nKFwiU3RhcnRpbmcgTm9kZVBhcnNlclwiKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgIHRoaXMucmVuZGVyUXVldWUgPSBbXTtcbiAgICB0aGlzLnN0YWNrID0gbmV3IFN0YWNraW5nQ29udGV4dCh0cnVlLCAxLCBlbGVtZW50Lm93bmVyRG9jdW1lbnQsIG51bGwpO1xuICAgIHZhciBwYXJlbnQgPSBuZXcgTm9kZUNvbnRhaW5lcihlbGVtZW50LCBudWxsKTtcbiAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlY3RhbmdsZSgwLCAwLCByZW5kZXJlci53aWR0aCwgcmVuZGVyZXIuaGVpZ2h0LCBuZXcgQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kKSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50ID09PSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYmFja2dyb3VuZC8jc3BlY2lhbC1iYWNrZ3JvdW5kc1xuICAgICAgICB2YXIgY2FudmFzQmFja2dyb3VuZCA9IG5ldyBOb2RlQ29udGFpbmVyKHBhcmVudC5jb2xvcignYmFja2dyb3VuZENvbG9yJykuaXNUcmFuc3BhcmVudCgpID8gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHkgOiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBudWxsKTtcbiAgICAgICAgcmVuZGVyZXIucmVjdGFuZ2xlKDAsIDAsIHJlbmRlcmVyLndpZHRoLCByZW5kZXJlci5oZWlnaHQsIGNhbnZhc0JhY2tncm91bmQuY29sb3IoJ2JhY2tncm91bmRDb2xvcicpKTtcbiAgICB9XG4gICAgcGFyZW50LnZpc2liaWxlID0gcGFyZW50LmlzRWxlbWVudFZpc2libGUoKTtcbiAgICB0aGlzLmNyZWF0ZVBzZXVkb0hpZGVTdHlsZXMoZWxlbWVudC5vd25lckRvY3VtZW50KTtcbiAgICB0aGlzLmRpc2FibGVBbmltYXRpb25zKGVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgdGhpcy5ub2RlcyA9IGZsYXR0ZW4oW3BhcmVudF0uY29uY2F0KHRoaXMuZ2V0Q2hpbGRyZW4ocGFyZW50KSkuZmlsdGVyKGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLnZpc2libGUgPSBjb250YWluZXIuaXNFbGVtZW50VmlzaWJsZSgpO1xuICAgIH0pLm1hcCh0aGlzLmdldFBzZXVkb0VsZW1lbnRzLCB0aGlzKSk7XG4gICAgdGhpcy5mb250TWV0cmljcyA9IG5ldyBGb250TWV0cmljcygpO1xuICAgIGxvZyhcIkZldGNoZWQgbm9kZXMsIHRvdGFsOlwiLCB0aGlzLm5vZGVzLmxlbmd0aCk7XG4gICAgbG9nKFwiQ2FsY3VsYXRlIG92ZXJmbG93IGNsaXBzXCIpO1xuICAgIHRoaXMuY2FsY3VsYXRlT3ZlcmZsb3dDbGlwcygpO1xuICAgIGxvZyhcIlN0YXJ0IGZldGNoaW5nIGltYWdlc1wiKTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlTG9hZGVyLmZldGNoKHRoaXMubm9kZXMuZmlsdGVyKGlzRWxlbWVudCkpO1xuICAgIHRoaXMucmVhZHkgPSB0aGlzLmltYWdlcy5yZWFkeS50aGVuKGJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvZyhcIkltYWdlcyBsb2FkZWQsIHN0YXJ0aW5nIHBhcnNpbmdcIik7XG4gICAgICAgIGxvZyhcIkNyZWF0aW5nIHN0YWNraW5nIGNvbnRleHRzXCIpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN0YWNraW5nQ29udGV4dHMoKTtcbiAgICAgICAgbG9nKFwiU29ydGluZyBzdGFja2luZyBjb250ZXh0c1wiKTtcbiAgICAgICAgdGhpcy5zb3J0U3RhY2tpbmdDb250ZXh0cyh0aGlzLnN0YWNrKTtcbiAgICAgICAgdGhpcy5wYXJzZSh0aGlzLnN0YWNrKTtcbiAgICAgICAgbG9nKFwiUmVuZGVyIHF1ZXVlIGNyZWF0ZWQgd2l0aCBcIiArIHRoaXMucmVuZGVyUXVldWUubGVuZ3RoICsgXCIgaXRlbXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShiaW5kKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hc3luYykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUuZm9yRWFjaCh0aGlzLnBhaW50LCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihvcHRpb25zLmFzeW5jKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hc3luYy5jYWxsKHRoaXMsIHRoaXMucmVuZGVyUXVldWUsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbmRlclF1ZXVlLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNSZW5kZXJlcih0aGlzLnJlbmRlclF1ZXVlLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSwgdGhpcykpO1xufVxuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5jYWxjdWxhdGVPdmVyZmxvd0NsaXBzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoaXNFbGVtZW50KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIGlmIChpc1BzZXVkb0VsZW1lbnQoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRUb0RPTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLmJvcmRlcnMgPSB0aGlzLnBhcnNlQm9yZGVycyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGNsaXAgPSAoY29udGFpbmVyLmNzcygnb3ZlcmZsb3cnKSA9PT0gXCJoaWRkZW5cIikgPyBbY29udGFpbmVyLmJvcmRlcnMuY2xpcF0gOiBbXTtcbiAgICAgICAgICAgIHZhciBjc3NDbGlwID0gY29udGFpbmVyLnBhcnNlQ2xpcCgpO1xuICAgICAgICAgICAgaWYgKGNzc0NsaXAgJiYgW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKGNvbnRhaW5lci5jc3MoJ3Bvc2l0aW9uJykpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNsaXAucHVzaChbW1wicmVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmJvdW5kcy5sZWZ0ICsgY3NzQ2xpcC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmJvdW5kcy50b3AgKyBjc3NDbGlwLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc0NsaXAucmlnaHQgLSBjc3NDbGlwLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGlwLmJvdHRvbSAtIGNzc0NsaXAudG9wXG4gICAgICAgICAgICAgICAgXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLmNsaXAgPSBoYXNQYXJlbnRDbGlwKGNvbnRhaW5lcikgPyBjb250YWluZXIucGFyZW50LmNsaXAuY29uY2F0KGNsaXApIDogY2xpcDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5iYWNrZ3JvdW5kQ2xpcCA9IChjb250YWluZXIuY3NzKCdvdmVyZmxvdycpICE9PSBcImhpZGRlblwiKSA/IGNvbnRhaW5lci5jbGlwLmNvbmNhdChbY29udGFpbmVyLmJvcmRlcnMuY2xpcF0pIDogY29udGFpbmVyLmNsaXA7XG4gICAgICAgICAgICBpZiAoaXNQc2V1ZG9FbGVtZW50KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2xlYW5ET00oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1RleHROb2RlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGlwID0gaGFzUGFyZW50Q2xpcChjb250YWluZXIpID8gY29udGFpbmVyLnBhcmVudC5jbGlwIDogW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BzZXVkb0VsZW1lbnQoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIGhhc1BhcmVudENsaXAoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5wYXJlbnQgJiYgY29udGFpbmVyLnBhcmVudC5jbGlwLmxlbmd0aDtcbn1cblxuTm9kZVBhcnNlci5wcm90b3R5cGUuYXN5bmNSZW5kZXJlciA9IGZ1bmN0aW9uKHF1ZXVlLCByZXNvbHZlLCBhc3luY1RpbWVyKSB7XG4gICAgYXN5bmNUaW1lciA9IGFzeW5jVGltZXIgfHwgRGF0ZS5ub3coKTtcbiAgICB0aGlzLnBhaW50KHF1ZXVlW3RoaXMucmVuZGVySW5kZXgrK10pO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IHRoaXMucmVuZGVySW5kZXgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoYXN5bmNUaW1lciArIDIwID4gRGF0ZS5ub3coKSkge1xuICAgICAgICB0aGlzLmFzeW5jUmVuZGVyZXIocXVldWUsIHJlc29sdmUsIGFzeW5jVGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNSZW5kZXJlcihxdWV1ZSwgcmVzb2x2ZSk7XG4gICAgICAgIH0sIHRoaXMpLCAwKTtcbiAgICB9XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVQc2V1ZG9IaWRlU3R5bGVzID0gZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICB0aGlzLmNyZWF0ZVN0eWxlcyhkb2N1bWVudCwgJy4nICsgUHNldWRvRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuUFNFVURPX0hJREVfRUxFTUVOVF9DTEFTU19CRUZPUkUgKyAnOmJlZm9yZSB7IGNvbnRlbnQ6IFwiXCIgIWltcG9ydGFudDsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9JyArXG4gICAgICAgICcuJyArIFBzZXVkb0VsZW1lbnRDb250YWluZXIucHJvdG90eXBlLlBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQUZURVIgKyAnOmFmdGVyIHsgY29udGVudDogXCJcIiAhaW1wb3J0YW50OyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0nKTtcbn07XG5cbk5vZGVQYXJzZXIucHJvdG90eXBlLmRpc2FibGVBbmltYXRpb25zID0gZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICB0aGlzLmNyZWF0ZVN0eWxlcyhkb2N1bWVudCwgJyogeyAtd2Via2l0LWFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50OyAtbW96LWFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50OyAtby1hbmltYXRpb246IG5vbmUgIWltcG9ydGFudDsgYW5pbWF0aW9uOiBub25lICFpbXBvcnRhbnQ7ICcgK1xuICAgICAgICAnLXdlYmtpdC10cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7IC1tb3otdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50OyAtby10cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7IHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDt9Jyk7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVTdHlsZXMgPSBmdW5jdGlvbihkb2N1bWVudCwgc3R5bGVzKSB7XG4gICAgdmFyIGhpZGVQc2V1ZG9FbGVtZW50cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaGlkZVBzZXVkb0VsZW1lbnRzLmlubmVySFRNTCA9IHN0eWxlcztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhpZGVQc2V1ZG9FbGVtZW50cyk7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5nZXRQc2V1ZG9FbGVtZW50cyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBub2RlcyA9IFtbY29udGFpbmVyXV07XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5nZXRQc2V1ZG9FbGVtZW50KGNvbnRhaW5lciwgXCI6YmVmb3JlXCIpO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLmdldFBzZXVkb0VsZW1lbnQoY29udGFpbmVyLCBcIjphZnRlclwiKTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbGF0dGVuKG5vZGVzKTtcbn07XG5cbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcLVthLXpdKS9nLCBmdW5jdGlvbihtYXRjaCl7XG4gICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoJy0nLCcnKTtcbiAgICB9KTtcbn1cblxuTm9kZVBhcnNlci5wcm90b3R5cGUuZ2V0UHNldWRvRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgdHlwZSkge1xuICAgIHZhciBzdHlsZSA9IGNvbnRhaW5lci5jb21wdXRlZFN0eWxlKHR5cGUpO1xuICAgIGlmKCFzdHlsZSB8fCAhc3R5bGUuY29udGVudCB8fCBzdHlsZS5jb250ZW50ID09PSBcIm5vbmVcIiB8fCBzdHlsZS5jb250ZW50ID09PSBcIi1tb3otYWx0LWNvbnRlbnRcIiB8fCBzdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IHN0cmlwUXVvdGVzKHN0eWxlLmNvbnRlbnQpO1xuICAgIHZhciBpc0ltYWdlID0gY29udGVudC5zdWJzdHIoMCwgMykgPT09ICd1cmwnO1xuICAgIHZhciBwc2V1ZG9Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpc0ltYWdlID8gJ2ltZycgOiAnaHRtbDJjYW52YXNwc2V1ZG9lbGVtZW50Jyk7XG4gICAgdmFyIHBzZXVkb0NvbnRhaW5lciA9IG5ldyBQc2V1ZG9FbGVtZW50Q29udGFpbmVyKHBzZXVkb05vZGUsIGNvbnRhaW5lciwgdHlwZSk7XG5cbiAgICBmb3IgKHZhciBpID0gc3R5bGUubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHRvQ2FtZWxDYXNlKHN0eWxlLml0ZW0oaSkpO1xuICAgICAgICBwc2V1ZG9Ob2RlLnN0eWxlW3Byb3BlcnR5XSA9IHN0eWxlW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICBwc2V1ZG9Ob2RlLmNsYXNzTmFtZSA9IFBzZXVkb0VsZW1lbnRDb250YWluZXIucHJvdG90eXBlLlBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQkVGT1JFICsgXCIgXCIgKyBQc2V1ZG9FbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5QU0VVRE9fSElERV9FTEVNRU5UX0NMQVNTX0FGVEVSO1xuXG4gICAgaWYgKGlzSW1hZ2UpIHtcbiAgICAgICAgcHNldWRvTm9kZS5zcmMgPSBwYXJzZUJhY2tncm91bmRzKGNvbnRlbnQpWzBdLmFyZ3NbMF07XG4gICAgICAgIHJldHVybiBbcHNldWRvQ29udGFpbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpO1xuICAgICAgICBwc2V1ZG9Ob2RlLmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICByZXR1cm4gW3BzZXVkb0NvbnRhaW5lciwgbmV3IFRleHRDb250YWluZXIodGV4dCwgcHNldWRvQ29udGFpbmVyKV07XG4gICAgfVxufTtcblxuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKHBhcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBmbGF0dGVuKFtdLmZpbHRlci5jYWxsKHBhcmVudENvbnRhaW5lci5ub2RlLmNoaWxkTm9kZXMsIHJlbmRlcmFibGVOb2RlKS5tYXAoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gW25vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbmV3IFRleHRDb250YWluZXIobm9kZSwgcGFyZW50Q29udGFpbmVyKSA6IG5ldyBOb2RlQ29udGFpbmVyKG5vZGUsIHBhcmVudENvbnRhaW5lcildLmZpbHRlcihub25JZ25vcmVkRWxlbWVudCk7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIubGVuZ3RoICYmIG5vZGUudGFnTmFtZSAhPT0gXCJURVhUQVJFQVwiID8gKGNvbnRhaW5lclswXS5pc0VsZW1lbnRWaXNpYmxlKCkgPyBjb250YWluZXIuY29uY2F0KHRoaXMuZ2V0Q2hpbGRyZW4oY29udGFpbmVyWzBdKSkgOiBbXSkgOiBjb250YWluZXI7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTm9kZVBhcnNlci5wcm90b3R5cGUubmV3U3RhY2tpbmdDb250ZXh0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBoYXNPd25TdGFja2luZykge1xuICAgIHZhciBzdGFjayA9IG5ldyBTdGFja2luZ0NvbnRleHQoaGFzT3duU3RhY2tpbmcsIGNvbnRhaW5lci5nZXRPcGFjaXR5KCksIGNvbnRhaW5lci5ub2RlLCBjb250YWluZXIucGFyZW50KTtcbiAgICBjb250YWluZXIuY2xvbmVUbyhzdGFjayk7XG4gICAgdmFyIHBhcmVudFN0YWNrID0gaGFzT3duU3RhY2tpbmcgPyBzdGFjay5nZXRQYXJlbnRTdGFjayh0aGlzKSA6IHN0YWNrLnBhcmVudC5zdGFjaztcbiAgICBwYXJlbnRTdGFjay5jb250ZXh0cy5wdXNoKHN0YWNrKTtcbiAgICBjb250YWluZXIuc3RhY2sgPSBzdGFjaztcbn07XG5cbk5vZGVQYXJzZXIucHJvdG90eXBlLmNyZWF0ZVN0YWNraW5nQ29udGV4dHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoY29udGFpbmVyKSAmJiAodGhpcy5pc1Jvb3RFbGVtZW50KGNvbnRhaW5lcikgfHwgaGFzT3BhY2l0eShjb250YWluZXIpIHx8IGlzUG9zaXRpb25lZEZvclN0YWNraW5nKGNvbnRhaW5lcikgfHwgdGhpcy5pc0JvZHlXaXRoVHJhbnNwYXJlbnRSb290KGNvbnRhaW5lcikgfHwgY29udGFpbmVyLmhhc1RyYW5zZm9ybSgpKSkge1xuICAgICAgICAgICAgdGhpcy5uZXdTdGFja2luZ0NvbnRleHQoY29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY29udGFpbmVyKSAmJiAoKGlzUG9zaXRpb25lZChjb250YWluZXIpICYmIHpJbmRleDAoY29udGFpbmVyKSkgfHwgaXNJbmxpbmVCbG9jayhjb250YWluZXIpIHx8IGlzRmxvYXRpbmcoY29udGFpbmVyKSkpIHtcbiAgICAgICAgICAgIHRoaXMubmV3U3RhY2tpbmdDb250ZXh0KGNvbnRhaW5lciwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLmFzc2lnblN0YWNrKGNvbnRhaW5lci5wYXJlbnQuc3RhY2spO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5pc0JvZHlXaXRoVHJhbnNwYXJlbnRSb290ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5ub2RlLm5vZGVOYW1lID09PSBcIkJPRFlcIiAmJiBjb250YWluZXIucGFyZW50LmNvbG9yKCdiYWNrZ3JvdW5kQ29sb3InKS5pc1RyYW5zcGFyZW50KCk7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5pc1Jvb3RFbGVtZW50ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5wYXJlbnQgPT09IG51bGw7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5zb3J0U3RhY2tpbmdDb250ZXh0cyA9IGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgc3RhY2suY29udGV4dHMuc29ydCh6SW5kZXhTb3J0KHN0YWNrLmNvbnRleHRzLnNsaWNlKDApKSk7XG4gICAgc3RhY2suY29udGV4dHMuZm9yRWFjaCh0aGlzLnNvcnRTdGFja2luZ0NvbnRleHRzLCB0aGlzKTtcbn07XG5cbk5vZGVQYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dEJvdW5kcyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0ZXh0LCBpbmRleCwgdGV4dExpc3QpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnQuY3NzKFwidGV4dERlY29yYXRpb25cIikuc3Vic3RyKDAsIDQpICE9PSBcIm5vbmVcIiB8fCB0ZXh0LnRyaW0oKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnQucmFuZ2VCb3VuZHMgJiYgIWNvbnRhaW5lci5wYXJlbnQuaGFzVHJhbnNmb3JtKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGV4dExpc3Quc2xpY2UoMCwgaW5kZXgpLmpvaW4oXCJcIikubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlQm91bmRzKGNvbnRhaW5lci5ub2RlLCBvZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGUgJiYgdHlwZW9mKGNvbnRhaW5lci5ub2RlLmRhdGEpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50Tm9kZSA9IGNvbnRhaW5lci5ub2RlLnNwbGl0VGV4dCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0V3JhcHBlckJvdW5kcyhjb250YWluZXIubm9kZSwgY29udGFpbmVyLnBhcmVudC5oYXNUcmFuc2Zvcm0oKSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm5vZGUgPSByZXBsYWNlbWVudE5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCF0aGlzLnN1cHBvcnQucmFuZ2VCb3VuZHMgfHwgY29udGFpbmVyLnBhcmVudC5oYXNUcmFuc2Zvcm0oKSl7XG4gICAgICAgICAgICBjb250YWluZXIubm9kZSA9IGNvbnRhaW5lci5ub2RlLnNwbGl0VGV4dCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5nZXRXcmFwcGVyQm91bmRzID0gZnVuY3Rpb24obm9kZSwgdHJhbnNmb3JtKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaHRtbDJjYW52YXN3cmFwcGVyJyk7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgYmFja3VwVGV4dCA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZCh3cmFwcGVyLCBub2RlKTtcbiAgICB2YXIgYm91bmRzID0gdHJhbnNmb3JtID8gb2Zmc2V0Qm91bmRzKHdyYXBwZXIpIDogZ2V0Qm91bmRzKHdyYXBwZXIpO1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoYmFja3VwVGV4dCwgd3JhcHBlcik7XG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5cbk5vZGVQYXJzZXIucHJvdG90eXBlLmdldFJhbmdlQm91bmRzID0gZnVuY3Rpb24obm9kZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlIHx8ICh0aGlzLnJhbmdlID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgcmV0dXJuIHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufTtcblxuZnVuY3Rpb24gQ2xlYXJUcmFuc2Zvcm0oKSB7fVxuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvdmlzdXJlbi5odG1sI3otaW5kZXhcbiAgICB2YXIgbmVnYXRpdmVaaW5kZXggPSBzdGFjay5jb250ZXh0cy5maWx0ZXIobmVnYXRpdmVaSW5kZXgpOyAvLyAyLiB0aGUgY2hpbGQgc3RhY2tpbmcgY29udGV4dHMgd2l0aCBuZWdhdGl2ZSBzdGFjayBsZXZlbHMgKG1vc3QgbmVnYXRpdmUgZmlyc3QpLlxuICAgIHZhciBkZXNjZW5kYW50RWxlbWVudHMgPSBzdGFjay5jaGlsZHJlbi5maWx0ZXIoaXNFbGVtZW50KTtcbiAgICB2YXIgZGVzY2VuZGFudE5vbkZsb2F0cyA9IGRlc2NlbmRhbnRFbGVtZW50cy5maWx0ZXIobm90KGlzRmxvYXRpbmcpKTtcbiAgICB2YXIgbm9uSW5saW5lTm9uUG9zaXRpb25lZERlc2NlbmRhbnRzID0gZGVzY2VuZGFudE5vbkZsb2F0cy5maWx0ZXIobm90KGlzUG9zaXRpb25lZCkpLmZpbHRlcihub3QoaW5saW5lTGV2ZWwpKTsgLy8gMyB0aGUgaW4tZmxvdywgbm9uLWlubGluZS1sZXZlbCwgbm9uLXBvc2l0aW9uZWQgZGVzY2VuZGFudHMuXG4gICAgdmFyIG5vblBvc2l0aW9uZWRGbG9hdHMgPSBkZXNjZW5kYW50RWxlbWVudHMuZmlsdGVyKG5vdChpc1Bvc2l0aW9uZWQpKS5maWx0ZXIoaXNGbG9hdGluZyk7IC8vIDQuIHRoZSBub24tcG9zaXRpb25lZCBmbG9hdHMuXG4gICAgdmFyIGluRmxvdyA9IGRlc2NlbmRhbnROb25GbG9hdHMuZmlsdGVyKG5vdChpc1Bvc2l0aW9uZWQpKS5maWx0ZXIoaW5saW5lTGV2ZWwpOyAvLyA1LiB0aGUgaW4tZmxvdywgaW5saW5lLWxldmVsLCBub24tcG9zaXRpb25lZCBkZXNjZW5kYW50cywgaW5jbHVkaW5nIGlubGluZSB0YWJsZXMgYW5kIGlubGluZSBibG9ja3MuXG4gICAgdmFyIHN0YWNrTGV2ZWwwID0gc3RhY2suY29udGV4dHMuY29uY2F0KGRlc2NlbmRhbnROb25GbG9hdHMuZmlsdGVyKGlzUG9zaXRpb25lZCkpLmZpbHRlcih6SW5kZXgwKTsgLy8gNi4gdGhlIGNoaWxkIHN0YWNraW5nIGNvbnRleHRzIHdpdGggc3RhY2sgbGV2ZWwgMCBhbmQgdGhlIHBvc2l0aW9uZWQgZGVzY2VuZGFudHMgd2l0aCBzdGFjayBsZXZlbCAwLlxuICAgIHZhciB0ZXh0ID0gc3RhY2suY2hpbGRyZW4uZmlsdGVyKGlzVGV4dE5vZGUpLmZpbHRlcihoYXNUZXh0KTtcbiAgICB2YXIgcG9zaXRpdmVaaW5kZXggPSBzdGFjay5jb250ZXh0cy5maWx0ZXIocG9zaXRpdmVaSW5kZXgpOyAvLyA3LiB0aGUgY2hpbGQgc3RhY2tpbmcgY29udGV4dHMgd2l0aCBwb3NpdGl2ZSBzdGFjayBsZXZlbHMgKGxlYXN0IHBvc2l0aXZlIGZpcnN0KS5cbiAgICBuZWdhdGl2ZVppbmRleC5jb25jYXQobm9uSW5saW5lTm9uUG9zaXRpb25lZERlc2NlbmRhbnRzKS5jb25jYXQobm9uUG9zaXRpb25lZEZsb2F0cylcbiAgICAgICAgLmNvbmNhdChpbkZsb3cpLmNvbmNhdChzdGFja0xldmVsMCkuY29uY2F0KHRleHQpLmNvbmNhdChwb3NpdGl2ZVppbmRleCkuZm9yRWFjaChmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUucHVzaChjb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKGlzU3RhY2tpbmdDb250ZXh0KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5wdXNoKG5ldyBDbGVhclRyYW5zZm9ybSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5wYWludCA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBDbGVhclRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgaWYgKGlzUHNldWRvRWxlbWVudChjb250YWluZXIucGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJlbnQuYXBwZW5kVG9ET00oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpbnRUZXh0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoaXNQc2V1ZG9FbGVtZW50KGNvbnRhaW5lci5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudC5jbGVhbkRPTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vZGUoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsb2coZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTm9kZVBhcnNlci5wcm90b3R5cGUucGFpbnROb2RlID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgaWYgKGlzU3RhY2tpbmdDb250ZXh0KGNvbnRhaW5lcikpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRPcGFjaXR5KGNvbnRhaW5lci5vcGFjaXR5KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5jdHguc2F2ZSgpO1xuICAgICAgICBpZiAoY29udGFpbmVyLmhhc1RyYW5zZm9ybSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFRyYW5zZm9ybShjb250YWluZXIucGFyc2VUcmFuc2Zvcm0oKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyLm5vZGUubm9kZU5hbWUgPT09IFwiSU5QVVRcIiAmJiBjb250YWluZXIubm9kZS50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgdGhpcy5wYWludENoZWNrYm94KGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIGlmIChjb250YWluZXIubm9kZS5ub2RlTmFtZSA9PT0gXCJJTlBVVFwiICYmIGNvbnRhaW5lci5ub2RlLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgICB0aGlzLnBhaW50UmFkaW8oY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhaW50RWxlbWVudChjb250YWluZXIpO1xuICAgIH1cbn07XG5cbk5vZGVQYXJzZXIucHJvdG90eXBlLnBhaW50RWxlbWVudCA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBib3VuZHMgPSBjb250YWluZXIucGFyc2VCb3VuZHMoKTtcbiAgICB0aGlzLnJlbmRlcmVyLmNsaXAoY29udGFpbmVyLmJhY2tncm91bmRDbGlwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJCYWNrZ3JvdW5kKGNvbnRhaW5lciwgYm91bmRzLCBjb250YWluZXIuYm9yZGVycy5ib3JkZXJzLm1hcChnZXRXaWR0aCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5jbGlwKGNvbnRhaW5lci5jbGlwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJCb3JkZXJzKGNvbnRhaW5lci5ib3JkZXJzLmJvcmRlcnMpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5jbGlwKGNvbnRhaW5lci5iYWNrZ3JvdW5kQ2xpcCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAoY29udGFpbmVyLm5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICBjYXNlIFwiSUZSQU1FXCI6XG4gICAgICAgICAgICB2YXIgaW1nQ29udGFpbmVyID0gdGhpcy5pbWFnZXMuZ2V0KGNvbnRhaW5lci5ub2RlKTtcbiAgICAgICAgICAgIGlmIChpbWdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckltYWdlKGNvbnRhaW5lciwgYm91bmRzLCBjb250YWluZXIuYm9yZGVycywgaW1nQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRXJyb3IgbG9hZGluZyA8XCIgKyBjb250YWluZXIubm9kZS5ub2RlTmFtZSArIFwiPlwiLCBjb250YWluZXIubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIklNR1wiOlxuICAgICAgICAgICAgdmFyIGltYWdlQ29udGFpbmVyID0gdGhpcy5pbWFnZXMuZ2V0KGNvbnRhaW5lci5ub2RlLnNyYyk7XG4gICAgICAgICAgICBpZiAoaW1hZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckltYWdlKGNvbnRhaW5lciwgYm91bmRzLCBjb250YWluZXIuYm9yZGVycywgaW1hZ2VDb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2coXCJFcnJvciBsb2FkaW5nIDxpbWc+XCIsIGNvbnRhaW5lci5ub2RlLnNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBTlZBU1wiOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJJbWFnZShjb250YWluZXIsIGJvdW5kcywgY29udGFpbmVyLmJvcmRlcnMsIHtpbWFnZTogY29udGFpbmVyLm5vZGV9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU0VMRUNUXCI6XG4gICAgICAgIGNhc2UgXCJJTlBVVFwiOlxuICAgICAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgICAgICAgIHRoaXMucGFpbnRGb3JtVmFsdWUoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlUGFyc2VyLnByb3RvdHlwZS5wYWludENoZWNrYm94ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgdmFyIGIgPSBjb250YWluZXIucGFyc2VCb3VuZHMoKTtcblxuICAgIHZhciBzaXplID0gTWF0aC5taW4oYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgIHZhciBib3VuZHMgPSB7d2lkdGg6IHNpemUgLSAxLCBoZWlnaHQ6IHNpemUgLSAxLCB0b3A6IGIudG9wLCBsZWZ0OiBiLmxlZnR9O1xuICAgIHZhciByID0gWzMsIDNdO1xuICAgIHZhciByYWRpdXMgPSBbciwgciwgciwgcl07XG4gICAgdmFyIGJvcmRlcnMgPSBbMSwxLDEsMV0ubWFwKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogbmV3IENvbG9yKCcjQTVBNUE1JyksIHdpZHRoOiB3fTtcbiAgICB9KTtcblxuICAgIHZhciBib3JkZXJQb2ludHMgPSBjYWxjdWxhdGVDdXJ2ZVBvaW50cyhib3VuZHMsIHJhZGl1cywgYm9yZGVycyk7XG5cbiAgICB0aGlzLnJlbmRlcmVyLmNsaXAoY29udGFpbmVyLmJhY2tncm91bmRDbGlwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZWN0YW5nbGUoYm91bmRzLmxlZnQgKyAxLCBib3VuZHMudG9wICsgMSwgYm91bmRzLndpZHRoIC0gMiwgYm91bmRzLmhlaWdodCAtIDIsIG5ldyBDb2xvcihcIiNERURFREVcIikpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckJvcmRlcnMoY2FsY3VsYXRlQm9yZGVycyhib3JkZXJzLCBib3VuZHMsIGJvcmRlclBvaW50cywgcmFkaXVzKSk7XG4gICAgICAgIGlmIChjb250YWluZXIubm9kZS5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmZvbnQobmV3IENvbG9yKCcjNDI0MjQyJyksICdub3JtYWwnLCAnbm9ybWFsJywgJ2JvbGQnLCAoc2l6ZSAtIDMpICsgXCJweFwiLCAnYXJpYWwnKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dChcIlxcdTI3MTRcIiwgYm91bmRzLmxlZnQgKyBzaXplIC8gNiwgYm91bmRzLnRvcCArIHNpemUgLSAxKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xufTtcblxuTm9kZVBhcnNlci5wcm90b3R5cGUucGFpbnRSYWRpbyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBib3VuZHMgPSBjb250YWluZXIucGFyc2VCb3VuZHMoKTtcblxuICAgIHZhciBzaXplID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KSAtIDI7XG5cbiAgICB0aGlzLnJlbmRlcmVyLmNsaXAoY29udGFpbmVyLmJhY2tncm91bmRDbGlwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5jaXJjbGVTdHJva2UoYm91bmRzLmxlZnQgKyAxLCBib3VuZHMudG9wICsgMSwgc2l6ZSwgbmV3IENvbG9yKCcjREVERURFJyksIDEsIG5ldyBDb2xvcignI0E1QTVBNScpKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuY2lyY2xlKE1hdGguY2VpbChib3VuZHMubGVmdCArIHNpemUgLyA0KSArIDEsIE1hdGguY2VpbChib3VuZHMudG9wICsgc2l6ZSAvIDQpICsgMSwgTWF0aC5mbG9vcihzaXplIC8gMiksIG5ldyBDb2xvcignIzQyNDI0MicpKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xufTtcblxuTm9kZVBhcnNlci5wcm90b3R5cGUucGFpbnRGb3JtVmFsdWUgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250YWluZXIuZ2V0VmFsdWUoKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSBjb250YWluZXIubm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2h0bWwyY2FudmFzd3JhcHBlcicpO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IFsnbGluZUhlaWdodCcsICd0ZXh0QWxpZ24nLCAnZm9udEZhbWlseScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2NvbG9yJyxcbiAgICAgICAgICAgICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJyxcbiAgICAgICAgICAgICd3aWR0aCcsICdoZWlnaHQnLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJUb3BXaWR0aCcsXG4gICAgICAgICAgICAnYm94U2l6aW5nJywgJ3doaXRlU3BhY2UnLCAnd29yZFdyYXAnXTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZVtwcm9wZXJ0eV0gPSBjb250YWluZXIuY3NzKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIC8vIE9sZGVyIElFIGhhcyBpc3N1ZXMgd2l0aCBcImJvcmRlclwiXG4gICAgICAgICAgICAgICAgbG9nKFwiaHRtbDJjYW52YXM6IFBhcnNlOiBFeGNlcHRpb24gY2F1Z2h0IGluIHJlbmRlckZvcm1WYWx1ZTogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGNvbnRhaW5lci5wYXJzZUJvdW5kcygpO1xuICAgICAgICB3cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICB3cmFwcGVyLnN0eWxlLmxlZnQgPSBib3VuZHMubGVmdCArIFwicHhcIjtcbiAgICAgICAgd3JhcHBlci5zdHlsZS50b3AgPSBib3VuZHMudG9wICsgXCJweFwiO1xuICAgICAgICB3cmFwcGVyLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIHRoaXMucGFpbnRUZXh0KG5ldyBUZXh0Q29udGFpbmVyKHdyYXBwZXIuZmlyc3RDaGlsZCwgY29udGFpbmVyKSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgfVxufTtcblxuTm9kZVBhcnNlci5wcm90b3R5cGUucGFpbnRUZXh0ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLmFwcGx5VGV4dFRyYW5zZm9ybSgpO1xuICAgIHZhciBjaGFyYWN0ZXJzID0gcHVueWNvZGUudWNzMi5kZWNvZGUoY29udGFpbmVyLm5vZGUuZGF0YSk7XG4gICAgdmFyIHRleHRMaXN0ID0gKCF0aGlzLm9wdGlvbnMubGV0dGVyUmVuZGVyaW5nIHx8IG5vTGV0dGVyU3BhY2luZyhjb250YWluZXIpKSAmJiAhaGFzVW5pY29kZShjb250YWluZXIubm9kZS5kYXRhKSA/IGdldFdvcmRzKGNoYXJhY3RlcnMpIDogY2hhcmFjdGVycy5tYXAoZnVuY3Rpb24oY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiBwdW55Y29kZS51Y3MyLmVuY29kZShbY2hhcmFjdGVyXSk7XG4gICAgfSk7XG5cbiAgICB2YXIgd2VpZ2h0ID0gY29udGFpbmVyLnBhcmVudC5mb250V2VpZ2h0KCk7XG4gICAgdmFyIHNpemUgPSBjb250YWluZXIucGFyZW50LmNzcygnZm9udFNpemUnKTtcbiAgICB2YXIgZmFtaWx5ID0gY29udGFpbmVyLnBhcmVudC5jc3MoJ2ZvbnRGYW1pbHknKTtcbiAgICB2YXIgc2hhZG93cyA9IGNvbnRhaW5lci5wYXJlbnQucGFyc2VUZXh0U2hhZG93cygpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5mb250KGNvbnRhaW5lci5wYXJlbnQuY29sb3IoJ2NvbG9yJyksIGNvbnRhaW5lci5wYXJlbnQuY3NzKCdmb250U3R5bGUnKSwgY29udGFpbmVyLnBhcmVudC5jc3MoJ2ZvbnRWYXJpYW50JyksIHdlaWdodCwgc2l6ZSwgZmFtaWx5KTtcbiAgICBpZiAoc2hhZG93cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBtdWx0aXBsZSB0ZXh0IHNoYWRvd3NcbiAgICAgICAgdGhpcy5yZW5kZXJlci5mb250U2hhZG93KHNoYWRvd3NbMF0uY29sb3IsIHNoYWRvd3NbMF0ub2Zmc2V0WCwgc2hhZG93c1swXS5vZmZzZXRZLCBzaGFkb3dzWzBdLmJsdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY2xlYXJTaGFkb3coKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVyLmNsaXAoY29udGFpbmVyLnBhcmVudC5jbGlwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGV4dExpc3QubWFwKHRoaXMucGFyc2VUZXh0Qm91bmRzKGNvbnRhaW5lciksIHRoaXMpLmZvckVhY2goZnVuY3Rpb24oYm91bmRzLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dCh0ZXh0TGlzdFtpbmRleF0sIGJvdW5kcy5sZWZ0LCBib3VuZHMuYm90dG9tKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRleHREZWNvcmF0aW9uKGNvbnRhaW5lci5wYXJlbnQsIGJvdW5kcywgdGhpcy5mb250TWV0cmljcy5nZXRNZXRyaWNzKGZhbWlseSwgc2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbk5vZGVQYXJzZXIucHJvdG90eXBlLnJlbmRlclRleHREZWNvcmF0aW9uID0gZnVuY3Rpb24oY29udGFpbmVyLCBib3VuZHMsIG1ldHJpY3MpIHtcbiAgICBzd2l0Y2goY29udGFpbmVyLmNzcyhcInRleHREZWNvcmF0aW9uXCIpLnNwbGl0KFwiIFwiKVswXSkge1xuICAgIGNhc2UgXCJ1bmRlcmxpbmVcIjpcbiAgICAgICAgLy8gRHJhd3MgYSBsaW5lIGF0IHRoZSBiYXNlbGluZSBvZiB0aGUgZm9udFxuICAgICAgICAvLyBUT0RPIEFzIHNvbWUgYnJvd3NlcnMgZGlzcGxheSB0aGUgbGluZSBhcyBtb3JlIHRoYW4gMXB4IGlmIHRoZSBmb250LXNpemUgaXMgYmlnLCBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnQgYm90aCBpbiBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlY3RhbmdsZShib3VuZHMubGVmdCwgTWF0aC5yb3VuZChib3VuZHMudG9wICsgbWV0cmljcy5iYXNlbGluZSArIG1ldHJpY3MubGluZVdpZHRoKSwgYm91bmRzLndpZHRoLCAxLCBjb250YWluZXIuY29sb3IoXCJjb2xvclwiKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvdmVybGluZVwiOlxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlY3RhbmdsZShib3VuZHMubGVmdCwgTWF0aC5yb3VuZChib3VuZHMudG9wKSwgYm91bmRzLndpZHRoLCAxLCBjb250YWluZXIuY29sb3IoXCJjb2xvclwiKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsaW5lLXRocm91Z2hcIjpcbiAgICAgICAgLy8gVE9ETyB0cnkgYW5kIGZpbmQgZXhhY3QgcG9zaXRpb24gZm9yIGxpbmUtdGhyb3VnaFxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlY3RhbmdsZShib3VuZHMubGVmdCwgTWF0aC5jZWlsKGJvdW5kcy50b3AgKyBtZXRyaWNzLm1pZGRsZSArIG1ldHJpY3MubGluZVdpZHRoKSwgYm91bmRzLndpZHRoLCAxLCBjb250YWluZXIuY29sb3IoXCJjb2xvclwiKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbnZhciBib3JkZXJDb2xvclRyYW5zZm9ybXMgPSB7XG4gICAgaW5zZXQ6IFtcbiAgICAgICAgW1wiZGFya2VuXCIsIDAuNjBdLFxuICAgICAgICBbXCJkYXJrZW5cIiwgMC4xMF0sXG4gICAgICAgIFtcImRhcmtlblwiLCAwLjEwXSxcbiAgICAgICAgW1wiZGFya2VuXCIsIDAuNjBdXG4gICAgXVxufTtcblxuTm9kZVBhcnNlci5wcm90b3R5cGUucGFyc2VCb3JkZXJzID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgdmFyIG5vZGVCb3VuZHMgPSBjb250YWluZXIucGFyc2VCb3VuZHMoKTtcbiAgICB2YXIgcmFkaXVzID0gZ2V0Qm9yZGVyUmFkaXVzRGF0YShjb250YWluZXIpO1xuICAgIHZhciBib3JkZXJzID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLm1hcChmdW5jdGlvbihzaWRlLCBpbmRleCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBjb250YWluZXIuY3NzKCdib3JkZXInICsgc2lkZSArICdTdHlsZScpO1xuICAgICAgICB2YXIgY29sb3IgPSBjb250YWluZXIuY29sb3IoJ2JvcmRlcicgKyBzaWRlICsgJ0NvbG9yJyk7XG4gICAgICAgIGlmIChzdHlsZSA9PT0gXCJpbnNldFwiICYmIGNvbG9yLmlzQmxhY2soKSkge1xuICAgICAgICAgICAgY29sb3IgPSBuZXcgQ29sb3IoWzI1NSwgMjU1LCAyNTUsIGNvbG9yLmFdKTsgLy8gdGhpcyBpcyB3cm9uZywgYnV0XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yVHJhbnNmb3JtID0gYm9yZGVyQ29sb3JUcmFuc2Zvcm1zW3N0eWxlXSA/IGJvcmRlckNvbG9yVHJhbnNmb3Jtc1tzdHlsZV1baW5kZXhdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBjb250YWluZXIuY3NzSW50KCdib3JkZXInICsgc2lkZSArICdXaWR0aCcpLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yVHJhbnNmb3JtID8gY29sb3JbY29sb3JUcmFuc2Zvcm1bMF1dKGNvbG9yVHJhbnNmb3JtWzFdKSA6IGNvbG9yLFxuICAgICAgICAgICAgYXJnczogbnVsbFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBib3JkZXJQb2ludHMgPSBjYWxjdWxhdGVDdXJ2ZVBvaW50cyhub2RlQm91bmRzLCByYWRpdXMsIGJvcmRlcnMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xpcDogdGhpcy5wYXJzZUJhY2tncm91bmRDbGlwKGNvbnRhaW5lciwgYm9yZGVyUG9pbnRzLCBib3JkZXJzLCByYWRpdXMsIG5vZGVCb3VuZHMpLFxuICAgICAgICBib3JkZXJzOiBjYWxjdWxhdGVCb3JkZXJzKGJvcmRlcnMsIG5vZGVCb3VuZHMsIGJvcmRlclBvaW50cywgcmFkaXVzKVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3JkZXJzKGJvcmRlcnMsIG5vZGVCb3VuZHMsIGJvcmRlclBvaW50cywgcmFkaXVzKSB7XG4gICAgcmV0dXJuIGJvcmRlcnMubWFwKGZ1bmN0aW9uKGJvcmRlciwgYm9yZGVyU2lkZSkge1xuICAgICAgICBpZiAoYm9yZGVyLndpZHRoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJ4ID0gbm9kZUJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgdmFyIGJ5ID0gbm9kZUJvdW5kcy50b3A7XG4gICAgICAgICAgICB2YXIgYncgPSBub2RlQm91bmRzLndpZHRoO1xuICAgICAgICAgICAgdmFyIGJoID0gbm9kZUJvdW5kcy5oZWlnaHQgLSAoYm9yZGVyc1syXS53aWR0aCk7XG5cbiAgICAgICAgICAgIHN3aXRjaChib3JkZXJTaWRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gdG9wIGJvcmRlclxuICAgICAgICAgICAgICAgIGJoID0gYm9yZGVyc1swXS53aWR0aDtcbiAgICAgICAgICAgICAgICBib3JkZXIuYXJncyA9IGRyYXdTaWRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxOiBbYngsIGJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyOiBbYnggKyBidywgYnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzM6IFtieCArIGJ3IC0gYm9yZGVyc1sxXS53aWR0aCwgYnkgKyBiaF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjNDogW2J4ICsgYm9yZGVyc1szXS53aWR0aCwgYnkgKyBiaF1cbiAgICAgICAgICAgICAgICAgICAgfSwgcmFkaXVzWzBdLCByYWRpdXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclBvaW50cy50b3BMZWZ0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BMZWZ0SW5uZXIsIGJvcmRlclBvaW50cy50b3BSaWdodE91dGVyLCBib3JkZXJQb2ludHMudG9wUmlnaHRJbm5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgYm9yZGVyXG4gICAgICAgICAgICAgICAgYnggPSBub2RlQm91bmRzLmxlZnQgKyBub2RlQm91bmRzLndpZHRoIC0gKGJvcmRlcnNbMV0ud2lkdGgpO1xuICAgICAgICAgICAgICAgIGJ3ID0gYm9yZGVyc1sxXS53aWR0aDtcblxuICAgICAgICAgICAgICAgIGJvcmRlci5hcmdzID0gZHJhd1NpZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYzE6IFtieCArIGJ3LCBieV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjMjogW2J4ICsgYncsIGJ5ICsgYmggKyBib3JkZXJzWzJdLndpZHRoXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMzOiBbYngsIGJ5ICsgYmhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzQ6IFtieCwgYnkgKyBib3JkZXJzWzBdLndpZHRoXVxuICAgICAgICAgICAgICAgICAgICB9LCByYWRpdXNbMV0sIHJhZGl1c1syXSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUG9pbnRzLnRvcFJpZ2h0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BSaWdodElubmVyLCBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbVJpZ2h0SW5uZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vIGJvdHRvbSBib3JkZXJcbiAgICAgICAgICAgICAgICBieSA9IChieSArIG5vZGVCb3VuZHMuaGVpZ2h0KSAtIChib3JkZXJzWzJdLndpZHRoKTtcbiAgICAgICAgICAgICAgICBiaCA9IGJvcmRlcnNbMl0ud2lkdGg7XG4gICAgICAgICAgICAgICAgYm9yZGVyLmFyZ3MgPSBkcmF3U2lkZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMTogW2J4ICsgYncsIGJ5ICsgYmhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzI6IFtieCwgYnkgKyBiaF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjMzogW2J4ICsgYm9yZGVyc1szXS53aWR0aCwgYnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzQ6IFtieCArIGJ3IC0gYm9yZGVyc1szXS53aWR0aCwgYnldXG4gICAgICAgICAgICAgICAgICAgIH0sIHJhZGl1c1syXSwgcmFkaXVzWzNdLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJQb2ludHMuYm90dG9tUmlnaHRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbVJpZ2h0SW5uZXIsIGJvcmRlclBvaW50cy5ib3R0b21MZWZ0T3V0ZXIsIGJvcmRlclBvaW50cy5ib3R0b21MZWZ0SW5uZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vIGxlZnQgYm9yZGVyXG4gICAgICAgICAgICAgICAgYncgPSBib3JkZXJzWzNdLndpZHRoO1xuICAgICAgICAgICAgICAgIGJvcmRlci5hcmdzID0gZHJhd1NpZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYzE6IFtieCwgYnkgKyBiaCArIGJvcmRlcnNbMl0ud2lkdGhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzI6IFtieCwgYnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzM6IFtieCArIGJ3LCBieSArIGJvcmRlcnNbMF0ud2lkdGhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzQ6IFtieCArIGJ3LCBieSArIGJoXVxuICAgICAgICAgICAgICAgICAgICB9LCByYWRpdXNbM10sIHJhZGl1c1swXSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRJbm5lciwgYm9yZGVyUG9pbnRzLnRvcExlZnRPdXRlciwgYm9yZGVyUG9pbnRzLnRvcExlZnRJbm5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9KTtcbn1cblxuTm9kZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYWNrZ3JvdW5kQ2xpcCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgYm9yZGVyUG9pbnRzLCBib3JkZXJzLCByYWRpdXMsIGJvdW5kcykge1xuICAgIHZhciBiYWNrZ3JvdW5kQ2xpcCA9IGNvbnRhaW5lci5jc3MoJ2JhY2tncm91bmRDbGlwJyksXG4gICAgICAgIGJvcmRlckFyZ3MgPSBbXTtcblxuICAgIHN3aXRjaChiYWNrZ3JvdW5kQ2xpcCkge1xuICAgIGNhc2UgXCJjb250ZW50LWJveFwiOlxuICAgIGNhc2UgXCJwYWRkaW5nLWJveFwiOlxuICAgICAgICBwYXJzZUNvcm5lcihib3JkZXJBcmdzLCByYWRpdXNbMF0sIHJhZGl1c1sxXSwgYm9yZGVyUG9pbnRzLnRvcExlZnRJbm5lciwgYm9yZGVyUG9pbnRzLnRvcFJpZ2h0SW5uZXIsIGJvdW5kcy5sZWZ0ICsgYm9yZGVyc1szXS53aWR0aCwgYm91bmRzLnRvcCArIGJvcmRlcnNbMF0ud2lkdGgpO1xuICAgICAgICBwYXJzZUNvcm5lcihib3JkZXJBcmdzLCByYWRpdXNbMV0sIHJhZGl1c1syXSwgYm9yZGVyUG9pbnRzLnRvcFJpZ2h0SW5uZXIsIGJvcmRlclBvaW50cy5ib3R0b21SaWdodElubmVyLCBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIGJvcmRlcnNbMV0ud2lkdGgsIGJvdW5kcy50b3AgKyBib3JkZXJzWzBdLndpZHRoKTtcbiAgICAgICAgcGFyc2VDb3JuZXIoYm9yZGVyQXJncywgcmFkaXVzWzJdLCByYWRpdXNbM10sIGJvcmRlclBvaW50cy5ib3R0b21SaWdodElubmVyLCBib3JkZXJQb2ludHMuYm90dG9tTGVmdElubmVyLCBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIGJvcmRlcnNbMV0ud2lkdGgsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gYm9yZGVyc1syXS53aWR0aCk7XG4gICAgICAgIHBhcnNlQ29ybmVyKGJvcmRlckFyZ3MsIHJhZGl1c1szXSwgcmFkaXVzWzBdLCBib3JkZXJQb2ludHMuYm90dG9tTGVmdElubmVyLCBib3JkZXJQb2ludHMudG9wTGVmdElubmVyLCBib3VuZHMubGVmdCArIGJvcmRlcnNbM10ud2lkdGgsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gYm9yZGVyc1syXS53aWR0aCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgICAgcGFyc2VDb3JuZXIoYm9yZGVyQXJncywgcmFkaXVzWzBdLCByYWRpdXNbMV0sIGJvcmRlclBvaW50cy50b3BMZWZ0T3V0ZXIsIGJvcmRlclBvaW50cy50b3BSaWdodE91dGVyLCBib3VuZHMubGVmdCwgYm91bmRzLnRvcCk7XG4gICAgICAgIHBhcnNlQ29ybmVyKGJvcmRlckFyZ3MsIHJhZGl1c1sxXSwgcmFkaXVzWzJdLCBib3JkZXJQb2ludHMudG9wUmlnaHRPdXRlciwgYm9yZGVyUG9pbnRzLmJvdHRvbVJpZ2h0T3V0ZXIsIGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoLCBib3VuZHMudG9wKTtcbiAgICAgICAgcGFyc2VDb3JuZXIoYm9yZGVyQXJncywgcmFkaXVzWzJdLCByYWRpdXNbM10sIGJvcmRlclBvaW50cy5ib3R0b21SaWdodE91dGVyLCBib3JkZXJQb2ludHMuYm90dG9tTGVmdE91dGVyLCBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCwgYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICBwYXJzZUNvcm5lcihib3JkZXJBcmdzLCByYWRpdXNbM10sIHJhZGl1c1swXSwgYm9yZGVyUG9pbnRzLmJvdHRvbUxlZnRPdXRlciwgYm9yZGVyUG9pbnRzLnRvcExlZnRPdXRlciwgYm91bmRzLmxlZnQsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvcmRlckFyZ3M7XG59O1xuXG5mdW5jdGlvbiBnZXRDdXJ2ZVBvaW50cyh4LCB5LCByMSwgcjIpIHtcbiAgICB2YXIga2FwcGEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgIHZhciBveCA9IChyMSkgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgICBveSA9IChyMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgeG0gPSB4ICsgcjEsIC8vIHgtbWlkZGxlXG4gICAgICAgIHltID0geSArIHIyOyAvLyB5LW1pZGRsZVxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcExlZnQ6IGJlemllckN1cnZlKHt4OiB4LCB5OiB5bX0sIHt4OiB4LCB5OiB5bSAtIG95fSwge3g6IHhtIC0gb3gsIHk6IHl9LCB7eDogeG0sIHk6IHl9KSxcbiAgICAgICAgdG9wUmlnaHQ6IGJlemllckN1cnZlKHt4OiB4LCB5OiB5fSwge3g6IHggKyBveCx5OiB5fSwge3g6IHhtLCB5OiB5bSAtIG95fSwge3g6IHhtLCB5OiB5bX0pLFxuICAgICAgICBib3R0b21SaWdodDogYmV6aWVyQ3VydmUoe3g6IHhtLCB5OiB5fSwge3g6IHhtLCB5OiB5ICsgb3l9LCB7eDogeCArIG94LCB5OiB5bX0sIHt4OiB4LCB5OiB5bX0pLFxuICAgICAgICBib3R0b21MZWZ0OiBiZXppZXJDdXJ2ZSh7eDogeG0sIHk6IHltfSwge3g6IHhtIC0gb3gsIHk6IHltfSwge3g6IHgsIHk6IHkgKyBveX0sIHt4OiB4LCB5Onl9KVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUN1cnZlUG9pbnRzKGJvdW5kcywgYm9yZGVyUmFkaXVzLCBib3JkZXJzKSB7XG4gICAgdmFyIHggPSBib3VuZHMubGVmdCxcbiAgICAgICAgeSA9IGJvdW5kcy50b3AsXG4gICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LFxuXG4gICAgICAgIHRsaCA9IGJvcmRlclJhZGl1c1swXVswXSA8IHdpZHRoIC8gMiA/IGJvcmRlclJhZGl1c1swXVswXSA6IHdpZHRoIC8gMixcbiAgICAgICAgdGx2ID0gYm9yZGVyUmFkaXVzWzBdWzFdIDwgaGVpZ2h0IC8gMiA/IGJvcmRlclJhZGl1c1swXVsxXSA6IGhlaWdodCAvIDIsXG4gICAgICAgIHRyaCA9IGJvcmRlclJhZGl1c1sxXVswXSA8IHdpZHRoIC8gMiA/IGJvcmRlclJhZGl1c1sxXVswXSA6IHdpZHRoIC8gMixcbiAgICAgICAgdHJ2ID0gYm9yZGVyUmFkaXVzWzFdWzFdIDwgaGVpZ2h0IC8gMiA/IGJvcmRlclJhZGl1c1sxXVsxXSA6IGhlaWdodCAvIDIsXG4gICAgICAgIGJyaCA9IGJvcmRlclJhZGl1c1syXVswXSA8IHdpZHRoIC8gMiA/IGJvcmRlclJhZGl1c1syXVswXSA6IHdpZHRoIC8gMixcbiAgICAgICAgYnJ2ID0gYm9yZGVyUmFkaXVzWzJdWzFdIDwgaGVpZ2h0IC8gMiA/IGJvcmRlclJhZGl1c1syXVsxXSA6IGhlaWdodCAvIDIsXG4gICAgICAgIGJsaCA9IGJvcmRlclJhZGl1c1szXVswXSA8IHdpZHRoIC8gMiA/IGJvcmRlclJhZGl1c1szXVswXSA6IHdpZHRoIC8gMixcbiAgICAgICAgYmx2ID0gYm9yZGVyUmFkaXVzWzNdWzFdIDwgaGVpZ2h0IC8gMiA/IGJvcmRlclJhZGl1c1szXVsxXSA6IGhlaWdodCAvIDI7XG5cbiAgICB2YXIgdG9wV2lkdGggPSB3aWR0aCAtIHRyaCxcbiAgICAgICAgcmlnaHRIZWlnaHQgPSBoZWlnaHQgLSBicnYsXG4gICAgICAgIGJvdHRvbVdpZHRoID0gd2lkdGggLSBicmgsXG4gICAgICAgIGxlZnRIZWlnaHQgPSBoZWlnaHQgLSBibHY7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3BMZWZ0T3V0ZXI6IGdldEN1cnZlUG9pbnRzKHgsIHksIHRsaCwgdGx2KS50b3BMZWZ0LnN1YmRpdmlkZSgwLjUpLFxuICAgICAgICB0b3BMZWZ0SW5uZXI6IGdldEN1cnZlUG9pbnRzKHggKyBib3JkZXJzWzNdLndpZHRoLCB5ICsgYm9yZGVyc1swXS53aWR0aCwgTWF0aC5tYXgoMCwgdGxoIC0gYm9yZGVyc1szXS53aWR0aCksIE1hdGgubWF4KDAsIHRsdiAtIGJvcmRlcnNbMF0ud2lkdGgpKS50b3BMZWZ0LnN1YmRpdmlkZSgwLjUpLFxuICAgICAgICB0b3BSaWdodE91dGVyOiBnZXRDdXJ2ZVBvaW50cyh4ICsgdG9wV2lkdGgsIHksIHRyaCwgdHJ2KS50b3BSaWdodC5zdWJkaXZpZGUoMC41KSxcbiAgICAgICAgdG9wUmlnaHRJbm5lcjogZ2V0Q3VydmVQb2ludHMoeCArIE1hdGgubWluKHRvcFdpZHRoLCB3aWR0aCArIGJvcmRlcnNbM10ud2lkdGgpLCB5ICsgYm9yZGVyc1swXS53aWR0aCwgKHRvcFdpZHRoID4gd2lkdGggKyBib3JkZXJzWzNdLndpZHRoKSA/IDAgOnRyaCAtIGJvcmRlcnNbM10ud2lkdGgsIHRydiAtIGJvcmRlcnNbMF0ud2lkdGgpLnRvcFJpZ2h0LnN1YmRpdmlkZSgwLjUpLFxuICAgICAgICBib3R0b21SaWdodE91dGVyOiBnZXRDdXJ2ZVBvaW50cyh4ICsgYm90dG9tV2lkdGgsIHkgKyByaWdodEhlaWdodCwgYnJoLCBicnYpLmJvdHRvbVJpZ2h0LnN1YmRpdmlkZSgwLjUpLFxuICAgICAgICBib3R0b21SaWdodElubmVyOiBnZXRDdXJ2ZVBvaW50cyh4ICsgTWF0aC5taW4oYm90dG9tV2lkdGgsIHdpZHRoIC0gYm9yZGVyc1szXS53aWR0aCksIHkgKyBNYXRoLm1pbihyaWdodEhlaWdodCwgaGVpZ2h0ICsgYm9yZGVyc1swXS53aWR0aCksIE1hdGgubWF4KDAsIGJyaCAtIGJvcmRlcnNbMV0ud2lkdGgpLCAgYnJ2IC0gYm9yZGVyc1syXS53aWR0aCkuYm90dG9tUmlnaHQuc3ViZGl2aWRlKDAuNSksXG4gICAgICAgIGJvdHRvbUxlZnRPdXRlcjogZ2V0Q3VydmVQb2ludHMoeCwgeSArIGxlZnRIZWlnaHQsIGJsaCwgYmx2KS5ib3R0b21MZWZ0LnN1YmRpdmlkZSgwLjUpLFxuICAgICAgICBib3R0b21MZWZ0SW5uZXI6IGdldEN1cnZlUG9pbnRzKHggKyBib3JkZXJzWzNdLndpZHRoLCB5ICsgbGVmdEhlaWdodCwgTWF0aC5tYXgoMCwgYmxoIC0gYm9yZGVyc1szXS53aWR0aCksIGJsdiAtIGJvcmRlcnNbMl0ud2lkdGgpLmJvdHRvbUxlZnQuc3ViZGl2aWRlKDAuNSlcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBiZXppZXJDdXJ2ZShzdGFydCwgc3RhcnRDb250cm9sLCBlbmRDb250cm9sLCBlbmQpIHtcbiAgICB2YXIgbGVycCA9IGZ1bmN0aW9uIChhLCBiLCB0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBhLnggKyAoYi54IC0gYS54KSAqIHQsXG4gICAgICAgICAgICB5OiBhLnkgKyAoYi55IC0gYS55KSAqIHRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBzdGFydENvbnRyb2w6IHN0YXJ0Q29udHJvbCxcbiAgICAgICAgZW5kQ29udHJvbDogZW5kQ29udHJvbCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIHN1YmRpdmlkZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdmFyIGFiID0gbGVycChzdGFydCwgc3RhcnRDb250cm9sLCB0KSxcbiAgICAgICAgICAgICAgICBiYyA9IGxlcnAoc3RhcnRDb250cm9sLCBlbmRDb250cm9sLCB0KSxcbiAgICAgICAgICAgICAgICBjZCA9IGxlcnAoZW5kQ29udHJvbCwgZW5kLCB0KSxcbiAgICAgICAgICAgICAgICBhYmJjID0gbGVycChhYiwgYmMsIHQpLFxuICAgICAgICAgICAgICAgIGJjY2QgPSBsZXJwKGJjLCBjZCwgdCksXG4gICAgICAgICAgICAgICAgZGVzdCA9IGxlcnAoYWJiYywgYmNjZCwgdCk7XG4gICAgICAgICAgICByZXR1cm4gW2JlemllckN1cnZlKHN0YXJ0LCBhYiwgYWJiYywgZGVzdCksIGJlemllckN1cnZlKGRlc3QsIGJjY2QsIGNkLCBlbmQpXTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VydmVUbzogZnVuY3Rpb24oYm9yZGVyQXJncykge1xuICAgICAgICAgICAgYm9yZGVyQXJncy5wdXNoKFtcImJlemllckN1cnZlXCIsIHN0YXJ0Q29udHJvbC54LCBzdGFydENvbnRyb2wueSwgZW5kQ29udHJvbC54LCBlbmRDb250cm9sLnksIGVuZC54LCBlbmQueV0pO1xuICAgICAgICB9LFxuICAgICAgICBjdXJ2ZVRvUmV2ZXJzZWQ6IGZ1bmN0aW9uKGJvcmRlckFyZ3MpIHtcbiAgICAgICAgICAgIGJvcmRlckFyZ3MucHVzaChbXCJiZXppZXJDdXJ2ZVwiLCBlbmRDb250cm9sLngsIGVuZENvbnRyb2wueSwgc3RhcnRDb250cm9sLngsIHN0YXJ0Q29udHJvbC55LCBzdGFydC54LCBzdGFydC55XSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3U2lkZShib3JkZXJEYXRhLCByYWRpdXMxLCByYWRpdXMyLCBvdXRlcjEsIGlubmVyMSwgb3V0ZXIyLCBpbm5lcjIpIHtcbiAgICB2YXIgYm9yZGVyQXJncyA9IFtdO1xuXG4gICAgaWYgKHJhZGl1czFbMF0gPiAwIHx8IHJhZGl1czFbMV0gPiAwKSB7XG4gICAgICAgIGJvcmRlckFyZ3MucHVzaChbXCJsaW5lXCIsIG91dGVyMVsxXS5zdGFydC54LCBvdXRlcjFbMV0uc3RhcnQueV0pO1xuICAgICAgICBvdXRlcjFbMV0uY3VydmVUbyhib3JkZXJBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBib3JkZXJBcmdzLnB1c2goWyBcImxpbmVcIiwgYm9yZGVyRGF0YS5jMVswXSwgYm9yZGVyRGF0YS5jMVsxXV0pO1xuICAgIH1cblxuICAgIGlmIChyYWRpdXMyWzBdID4gMCB8fCByYWRpdXMyWzFdID4gMCkge1xuICAgICAgICBib3JkZXJBcmdzLnB1c2goW1wibGluZVwiLCBvdXRlcjJbMF0uc3RhcnQueCwgb3V0ZXIyWzBdLnN0YXJ0LnldKTtcbiAgICAgICAgb3V0ZXIyWzBdLmN1cnZlVG8oYm9yZGVyQXJncyk7XG4gICAgICAgIGJvcmRlckFyZ3MucHVzaChbXCJsaW5lXCIsIGlubmVyMlswXS5lbmQueCwgaW5uZXIyWzBdLmVuZC55XSk7XG4gICAgICAgIGlubmVyMlswXS5jdXJ2ZVRvUmV2ZXJzZWQoYm9yZGVyQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9yZGVyQXJncy5wdXNoKFtcImxpbmVcIiwgYm9yZGVyRGF0YS5jMlswXSwgYm9yZGVyRGF0YS5jMlsxXV0pO1xuICAgICAgICBib3JkZXJBcmdzLnB1c2goW1wibGluZVwiLCBib3JkZXJEYXRhLmMzWzBdLCBib3JkZXJEYXRhLmMzWzFdXSk7XG4gICAgfVxuXG4gICAgaWYgKHJhZGl1czFbMF0gPiAwIHx8IHJhZGl1czFbMV0gPiAwKSB7XG4gICAgICAgIGJvcmRlckFyZ3MucHVzaChbXCJsaW5lXCIsIGlubmVyMVsxXS5lbmQueCwgaW5uZXIxWzFdLmVuZC55XSk7XG4gICAgICAgIGlubmVyMVsxXS5jdXJ2ZVRvUmV2ZXJzZWQoYm9yZGVyQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9yZGVyQXJncy5wdXNoKFtcImxpbmVcIiwgYm9yZGVyRGF0YS5jNFswXSwgYm9yZGVyRGF0YS5jNFsxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBib3JkZXJBcmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvcm5lcihib3JkZXJBcmdzLCByYWRpdXMxLCByYWRpdXMyLCBjb3JuZXIxLCBjb3JuZXIyLCB4LCB5KSB7XG4gICAgaWYgKHJhZGl1czFbMF0gPiAwIHx8IHJhZGl1czFbMV0gPiAwKSB7XG4gICAgICAgIGJvcmRlckFyZ3MucHVzaChbXCJsaW5lXCIsIGNvcm5lcjFbMF0uc3RhcnQueCwgY29ybmVyMVswXS5zdGFydC55XSk7XG4gICAgICAgIGNvcm5lcjFbMF0uY3VydmVUbyhib3JkZXJBcmdzKTtcbiAgICAgICAgY29ybmVyMVsxXS5jdXJ2ZVRvKGJvcmRlckFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJvcmRlckFyZ3MucHVzaChbXCJsaW5lXCIsIHgsIHldKTtcbiAgICB9XG5cbiAgICBpZiAocmFkaXVzMlswXSA+IDAgfHwgcmFkaXVzMlsxXSA+IDApIHtcbiAgICAgICAgYm9yZGVyQXJncy5wdXNoKFtcImxpbmVcIiwgY29ybmVyMlswXS5zdGFydC54LCBjb3JuZXIyWzBdLnN0YXJ0LnldKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5lZ2F0aXZlWkluZGV4KGNvbnRhaW5lcikge1xuICAgIHJldHVybiBjb250YWluZXIuY3NzSW50KFwiekluZGV4XCIpIDwgMDtcbn1cblxuZnVuY3Rpb24gcG9zaXRpdmVaSW5kZXgoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jc3NJbnQoXCJ6SW5kZXhcIikgPiAwO1xufVxuXG5mdW5jdGlvbiB6SW5kZXgwKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBjb250YWluZXIuY3NzSW50KFwiekluZGV4XCIpID09PSAwO1xufVxuXG5mdW5jdGlvbiBpbmxpbmVMZXZlbChjb250YWluZXIpIHtcbiAgICByZXR1cm4gW1wiaW5saW5lXCIsIFwiaW5saW5lLWJsb2NrXCIsIFwiaW5saW5lLXRhYmxlXCJdLmluZGV4T2YoY29udGFpbmVyLmNzcyhcImRpc3BsYXlcIikpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2luZ0NvbnRleHQoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIChjb250YWluZXIgaW5zdGFuY2VvZiBTdGFja2luZ0NvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBoYXNUZXh0KGNvbnRhaW5lcikge1xuICAgIHJldHVybiBjb250YWluZXIubm9kZS5kYXRhLnRyaW0oKS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBub0xldHRlclNwYWNpbmcoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuICgvXihub3JtYWx8bm9uZXwwcHgpJC8udGVzdChjb250YWluZXIucGFyZW50LmNzcyhcImxldHRlclNwYWNpbmdcIikpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyUmFkaXVzRGF0YShjb250YWluZXIpIHtcbiAgICByZXR1cm4gW1wiVG9wTGVmdFwiLCBcIlRvcFJpZ2h0XCIsIFwiQm90dG9tUmlnaHRcIiwgXCJCb3R0b21MZWZ0XCJdLm1hcChmdW5jdGlvbihzaWRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbnRhaW5lci5jc3MoJ2JvcmRlcicgKyBzaWRlICsgJ1JhZGl1cycpO1xuICAgICAgICB2YXIgYXJyID0gdmFsdWUuc3BsaXQoXCIgXCIpO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBhcnJbMV0gPSBhcnJbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoYXNJbnQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJhYmxlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25lZEZvclN0YWNraW5nKGNvbnRhaW5lcikge1xuICAgIHZhciBwb3NpdGlvbiA9IGNvbnRhaW5lci5jc3MoXCJwb3NpdGlvblwiKTtcbiAgICB2YXIgekluZGV4ID0gKFtcImFic29sdXRlXCIsIFwicmVsYXRpdmVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKHBvc2l0aW9uKSAhPT0gLTEpID8gY29udGFpbmVyLmNzcyhcInpJbmRleFwiKSA6IFwiYXV0b1wiO1xuICAgIHJldHVybiB6SW5kZXggIT09IFwiYXV0b1wiO1xufVxuXG5mdW5jdGlvbiBpc1Bvc2l0aW9uZWQoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jc3MoXCJwb3NpdGlvblwiKSAhPT0gXCJzdGF0aWNcIjtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdGluZyhjb250YWluZXIpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmNzcyhcImZsb2F0XCIpICE9PSBcIm5vbmVcIjtcbn1cblxuZnVuY3Rpb24gaXNJbmxpbmVCbG9jayhjb250YWluZXIpIHtcbiAgICByZXR1cm4gW1wiaW5saW5lLWJsb2NrXCIsIFwiaW5saW5lLXRhYmxlXCJdLmluZGV4T2YoY29udGFpbmVyLmNzcyhcImRpc3BsYXlcIikpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gbm90KGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChjb250YWluZXIpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLm5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuXG5mdW5jdGlvbiBpc1BzZXVkb0VsZW1lbnQoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pc1BzZXVkb0VsZW1lbnQgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5ub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gekluZGV4U29ydChjb250ZXh0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5jc3NJbnQoXCJ6SW5kZXhcIikgKyAoY29udGV4dHMuaW5kZXhPZihhKSAvIGNvbnRleHRzLmxlbmd0aCkpIC0gKGIuY3NzSW50KFwiekluZGV4XCIpICsgKGNvbnRleHRzLmluZGV4T2YoYikgLyBjb250ZXh0cy5sZW5ndGgpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYXNPcGFjaXR5KGNvbnRhaW5lcikge1xuICAgIHJldHVybiBjb250YWluZXIuZ2V0T3BhY2l0eSgpIDwgMTtcbn1cblxuZnVuY3Rpb24gYXNJbnQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGgoYm9yZGVyKSB7XG4gICAgcmV0dXJuIGJvcmRlci53aWR0aDtcbn1cblxuZnVuY3Rpb24gbm9uSWdub3JlZEVsZW1lbnQobm9kZUNvbnRhaW5lcikge1xuICAgIHJldHVybiAobm9kZUNvbnRhaW5lci5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSB8fCBbXCJTQ1JJUFRcIiwgXCJIRUFEXCIsIFwiVElUTEVcIiwgXCJPQkpFQ1RcIiwgXCJCUlwiLCBcIk9QVElPTlwiXS5pbmRleE9mKG5vZGVDb250YWluZXIubm9kZS5ub2RlTmFtZSkgPT09IC0xKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbihhcnJheXMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBhcnJheXMpO1xufVxuXG5mdW5jdGlvbiBzdHJpcFF1b3Rlcyhjb250ZW50KSB7XG4gICAgdmFyIGZpcnN0ID0gY29udGVudC5zdWJzdHIoMCwgMSk7XG4gICAgcmV0dXJuIChmaXJzdCA9PT0gY29udGVudC5zdWJzdHIoY29udGVudC5sZW5ndGggLSAxKSAmJiBmaXJzdC5tYXRjaCgvJ3xcIi8pKSA/IGNvbnRlbnQuc3Vic3RyKDEsIGNvbnRlbnQubGVuZ3RoIC0gMikgOiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiBnZXRXb3JkcyhjaGFyYWN0ZXJzKSB7XG4gICAgdmFyIHdvcmRzID0gW10sIGkgPSAwLCBvbldvcmRCb3VuZGFyeSA9IGZhbHNlLCB3b3JkO1xuICAgIHdoaWxlKGNoYXJhY3RlcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1dvcmRCb3VuZGFyeShjaGFyYWN0ZXJzW2ldKSA9PT0gb25Xb3JkQm91bmRhcnkpIHtcbiAgICAgICAgICAgIHdvcmQgPSBjaGFyYWN0ZXJzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgIGlmICh3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2gocHVueWNvZGUudWNzMi5lbmNvZGUod29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Xb3JkQm91bmRhcnkgPSEgb25Xb3JkQm91bmRhcnk7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID49IGNoYXJhY3RlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB3b3JkID0gY2hhcmFjdGVycy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICBpZiAod29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKHB1bnljb2RlLnVjczIuZW5jb2RlKHdvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZHM7XG59XG5cbmZ1bmN0aW9uIGlzV29yZEJvdW5kYXJ5KGNoYXJhY3RlckNvZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAzMiwgLy8gPHNwYWNlPlxuICAgICAgICAxMywgLy8gXFxyXG4gICAgICAgIDEwLCAvLyBcXG5cbiAgICAgICAgOSwgLy8gXFx0XG4gICAgICAgIDQ1IC8vIC1cbiAgICBdLmluZGV4T2YoY2hhcmFjdGVyQ29kZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiAoL1teXFx1MDAwMC1cXHUwMGZmXS8pLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUGFyc2VyO1xuXG59LHtcIi4vY29sb3JcIjozLFwiLi9mb250bWV0cmljc1wiOjcsXCIuL2xvZ1wiOjEzLFwiLi9ub2RlY29udGFpbmVyXCI6MTQsXCIuL3BzZXVkb2VsZW1lbnRjb250YWluZXJcIjoxOCxcIi4vc3RhY2tpbmdjb250ZXh0XCI6MjEsXCIuL3RleHRjb250YWluZXJcIjoyNSxcIi4vdXRpbHNcIjoyNixcInB1bnljb2RlXCI6MX1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBYSFIgPSBfZGVyZXFfKCcuL3hocicpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi91dGlscycpO1xudmFyIGxvZyA9IF9kZXJlcV8oJy4vbG9nJyk7XG52YXIgY3JlYXRlV2luZG93Q2xvbmUgPSBfZGVyZXFfKCcuL2Nsb25lJyk7XG52YXIgZGVjb2RlNjQgPSB1dGlscy5kZWNvZGU2NDtcblxuZnVuY3Rpb24gUHJveHkoc3JjLCBwcm94eVVybCwgZG9jdW1lbnQpIHtcbiAgICB2YXIgc3VwcG9ydHNDT1JTID0gKCd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKTtcbiAgICBpZiAoIXByb3h5VXJsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIk5vIHByb3h5IGNvbmZpZ3VyZWRcIik7XG4gICAgfVxuICAgIHZhciBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKHN1cHBvcnRzQ09SUyk7XG4gICAgdmFyIHVybCA9IGNyZWF0ZVByb3h5VXJsKHByb3h5VXJsLCBzcmMsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiBzdXBwb3J0c0NPUlMgPyBYSFIodXJsKSA6IChqc29ucChkb2N1bWVudCwgdXJsLCBjYWxsYmFjaykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlNjQocmVzcG9uc2UuY29udGVudCk7XG4gICAgfSkpO1xufVxudmFyIHByb3h5Q291bnQgPSAwO1xuXG5mdW5jdGlvbiBQcm94eVVSTChzcmMsIHByb3h5VXJsLCBkb2N1bWVudCkge1xuICAgIHZhciBzdXBwb3J0c0NPUlNJbWFnZSA9ICgnY3Jvc3NPcmlnaW4nIGluIG5ldyBJbWFnZSgpKTtcbiAgICB2YXIgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhzdXBwb3J0c0NPUlNJbWFnZSk7XG4gICAgdmFyIHVybCA9IGNyZWF0ZVByb3h5VXJsKHByb3h5VXJsLCBzcmMsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKHN1cHBvcnRzQ09SU0ltYWdlID8gUHJvbWlzZS5yZXNvbHZlKHVybCkgOiBqc29ucChkb2N1bWVudCwgdXJsLCBjYWxsYmFjaykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gXCJkYXRhOlwiICsgcmVzcG9uc2UudHlwZSArIFwiO2Jhc2U2NCxcIiArIHJlc3BvbnNlLmNvbnRlbnQ7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBqc29ucChkb2N1bWVudCwgdXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5odG1sMmNhbnZhcy5wcm94eVtjYWxsYmFja107XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHMpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuaHRtbDJjYW52YXMucHJveHlbY2FsbGJhY2tdID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgICBzLnNyYyA9IHVybDtcbiAgICAgICAgcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWxsYmFjayh1c2VDT1JTKSB7XG4gICAgcmV0dXJuICF1c2VDT1JTID8gXCJodG1sMmNhbnZhc19cIiArIERhdGUubm93KCkgKyBcIl9cIiArICgrK3Byb3h5Q291bnQpICsgXCJfXCIgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHlVcmwocHJveHlVcmwsIHNyYywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcHJveHlVcmwgKyBcIj91cmw9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjKSArIChjYWxsYmFjay5sZW5ndGggPyBcIiZjYWxsYmFjaz1odG1sMmNhbnZhcy5wcm94eS5cIiArIGNhbGxiYWNrIDogXCJcIik7XG59XG5cbmZ1bmN0aW9uIGRvY3VtZW50RnJvbUhUTUwoc3JjKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKSwgZG9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQvaHRtbFwiKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBsb2coXCJET01QYXJzZXIgbm90IHN1cHBvcnRlZCwgZmFsbGluZyBiYWNrIHRvIGNyZWF0ZUhUTUxEb2N1bWVudFwiKTtcbiAgICAgICAgICAgIGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9jLm9wZW4oKTtcbiAgICAgICAgICAgICAgICBkb2Mud3JpdGUoaHRtbCk7XG4gICAgICAgICAgICAgICAgZG9jLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGNhdGNoKGVlKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiY3JlYXRlSFRNTERvY3VtZW50IHdyaXRlIG5vdCBzdXBwb3J0ZWQsIGZhbGxpbmcgYmFjayB0byBkb2N1bWVudC5ib2R5LmlubmVySFRNTFwiKTtcbiAgICAgICAgICAgICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBodG1sOyAvLyBpZTkgZG9lc250IHN1cHBvcnQgd3JpdGluZyB0byBkb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgICAgICBpZiAoIWIgfHwgIWIuaHJlZi5ob3N0KSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKTtcbiAgICAgICAgICAgIGJhc2UuaHJlZiA9IHNyYztcbiAgICAgICAgICAgIGRvYy5oZWFkLmluc2VydEJlZm9yZShiYXNlLCBkb2MuaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbG9hZFVybERvY3VtZW50KHNyYywgcHJveHksIGRvY3VtZW50LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShzcmMsIHByb3h5LCB3aW5kb3cuZG9jdW1lbnQpLnRoZW4oZG9jdW1lbnRGcm9tSFRNTChzcmMpKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gY3JlYXRlV2luZG93Q2xvbmUoZG9jLCBkb2N1bWVudCwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucywgMCwgMCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuUHJveHkgPSBQcm94eTtcbmV4cG9ydHMuUHJveHlVUkwgPSBQcm94eVVSTDtcbmV4cG9ydHMubG9hZFVybERvY3VtZW50ID0gbG9hZFVybERvY3VtZW50O1xuXG59LHtcIi4vY2xvbmVcIjoyLFwiLi9sb2dcIjoxMyxcIi4vdXRpbHNcIjoyNixcIi4veGhyXCI6Mjh9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgUHJveHlVUkwgPSBfZGVyZXFfKCcuL3Byb3h5JykuUHJveHlVUkw7XG5cbmZ1bmN0aW9uIFByb3h5SW1hZ2VDb250YWluZXIoc3JjLCBwcm94eSkge1xuICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5ocmVmID0gc3JjO1xuICAgIHNyYyA9IGxpbmsuaHJlZjtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLmltYWdlLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgc2VsZi5pbWFnZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBzZWxmLmltYWdlLm9uZXJyb3IgPSByZWplY3Q7XG5cbiAgICAgICAgbmV3IFByb3h5VVJMKHNyYywgcHJveHksIGRvY3VtZW50KS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5zcmMgPSB1cmw7XG4gICAgICAgIH0pWydjYXRjaCddKHJlamVjdCk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHlJbWFnZUNvbnRhaW5lcjtcblxufSx7XCIuL3Byb3h5XCI6MTZ9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZUNvbnRhaW5lciA9IF9kZXJlcV8oJy4vbm9kZWNvbnRhaW5lcicpO1xuXG5mdW5jdGlvbiBQc2V1ZG9FbGVtZW50Q29udGFpbmVyKG5vZGUsIHBhcmVudCwgdHlwZSkge1xuICAgIE5vZGVDb250YWluZXIuY2FsbCh0aGlzLCBub2RlLCBwYXJlbnQpO1xuICAgIHRoaXMuaXNQc2V1ZG9FbGVtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLmJlZm9yZSA9IHR5cGUgPT09IFwiOmJlZm9yZVwiO1xufVxuXG5Qc2V1ZG9FbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5jbG9uZVRvID0gZnVuY3Rpb24oc3RhY2spIHtcbiAgICBQc2V1ZG9FbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5jbG9uZVRvLmNhbGwodGhpcywgc3RhY2spO1xuICAgIHN0YWNrLmlzUHNldWRvRWxlbWVudCA9IHRydWU7XG4gICAgc3RhY2suYmVmb3JlID0gdGhpcy5iZWZvcmU7XG59O1xuXG5Qc2V1ZG9FbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZUNvbnRhaW5lci5wcm90b3R5cGUpO1xuXG5Qc2V1ZG9FbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5hcHBlbmRUb0RPTSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmJlZm9yZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIHRoaXMucGFyZW50Lm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5ub2RlLmNsYXNzTmFtZSArPSBcIiBcIiArIHRoaXMuZ2V0SGlkZUNsYXNzKCk7XG59O1xuXG5Qc2V1ZG9FbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5jbGVhbkRPTSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgdGhpcy5wYXJlbnQubm9kZS5jbGFzc05hbWUgPSB0aGlzLnBhcmVudC5ub2RlLmNsYXNzTmFtZS5yZXBsYWNlKHRoaXMuZ2V0SGlkZUNsYXNzKCksIFwiXCIpO1xufTtcblxuUHNldWRvRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuZ2V0SGlkZUNsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbXCJQU0VVRE9fSElERV9FTEVNRU5UX0NMQVNTX1wiICsgKHRoaXMuYmVmb3JlID8gXCJCRUZPUkVcIiA6IFwiQUZURVJcIildO1xufTtcblxuUHNldWRvRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuUFNFVURPX0hJREVfRUxFTUVOVF9DTEFTU19CRUZPUkUgPSBcIl9fX2h0bWwyY2FudmFzX19fcHNldWRvZWxlbWVudF9iZWZvcmVcIjtcblBzZXVkb0VsZW1lbnRDb250YWluZXIucHJvdG90eXBlLlBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQUZURVIgPSBcIl9fX2h0bWwyY2FudmFzX19fcHNldWRvZWxlbWVudF9hZnRlclwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBzZXVkb0VsZW1lbnRDb250YWluZXI7XG5cbn0se1wiLi9ub2RlY29udGFpbmVyXCI6MTR9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbG9nID0gX2RlcmVxXygnLi9sb2cnKTtcblxuZnVuY3Rpb24gUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgaW1hZ2VzLCBvcHRpb25zLCBkb2N1bWVudCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckltYWdlID0gZnVuY3Rpb24oY29udGFpbmVyLCBib3VuZHMsIGJvcmRlckRhdGEsIGltYWdlQ29udGFpbmVyKSB7XG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gY29udGFpbmVyLmNzc0ludCgncGFkZGluZ0xlZnQnKSxcbiAgICAgICAgcGFkZGluZ1RvcCA9IGNvbnRhaW5lci5jc3NJbnQoJ3BhZGRpbmdUb3AnKSxcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29udGFpbmVyLmNzc0ludCgncGFkZGluZ1JpZ2h0JyksXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBjb250YWluZXIuY3NzSW50KCdwYWRkaW5nQm90dG9tJyksXG4gICAgICAgIGJvcmRlcnMgPSBib3JkZXJEYXRhLmJvcmRlcnM7XG5cbiAgICB2YXIgd2lkdGggPSBib3VuZHMud2lkdGggLSAoYm9yZGVyc1sxXS53aWR0aCArIGJvcmRlcnNbM10ud2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCk7XG4gICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSAoYm9yZGVyc1swXS53aWR0aCArIGJvcmRlcnNbMl0ud2lkdGggKyBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbSk7XG4gICAgdGhpcy5kcmF3SW1hZ2UoXG4gICAgICAgIGltYWdlQ29udGFpbmVyLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBpbWFnZUNvbnRhaW5lci5pbWFnZS53aWR0aCB8fCB3aWR0aCxcbiAgICAgICAgaW1hZ2VDb250YWluZXIuaW1hZ2UuaGVpZ2h0IHx8IGhlaWdodCxcbiAgICAgICAgYm91bmRzLmxlZnQgKyBwYWRkaW5nTGVmdCArIGJvcmRlcnNbM10ud2lkdGgsXG4gICAgICAgIGJvdW5kcy50b3AgKyBwYWRkaW5nVG9wICsgYm9yZGVyc1swXS53aWR0aCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmFja2dyb3VuZCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgYm91bmRzLCBib3JkZXJEYXRhKSB7XG4gICAgaWYgKGJvdW5kcy5oZWlnaHQgPiAwICYmIGJvdW5kcy53aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5yZW5kZXJCYWNrZ3JvdW5kQ29sb3IoY29udGFpbmVyLCBib3VuZHMpO1xuICAgICAgICB0aGlzLnJlbmRlckJhY2tncm91bmRJbWFnZShjb250YWluZXIsIGJvdW5kcywgYm9yZGVyRGF0YSk7XG4gICAgfVxufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJhY2tncm91bmRDb2xvciA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgYm91bmRzKSB7XG4gICAgdmFyIGNvbG9yID0gY29udGFpbmVyLmNvbG9yKFwiYmFja2dyb3VuZENvbG9yXCIpO1xuICAgIGlmICghY29sb3IuaXNUcmFuc3BhcmVudCgpKSB7XG4gICAgICAgIHRoaXMucmVjdGFuZ2xlKGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIGNvbG9yKTtcbiAgICB9XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQm9yZGVycyA9IGZ1bmN0aW9uKGJvcmRlcnMpIHtcbiAgICBib3JkZXJzLmZvckVhY2godGhpcy5yZW5kZXJCb3JkZXIsIHRoaXMpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJvcmRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuY29sb3IuaXNUcmFuc3BhcmVudCgpICYmIGRhdGEuYXJncyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShkYXRhLmFyZ3MsIGRhdGEuY29sb3IpO1xuICAgIH1cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbihjb250YWluZXIsIGJvdW5kcywgYm9yZGVyRGF0YSkge1xuICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2VzID0gY29udGFpbmVyLnBhcnNlQmFja2dyb3VuZEltYWdlcygpO1xuICAgIGJhY2tncm91bmRJbWFnZXMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24oYmFja2dyb3VuZEltYWdlLCBpbmRleCwgYXJyKSB7XG4gICAgICAgIHN3aXRjaChiYWNrZ3JvdW5kSW1hZ2UubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2VzLmdldChiYWNrZ3JvdW5kSW1hZ2UuYXJnc1swXSk7XG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckJhY2tncm91bmRSZXBlYXRpbmcoY29udGFpbmVyLCBib3VuZHMsIGltYWdlLCBhcnIubGVuZ3RoIC0gKGluZGV4KzEpLCBib3JkZXJEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRXJyb3IgbG9hZGluZyBiYWNrZ3JvdW5kLWltYWdlXCIsIGJhY2tncm91bmRJbWFnZS5hcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZWFyLWdyYWRpZW50XCI6XG4gICAgICAgIGNhc2UgXCJncmFkaWVudFwiOlxuICAgICAgICAgICAgdmFyIGdyYWRpZW50SW1hZ2UgPSB0aGlzLmltYWdlcy5nZXQoYmFja2dyb3VuZEltYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChncmFkaWVudEltYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCYWNrZ3JvdW5kR3JhZGllbnQoZ3JhZGllbnRJbWFnZSwgYm91bmRzLCBib3JkZXJEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRXJyb3IgbG9hZGluZyBiYWNrZ3JvdW5kLWltYWdlXCIsIGJhY2tncm91bmRJbWFnZS5hcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2coXCJVbmtub3duIGJhY2tncm91bmQtaW1hZ2UgdHlwZVwiLCBiYWNrZ3JvdW5kSW1hZ2UuYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCYWNrZ3JvdW5kUmVwZWF0aW5nID0gZnVuY3Rpb24oY29udGFpbmVyLCBib3VuZHMsIGltYWdlQ29udGFpbmVyLCBpbmRleCwgYm9yZGVyRGF0YSkge1xuICAgIHZhciBzaXplID0gY29udGFpbmVyLnBhcnNlQmFja2dyb3VuZFNpemUoYm91bmRzLCBpbWFnZUNvbnRhaW5lci5pbWFnZSwgaW5kZXgpO1xuICAgIHZhciBwb3NpdGlvbiA9IGNvbnRhaW5lci5wYXJzZUJhY2tncm91bmRQb3NpdGlvbihib3VuZHMsIGltYWdlQ29udGFpbmVyLmltYWdlLCBpbmRleCwgc2l6ZSk7XG4gICAgdmFyIHJlcGVhdCA9IGNvbnRhaW5lci5wYXJzZUJhY2tncm91bmRSZXBlYXQoaW5kZXgpO1xuICAgIHN3aXRjaCAocmVwZWF0KSB7XG4gICAgY2FzZSBcInJlcGVhdC14XCI6XG4gICAgY2FzZSBcInJlcGVhdCBuby1yZXBlYXRcIjpcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kUmVwZWF0U2hhcGUoaW1hZ2VDb250YWluZXIsIHBvc2l0aW9uLCBzaXplLCBib3VuZHMsIGJvdW5kcy5sZWZ0ICsgYm9yZGVyRGF0YVszXSwgYm91bmRzLnRvcCArIHBvc2l0aW9uLnRvcCArIGJvcmRlckRhdGFbMF0sIDk5OTk5LCBzaXplLmhlaWdodCwgYm9yZGVyRGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyZXBlYXQteVwiOlxuICAgIGNhc2UgXCJuby1yZXBlYXQgcmVwZWF0XCI6XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFJlcGVhdFNoYXBlKGltYWdlQ29udGFpbmVyLCBwb3NpdGlvbiwgc2l6ZSwgYm91bmRzLCBib3VuZHMubGVmdCArIHBvc2l0aW9uLmxlZnQgKyBib3JkZXJEYXRhWzNdLCBib3VuZHMudG9wICsgYm9yZGVyRGF0YVswXSwgc2l6ZS53aWR0aCwgOTk5OTksIGJvcmRlckRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwibm8tcmVwZWF0XCI6XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFJlcGVhdFNoYXBlKGltYWdlQ29udGFpbmVyLCBwb3NpdGlvbiwgc2l6ZSwgYm91bmRzLCBib3VuZHMubGVmdCArIHBvc2l0aW9uLmxlZnQgKyBib3JkZXJEYXRhWzNdLCBib3VuZHMudG9wICsgcG9zaXRpb24udG9wICsgYm9yZGVyRGF0YVswXSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIGJvcmRlckRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJlbmRlckJhY2tncm91bmRSZXBlYXQoaW1hZ2VDb250YWluZXIsIHBvc2l0aW9uLCBzaXplLCB7dG9wOiBib3VuZHMudG9wLCBsZWZ0OiBib3VuZHMubGVmdH0sIGJvcmRlckRhdGFbM10sIGJvcmRlckRhdGFbMF0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuXG59LHtcIi4vbG9nXCI6MTN9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgUmVuZGVyZXIgPSBfZGVyZXFfKCcuLi9yZW5kZXJlcicpO1xudmFyIExpbmVhckdyYWRpZW50Q29udGFpbmVyID0gX2RlcmVxXygnLi4vbGluZWFyZ3JhZGllbnRjb250YWluZXInKTtcbnZhciBsb2cgPSBfZGVyZXFfKCcuLi9sb2cnKTtcblxuZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIod2lkdGgsIGhlaWdodCkge1xuICAgIFJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYW52YXMgPSB0aGlzLm9wdGlvbnMuY2FudmFzIHx8IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB0aGlzLnRhaW50Q3R4ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB0aGlzLmN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgIHRoaXMudmFyaWFibGVzID0ge307XG4gICAgbG9nKFwiSW5pdGlhbGl6ZWQgQ2FudmFzUmVuZGVyZXIgd2l0aCBzaXplXCIsIHdpZHRoLCBcInhcIiwgaGVpZ2h0KTtcbn1cblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZW5kZXJlci5wcm90b3R5cGUpO1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2V0RmlsbFN0eWxlID0gZnVuY3Rpb24oZmlsbFN0eWxlKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdHlwZW9mKGZpbGxTdHlsZSkgPT09IFwib2JqZWN0XCIgJiYgISFmaWxsU3R5bGUuaXNDb2xvciA/IGZpbGxTdHlsZS50b1N0cmluZygpIDogZmlsbFN0eWxlO1xuICAgIHJldHVybiB0aGlzLmN0eDtcbn07XG5cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWN0YW5nbGUgPSBmdW5jdGlvbihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgdGhpcy5zZXRGaWxsU3R5bGUoY29sb3IpLmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24obGVmdCwgdG9wLCBzaXplLCBjb2xvcikge1xuICAgIHRoaXMuc2V0RmlsbFN0eWxlKGNvbG9yKTtcbiAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLmN0eC5hcmMobGVmdCArIHNpemUgLyAyLCB0b3AgKyBzaXplIC8gMiwgc2l6ZSAvIDIsIDAsIE1hdGguUEkqMiwgdHJ1ZSk7XG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5jdHguZmlsbCgpO1xufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNpcmNsZVN0cm9rZSA9IGZ1bmN0aW9uKGxlZnQsIHRvcCwgc2l6ZSwgY29sb3IsIHN0cm9rZSwgc3Ryb2tlQ29sb3IpIHtcbiAgICB0aGlzLmNpcmNsZShsZWZ0LCB0b3AsIHNpemUsIGNvbG9yKTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlKCk7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1NoYXBlID0gZnVuY3Rpb24oc2hhcGUsIGNvbG9yKSB7XG4gICAgdGhpcy5zaGFwZShzaGFwZSk7XG4gICAgdGhpcy5zZXRGaWxsU3R5bGUoY29sb3IpLmZpbGwoKTtcbn07XG5cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS50YWludHMgPSBmdW5jdGlvbihpbWFnZUNvbnRhaW5lcikge1xuICAgIGlmIChpbWFnZUNvbnRhaW5lci50YWludGVkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGFpbnRDdHguZHJhd0ltYWdlKGltYWdlQ29udGFpbmVyLmltYWdlLCAwLCAwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudGFpbnRDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgICAgICAgaW1hZ2VDb250YWluZXIudGFpbnRlZCA9IGZhbHNlO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbnRDdHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLnRhaW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlQ29udGFpbmVyLnRhaW50ZWQ7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd0ltYWdlID0gZnVuY3Rpb24oaW1hZ2VDb250YWluZXIsIHN4LCBzeSwgc3csIHNoLCBkeCwgZHksIGR3LCBkaCkge1xuICAgIGlmICghdGhpcy50YWludHMoaW1hZ2VDb250YWluZXIpIHx8IHRoaXMub3B0aW9ucy5hbGxvd1RhaW50KSB7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZUNvbnRhaW5lci5pbWFnZSwgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoKTtcbiAgICB9XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uKHNoYXBlcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgc2hhcGVzLmZpbHRlcihoYXNFbnRyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUoc2hhcGUpLmNsaXAoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbn07XG5cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5zaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgc2hhcGUuZm9yRWFjaChmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHBvaW50WzBdID09PSBcInJlY3RcIikge1xuICAgICAgICAgICAgdGhpcy5jdHgucmVjdC5hcHBseSh0aGlzLmN0eCwgcG9pbnQuc2xpY2UoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHhbKGluZGV4ID09PSAwKSA/IFwibW92ZVRvXCIgOiBwb2ludFswXSArIFwiVG9cIiBdLmFwcGx5KHRoaXMuY3R4LCBwb2ludC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gdGhpcy5jdHg7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZm9udCA9IGZ1bmN0aW9uKGNvbG9yLCBzdHlsZSwgdmFyaWFudCwgd2VpZ2h0LCBzaXplLCBmYW1pbHkpIHtcbiAgICB0aGlzLnNldEZpbGxTdHlsZShjb2xvcikuZm9udCA9IFtzdHlsZSwgdmFyaWFudCwgd2VpZ2h0LCBzaXplLCBmYW1pbHldLmpvaW4oXCIgXCIpLnNwbGl0KFwiLFwiKVswXTtcbn07XG5cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5mb250U2hhZG93ID0gZnVuY3Rpb24oY29sb3IsIG9mZnNldFgsIG9mZnNldFksIGJsdXIpIHtcbiAgICB0aGlzLnNldFZhcmlhYmxlKFwic2hhZG93Q29sb3JcIiwgY29sb3IudG9TdHJpbmcoKSlcbiAgICAgICAgLnNldFZhcmlhYmxlKFwic2hhZG93T2Zmc2V0WVwiLCBvZmZzZXRYKVxuICAgICAgICAuc2V0VmFyaWFibGUoXCJzaGFkb3dPZmZzZXRYXCIsIG9mZnNldFkpXG4gICAgICAgIC5zZXRWYXJpYWJsZShcInNoYWRvd0JsdXJcIiwgYmx1cik7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xlYXJTaGFkb3cgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFZhcmlhYmxlKFwic2hhZG93Q29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0ub3JpZ2luWzBdLCB0cmFuc2Zvcm0ub3JpZ2luWzFdKTtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHkodGhpcy5jdHgsIHRyYW5zZm9ybS5tYXRyaXgpO1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLm9yaWdpblswXSwgLXRyYW5zZm9ybS5vcmlnaW5bMV0pO1xufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnNldFZhcmlhYmxlID0gZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudmFyaWFibGVzW3Byb3BlcnR5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZXNbcHJvcGVydHldID0gdGhpcy5jdHhbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQsIGxlZnQsIGJvdHRvbSkge1xuICAgIHRoaXMuY3R4LmZpbGxUZXh0KHRleHQsIGxlZnQsIGJvdHRvbSk7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuYmFja2dyb3VuZFJlcGVhdFNoYXBlID0gZnVuY3Rpb24oaW1hZ2VDb250YWluZXIsIGJhY2tncm91bmRQb3NpdGlvbiwgc2l6ZSwgYm91bmRzLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGJvcmRlckRhdGEpIHtcbiAgICB2YXIgc2hhcGUgPSBbXG4gICAgICAgIFtcImxpbmVcIiwgTWF0aC5yb3VuZChsZWZ0KSwgTWF0aC5yb3VuZCh0b3ApXSxcbiAgICAgICAgW1wibGluZVwiLCBNYXRoLnJvdW5kKGxlZnQgKyB3aWR0aCksIE1hdGgucm91bmQodG9wKV0sXG4gICAgICAgIFtcImxpbmVcIiwgTWF0aC5yb3VuZChsZWZ0ICsgd2lkdGgpLCBNYXRoLnJvdW5kKGhlaWdodCArIHRvcCldLFxuICAgICAgICBbXCJsaW5lXCIsIE1hdGgucm91bmQobGVmdCksIE1hdGgucm91bmQoaGVpZ2h0ICsgdG9wKV1cbiAgICBdO1xuICAgIHRoaXMuY2xpcChbc2hhcGVdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJCYWNrZ3JvdW5kUmVwZWF0KGltYWdlQ29udGFpbmVyLCBiYWNrZ3JvdW5kUG9zaXRpb24sIHNpemUsIGJvdW5kcywgYm9yZGVyRGF0YVszXSwgYm9yZGVyRGF0YVswXSk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmFja2dyb3VuZFJlcGVhdCA9IGZ1bmN0aW9uKGltYWdlQ29udGFpbmVyLCBiYWNrZ3JvdW5kUG9zaXRpb24sIHNpemUsIGJvdW5kcywgYm9yZGVyTGVmdCwgYm9yZGVyVG9wKSB7XG4gICAgdmFyIG9mZnNldFggPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgYmFja2dyb3VuZFBvc2l0aW9uLmxlZnQgKyBib3JkZXJMZWZ0KSwgb2Zmc2V0WSA9IE1hdGgucm91bmQoYm91bmRzLnRvcCArIGJhY2tncm91bmRQb3NpdGlvbi50b3AgKyBib3JkZXJUb3ApO1xuICAgIHRoaXMuc2V0RmlsbFN0eWxlKHRoaXMuY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5yZXNpemVJbWFnZShpbWFnZUNvbnRhaW5lciwgc2l6ZSksIFwicmVwZWF0XCIpKTtcbiAgICB0aGlzLmN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgdGhpcy5jdHguZmlsbCgpO1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJhY2tncm91bmRHcmFkaWVudCA9IGZ1bmN0aW9uKGdyYWRpZW50SW1hZ2UsIGJvdW5kcykge1xuICAgIGlmIChncmFkaWVudEltYWdlIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gdGhpcy5jdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgICAgICBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAqIGdyYWRpZW50SW1hZ2UueDAsXG4gICAgICAgICAgICBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAqIGdyYWRpZW50SW1hZ2UueTAsXG4gICAgICAgICAgICBib3VuZHMubGVmdCArICBib3VuZHMud2lkdGggKiBncmFkaWVudEltYWdlLngxLFxuICAgICAgICAgICAgYm91bmRzLnRvcCArICBib3VuZHMuaGVpZ2h0ICogZ3JhZGllbnRJbWFnZS55MSk7XG4gICAgICAgIGdyYWRpZW50SW1hZ2UuY29sb3JTdG9wcy5mb3JFYWNoKGZ1bmN0aW9uKGNvbG9yU3RvcCkge1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcC5zdG9wLCBjb2xvclN0b3AuY29sb3IudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlY3RhbmdsZShib3VuZHMubGVmdCwgYm91bmRzLnRvcCwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCBncmFkaWVudCk7XG4gICAgfVxufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZUltYWdlID0gZnVuY3Rpb24oaW1hZ2VDb250YWluZXIsIHNpemUpIHtcbiAgICB2YXIgaW1hZ2UgPSBpbWFnZUNvbnRhaW5lci5pbWFnZTtcbiAgICBpZihpbWFnZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG5cbiAgICB2YXIgY3R4LCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG4gICAgcmV0dXJuIGNhbnZhcztcbn07XG5cbmZ1bmN0aW9uIGhhc0VudHJpZXMoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNSZW5kZXJlcjtcblxufSx7XCIuLi9saW5lYXJncmFkaWVudGNvbnRhaW5lclwiOjEyLFwiLi4vbG9nXCI6MTMsXCIuLi9yZW5kZXJlclwiOjE5fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGVDb250YWluZXIgPSBfZGVyZXFfKCcuL25vZGVjb250YWluZXInKTtcblxuZnVuY3Rpb24gU3RhY2tpbmdDb250ZXh0KGhhc093blN0YWNraW5nLCBvcGFjaXR5LCBlbGVtZW50LCBwYXJlbnQpIHtcbiAgICBOb2RlQ29udGFpbmVyLmNhbGwodGhpcywgZWxlbWVudCwgcGFyZW50KTtcbiAgICB0aGlzLm93blN0YWNraW5nID0gaGFzT3duU3RhY2tpbmc7XG4gICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLm9wYWNpdHkgPSAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5zdGFjay5vcGFjaXR5IDogMSkgKiBvcGFjaXR5O1xufVxuXG5TdGFja2luZ0NvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlQ29udGFpbmVyLnByb3RvdHlwZSk7XG5cblN0YWNraW5nQ29udGV4dC5wcm90b3R5cGUuZ2V0UGFyZW50U3RhY2sgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHBhcmVudFN0YWNrID0gKHRoaXMucGFyZW50KSA/IHRoaXMucGFyZW50LnN0YWNrIDogbnVsbDtcbiAgICByZXR1cm4gcGFyZW50U3RhY2sgPyAocGFyZW50U3RhY2sub3duU3RhY2tpbmcgPyBwYXJlbnRTdGFjayA6IHBhcmVudFN0YWNrLmdldFBhcmVudFN0YWNrKGNvbnRleHQpKSA6IGNvbnRleHQuc3RhY2s7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNraW5nQ29udGV4dDtcblxufSx7XCIuL25vZGVjb250YWluZXJcIjoxNH1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIFN1cHBvcnQoZG9jdW1lbnQpIHtcbiAgICB0aGlzLnJhbmdlQm91bmRzID0gdGhpcy50ZXN0UmFuZ2VCb3VuZHMoZG9jdW1lbnQpO1xuICAgIHRoaXMuY29ycyA9IHRoaXMudGVzdENPUlMoKTtcbiAgICB0aGlzLnN2ZyA9IHRoaXMudGVzdFNWRygpO1xufVxuXG5TdXBwb3J0LnByb3RvdHlwZS50ZXN0UmFuZ2VCb3VuZHMgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgIHZhciByYW5nZSwgdGVzdEVsZW1lbnQsIHJhbmdlQm91bmRzLCByYW5nZUhlaWdodCwgc3VwcG9ydCA9IGZhbHNlO1xuXG4gICAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICAgICAgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib3VuZHRlc3QnKTtcbiAgICAgICAgICAgIHRlc3RFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiMTIzcHhcIjtcbiAgICAgICAgICAgIHRlc3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RFbGVtZW50KTtcblxuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZSh0ZXN0RWxlbWVudCk7XG4gICAgICAgICAgICByYW5nZUJvdW5kcyA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmFuZ2VIZWlnaHQgPSByYW5nZUJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZUhlaWdodCA9PT0gMTIzKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlc3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBwb3J0O1xufTtcblxuU3VwcG9ydC5wcm90b3R5cGUudGVzdENPUlMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mKChuZXcgSW1hZ2UoKSkuY3Jvc3NPcmlnaW4pICE9PSBcInVuZGVmaW5lZFwiO1xufTtcblxuU3VwcG9ydC5wcm90b3R5cGUudGVzdFNWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB2YXIgY3R4ID0gIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJz48L3N2Zz5cIjtcblxuICAgIHRyeSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdXBwb3J0O1xuXG59LHt9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgWEhSID0gX2RlcmVxXygnLi94aHInKTtcbnZhciBkZWNvZGU2NCA9IF9kZXJlcV8oJy4vdXRpbHMnKS5kZWNvZGU2NDtcblxuZnVuY3Rpb24gU1ZHQ29udGFpbmVyKHNyYykge1xuICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucHJvbWlzZSA9IHRoaXMuaGFzRmFicmljKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChzZWxmLmlzSW5saW5lKHNyYykgPyBQcm9taXNlLnJlc29sdmUoc2VsZi5pbmxpbmVGb3JtYXR0aW5nKHNyYykpIDogWEhSKHNyYykpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oc3ZnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICB3aW5kb3cuaHRtbDJjYW52YXMuc3ZnLmZhYnJpYy5sb2FkU1ZHRnJvbVN0cmluZyhzdmcsIHNlbGYuY3JlYXRlQ2FudmFzLmNhbGwoc2VsZiwgcmVzb2x2ZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuU1ZHQ29udGFpbmVyLnByb3RvdHlwZS5oYXNGYWJyaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXdpbmRvdy5odG1sMmNhbnZhcy5zdmcgfHwgIXdpbmRvdy5odG1sMmNhbnZhcy5zdmcuZmFicmljID8gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaHRtbDJjYW52YXMuc3ZnLmpzIGlzIG5vdCBsb2FkZWQsIGNhbm5vdCByZW5kZXIgc3ZnXCIpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuU1ZHQ29udGFpbmVyLnByb3RvdHlwZS5pbmxpbmVGb3JtYXR0aW5nID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgcmV0dXJuICgvXmRhdGE6aW1hZ2VcXC9zdmdcXCt4bWw7YmFzZTY0LC8udGVzdChzcmMpKSA/IHRoaXMuZGVjb2RlNjQodGhpcy5yZW1vdmVDb250ZW50VHlwZShzcmMpKSA6IHRoaXMucmVtb3ZlQ29udGVudFR5cGUoc3JjKTtcbn07XG5cblNWR0NvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ29udGVudFR5cGUgPSBmdW5jdGlvbihzcmMpIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoL15kYXRhOmltYWdlXFwvc3ZnXFwreG1sKDtiYXNlNjQpPywvLCcnKTtcbn07XG5cblNWR0NvbnRhaW5lci5wcm90b3R5cGUuaXNJbmxpbmUgPSBmdW5jdGlvbihzcmMpIHtcbiAgICByZXR1cm4gKC9eZGF0YTppbWFnZVxcL3N2Z1xcK3htbC9pLnRlc3Qoc3JjKSk7XG59O1xuXG5TVkdDb250YWluZXIucHJvdG90eXBlLmNyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBuZXcgd2luZG93Lmh0bWwyY2FudmFzLnN2Zy5mYWJyaWMuU3RhdGljQ2FudmFzKCdjJyk7XG4gICAgICAgIHNlbGYuaW1hZ2UgPSBjYW52YXMubG93ZXJDYW52YXNFbDtcbiAgICAgICAgY2FudmFzXG4gICAgICAgICAgICAuc2V0V2lkdGgob3B0aW9ucy53aWR0aClcbiAgICAgICAgICAgIC5zZXRIZWlnaHQob3B0aW9ucy5oZWlnaHQpXG4gICAgICAgICAgICAuYWRkKHdpbmRvdy5odG1sMmNhbnZhcy5zdmcuZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhvYmplY3RzLCBvcHRpb25zKSlcbiAgICAgICAgICAgIC5yZW5kZXJBbGwoKTtcbiAgICAgICAgcmVzb2x2ZShjYW52YXMubG93ZXJDYW52YXNFbCk7XG4gICAgfTtcbn07XG5cblNWR0NvbnRhaW5lci5wcm90b3R5cGUuZGVjb2RlNjQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gKHR5cGVvZih3aW5kb3cuYXRvYikgPT09IFwiZnVuY3Rpb25cIikgPyB3aW5kb3cuYXRvYihzdHIpIDogZGVjb2RlNjQoc3RyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHQ29udGFpbmVyO1xuXG59LHtcIi4vdXRpbHNcIjoyNixcIi4veGhyXCI6Mjh9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU1ZHQ29udGFpbmVyID0gX2RlcmVxXygnLi9zdmdjb250YWluZXInKTtcblxuZnVuY3Rpb24gU1ZHTm9kZUNvbnRhaW5lcihub2RlLCBfbmF0aXZlKSB7XG4gICAgdGhpcy5zcmMgPSBub2RlO1xuICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucHJvbWlzZSA9IF9uYXRpdmUgPyBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBzZWxmLmltYWdlLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNlbGYuaW1hZ2Uub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgc2VsZi5pbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIChuZXcgWE1MU2VyaWFsaXplcigpKS5zZXJpYWxpemVUb1N0cmluZyhub2RlKTtcbiAgICAgICAgaWYgKHNlbGYuaW1hZ2UuY29tcGxldGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5pbWFnZSk7XG4gICAgICAgIH1cbiAgICB9KSA6IHRoaXMuaGFzRmFicmljKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5odG1sMmNhbnZhcy5zdmcuZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQobm9kZSwgc2VsZi5jcmVhdGVDYW52YXMuY2FsbChzZWxmLCByZXNvbHZlKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5TVkdOb2RlQ29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU1ZHQ29udGFpbmVyLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHTm9kZUNvbnRhaW5lcjtcblxufSx7XCIuL3N2Z2NvbnRhaW5lclwiOjIzfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGVDb250YWluZXIgPSBfZGVyZXFfKCcuL25vZGVjb250YWluZXInKTtcblxuZnVuY3Rpb24gVGV4dENvbnRhaW5lcihub2RlLCBwYXJlbnQpIHtcbiAgICBOb2RlQ29udGFpbmVyLmNhbGwodGhpcywgbm9kZSwgcGFyZW50KTtcbn1cblxuVGV4dENvbnRhaW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGVDb250YWluZXIucHJvdG90eXBlKTtcblxuVGV4dENvbnRhaW5lci5wcm90b3R5cGUuYXBwbHlUZXh0VHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2RlLmRhdGEgPSB0aGlzLnRyYW5zZm9ybSh0aGlzLnBhcmVudC5jc3MoXCJ0ZXh0VHJhbnNmb3JtXCIpKTtcbn07XG5cblRleHRDb250YWluZXIucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgIHZhciB0ZXh0ID0gdGhpcy5ub2RlLmRhdGE7XG4gICAgc3dpdGNoKHRyYW5zZm9ybSl7XG4gICAgICAgIGNhc2UgXCJsb3dlcmNhc2VcIjpcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNhc2UgXCJjYXBpdGFsaXplXCI6XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8oXnxcXHN8OnwtfFxcKHxcXCkpKFthLXpdKS9nLCBjYXBpdGFsaXplKTtcbiAgICAgICAgY2FzZSBcInVwcGVyY2FzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRleHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUobSwgcDEsIHAyKSB7XG4gICAgaWYgKG0ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcDEgKyBwMi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0Q29udGFpbmVyO1xuXG59LHtcIi4vbm9kZWNvbnRhaW5lclwiOjE0fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5zbWFsbEltYWdlID0gZnVuY3Rpb24gc21hbGxJbWFnZSgpIHtcbiAgICByZXR1cm4gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTdcIjtcbn07XG5cbmV4cG9ydHMuYmluZCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcblxuLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG5leHBvcnRzLmRlY29kZTY0ID0gZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgdmFyIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0LCBieXRlMSwgYnl0ZTIsIGJ5dGUzO1xuXG4gICAgdmFyIG91dHB1dCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgICBlbmNvZGVkMiA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO1xuICAgICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICAgIGJ5dGUxID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgICBieXRlMiA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICAgIGJ5dGUzID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgZW5jb2RlZDQ7XG4gICAgICAgIGlmIChlbmNvZGVkMyA9PT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUxKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbmNvZGVkNCA9PT0gNjQgfHwgZW5jb2RlZDQgPT09IC0xKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlMSwgYnl0ZTIpO1xuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlMSwgYnl0ZTIsIGJ5dGUzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5leHBvcnRzLmdldEJvdW5kcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgd2lkdGggPSBub2RlLm9mZnNldFdpZHRoID09IG51bGwgPyBjbGllbnRSZWN0LndpZHRoIDogbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AsXG4gICAgICAgICAgICBib3R0b206IGNsaWVudFJlY3QuYm90dG9tIHx8IChjbGllbnRSZWN0LnRvcCArIGNsaWVudFJlY3QuaGVpZ2h0KSxcbiAgICAgICAgICAgIHJpZ2h0OiBjbGllbnRSZWN0LmxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgIHdpZHRoOiAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0ID09IG51bGwgPyBjbGllbnRSZWN0LmhlaWdodCA6IG5vZGUub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5cbmV4cG9ydHMub2Zmc2V0Qm91bmRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLm9mZnNldFBhcmVudCA/IGV4cG9ydHMub2Zmc2V0Qm91bmRzKG5vZGUub2Zmc2V0UGFyZW50KSA6IHt0b3A6IDAsIGxlZnQ6IDB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBub2RlLm9mZnNldFRvcCArIHBhcmVudC50b3AsXG4gICAgICAgIGJvdHRvbTogbm9kZS5vZmZzZXRUb3AgKyBub2RlLm9mZnNldEhlaWdodCArIHBhcmVudC50b3AsXG4gICAgICAgIHJpZ2h0OiBub2RlLm9mZnNldExlZnQgKyBwYXJlbnQubGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgICAgIGxlZnQ6IG5vZGUub2Zmc2V0TGVmdCArIHBhcmVudC5sZWZ0LFxuICAgICAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodFxuICAgIH07XG59O1xuXG5leHBvcnRzLnBhcnNlQmFja2dyb3VuZHMgPSBmdW5jdGlvbihiYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICB2YXIgd2hpdGVzcGFjZSA9ICcgXFxyXFxuXFx0JyxcbiAgICAgICAgbWV0aG9kLCBkZWZpbml0aW9uLCBwcmVmaXgsIHByZWZpeF9pLCBibG9jaywgcmVzdWx0cyA9IFtdLFxuICAgICAgICBtb2RlID0gMCwgbnVtUGFyZW4gPSAwLCBxdW90ZSwgYXJncztcbiAgICB2YXIgYXBwZW5kUmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uc3Vic3RyKDAsIDEpID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24uc3Vic3RyKDEsIGRlZmluaXRpb24ubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2Quc3Vic3RyKDAsIDEpID09PSAnLScgJiYgKHByZWZpeF9pID0gbWV0aG9kLmluZGV4T2YoJy0nLCAxICkgKyAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBtZXRob2Quc3Vic3RyKDAsIHByZWZpeF9pKTtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBtZXRob2Quc3Vic3RyKHByZWZpeF9pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYmxvY2ssXG4gICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICBpbWFnZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICBtZXRob2QgPSBwcmVmaXggPSBkZWZpbml0aW9uID0gYmxvY2sgPSAnJztcbiAgICB9O1xuICAgIGFyZ3MgPSBbXTtcbiAgICBtZXRob2QgPSBwcmVmaXggPSBkZWZpbml0aW9uID0gYmxvY2sgPSAnJztcbiAgICBiYWNrZ3JvdW5kSW1hZ2Uuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmIChtb2RlID09PSAwICYmIHdoaXRlc3BhY2UuaW5kZXhPZihjKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGMpIHtcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgaWYoIXF1b3RlKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSBjO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHF1b3RlID09PSBjKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgaWYocXVvdGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZihtb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbW9kZSA9IDE7XG4gICAgICAgICAgICAgICAgYmxvY2sgKz0gYztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bVBhcmVuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICBpZiAocXVvdGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZihtb2RlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYobnVtUGFyZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGFyZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGlmIChxdW90ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG1vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtUGFyZW4gPT09IDAgJiYgIW1ldGhvZC5tYXRjaCgvXnVybCQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrICs9IGM7XG4gICAgICAgIGlmIChtb2RlID09PSAwKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24gKz0gYztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXBwZW5kUmVzdWx0KCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG59LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgR3JhZGllbnRDb250YWluZXIgPSBfZGVyZXFfKCcuL2dyYWRpZW50Y29udGFpbmVyJyk7XG5cbmZ1bmN0aW9uIFdlYmtpdEdyYWRpZW50Q29udGFpbmVyKGltYWdlRGF0YSkge1xuICAgIEdyYWRpZW50Q29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gaW1hZ2VEYXRhLmFyZ3NbMF0gPT09IFwibGluZWFyXCIgPyBHcmFkaWVudENvbnRhaW5lci5UWVBFUy5MSU5FQVIgOiBHcmFkaWVudENvbnRhaW5lci5UWVBFUy5SQURJQUw7XG59XG5cbldlYmtpdEdyYWRpZW50Q29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3JhZGllbnRDb250YWluZXIucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJraXRHcmFkaWVudENvbnRhaW5lcjtcblxufSx7XCIuL2dyYWRpZW50Y29udGFpbmVyXCI6OX1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIFhIUih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG5cbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIk5ldHdvcmsgRXJyb3JcIikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xuXG59LHt9XX0se30sWzRdKSg0KVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vaHRtbDJjYW52YXMvZGlzdC9odG1sMmNhbnZhcy5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55\n");

/***/ }),

/***/ 75:
/***/ (function(module, exports) {

eval("module.exports = \"static/assets/cover.4cfd217d.png\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9hc3NldHMvY292ZXIucG5nPzY0OTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcInN0YXRpYy9hc3NldHMvY292ZXIuNGNmZDIxN2QucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9hc3NldHMvY292ZXIucG5nXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75\n");

/***/ }),

/***/ 76:
/***/ (function(module, exports) {

eval("module.exports = \"static/assets/shining.a498b352.png\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9hc3NldHMvc2hpbmluZy5wbmc/ODdhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwic3RhdGljL2Fzc2V0cy9zaGluaW5nLmE0OThiMzUyLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvdmlld3Mvc2hhcmUvYXNzZXRzL3NoaW5pbmcucG5nXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76\n");

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

eval("// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvYmFieWZhbi9Eb2N1bWVudHMvcHJvamVjdC90cnVlY29sb3Ivfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcz9lNmRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIHNjb3BlSWQsXG4gIGNzc01vZHVsZXNcbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIC8vIGluamVjdCBjc3NNb2R1bGVzXG4gIGlmIChjc3NNb2R1bGVzKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmNvbXB1dGVkIHx8IG51bGwpXG4gICAgT2JqZWN0LmtleXMoY3NzTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbW9kdWxlID0gY3NzTW9kdWxlc1trZXldXG4gICAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kdWxlIH1cbiAgICB9KVxuICAgIG9wdGlvbnMuY29tcHV0ZWQgPSBjb21wdXRlZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9iYWJ5ZmFuL0RvY3VtZW50cy9wcm9qZWN0L3RydWVjb2xvci9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),

/***/ 99:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"share\"\n  }, [_c('div', {\n    attrs: {\n      \"id\": \"share\"\n    }\n  }, [_c('div', {\n    staticClass: \"share-cover\",\n    on: {\n      \"click\": function($event) {\n        _vm.share()\n      }\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"share-shining\"\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"share-middle\"\n  }, [_c('div', {\n    staticClass: \"share-middle-cover\"\n  }), _vm._v(\" \"), _c('img', {\n    staticClass: \"share-middle-left\",\n    attrs: {\n      \"src\": _vm.url1\n    }\n  }), _vm._v(\" \"), _c('img', {\n    staticClass: \"share-middle-right\",\n    attrs: {\n      \"src\": _vm.url2\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"share-span\"\n  }, [_vm._v(_vm._s(_vm.spanShare))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"share-img\"\n  }, [_c('img', {\n    staticClass: \"share-img__img\",\n    attrs: {\n      \"src\": _vm.imgShare\n    }\n  })])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"share__button\"\n  }, [_c('button', {\n    staticClass: \"share__button__left\",\n    on: {\n      \"click\": function($event) {\n        _vm.share()\n      }\n    }\n  }, [_vm._v(\" \")]), _vm._v(\" \"), _c('button', {\n    staticClass: \"share__button__right\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": function($event) {\n        _vm.crop()\n      }\n    }\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('button', {\n    staticClass: \"share__button__save\",\n    attrs: {\n      \"type\": \"button\"\n    }\n  }, [_vm._v(\"\")])])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-dd0d184a\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9pbmRleC52dWU/ZWU1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZVwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwic2hhcmVcIlxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwic2hhcmUtY292ZXJcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNoYXJlKClcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNoYXJlLXNoaW5pbmdcIlxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZS1taWRkbGVcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZS1taWRkbGUtY292ZXJcIlxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2ltZycsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZS1taWRkbGUtbGVmdFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInNyY1wiOiBfdm0udXJsMVxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdpbWcnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwic2hhcmUtbWlkZGxlLXJpZ2h0XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwic3JjXCI6IF92bS51cmwyXG4gICAgfVxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNoYXJlLXNwYW5cIlxuICB9LCBbX3ZtLl92KF92bS5fcyhfdm0uc3BhblNoYXJlKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZS1pbWdcIlxuICB9LCBbX2MoJ2ltZycsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZS1pbWdfX2ltZ1wiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInNyY1wiOiBfdm0uaW1nU2hhcmVcbiAgICB9XG4gIH0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZV9fYnV0dG9uXCJcbiAgfSwgW19jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwic2hhcmVfX2J1dHRvbl9fbGVmdFwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2hhcmUoKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIueCqyDogIBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZV9fYnV0dG9uX19yaWdodFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJidXR0b25cIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5jcm9wKClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLngrnlh7vnlJ/miJDlm77niYdcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaGFyZV9fYnV0dG9uX19zYXZlXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcImJ1dHRvblwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwi6ZW/5oyJ5Zu+54mH5L+d5a2YXCIpXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWRkMGQxODRhXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2JhYnlmYW4vRG9jdW1lbnRzL3Byb2plY3QvdHJ1ZWNvbG9yL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1kZDBkMTg0YVwifSEvVXNlcnMvYmFieWZhbi9Eb2N1bWVudHMvcHJvamVjdC90cnVlY29sb3Ivfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aWV3cy9zaGFyZS9pbmRleC52dWVcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99\n");

/***/ })

});